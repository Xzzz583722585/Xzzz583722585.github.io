

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Jon Xzzz">
  <meta name="keywords" content="">
  
  <title>DDD-001-对一个未完成项目的总结 - Jon Xzzz</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.jonxzzz.xyz","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SAmnq0afTzl9DvACTmD2ys0H-gzGzoHsz","app_key":"yxbky5wsCPQcibrgyi8HmBtm","server_url":"http://www.jonxzzz.xyz/"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Jon Xzzz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="DDD-001-对一个未完成项目的总结">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-19 19:51" pubdate>
        2021年8月19日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">DDD-001-对一个未完成项目的总结</h1>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容为ZXJY公司内部系统架构、代码、文章、讨论的归纳总结，以及本人对各问题的思考。因保密相关，涉及到敏感内容，会以网络普遍讨论的模型为例。</p>
<h2 id="ZXJY公司系统架构所面临的问题"><a href="#ZXJY公司系统架构所面临的问题" class="headerlink" title="ZXJY公司系统架构所面临的问题"></a>ZXJY公司系统架构所面临的问题</h2><p><strong>核心问题：微服务数量过多。</strong></p>
<p>ZXJY从2015年开始全面使用微服务架构后，服务的数量就开始飞涨。某些研发组甚至发展到了，一个业务功能一个微服务的程度（往往是按照数据库表来划分的，这里要埋一个坑，即微服务如何划分的实践问题）。在一开始感受到微服务带来的分工和模块化的优点之后，团队很快就碰到如何管理数量庞大的微服务的棘手问题–<strong>系统复杂程度指数级上升</strong>。</p>
<ul>
<li><p>理解困难。</p>
<ul>
<li>新人对业务逻辑与代码逻辑的映射、系统架构、代码细节、技术实现理解困难。</li>
</ul>
</li>
<li><p>开发困难。</p>
<ul>
<li>难以判断新功能放在哪个微服务更合适（或者说都可以）。</li>
<li>抽象泄漏。微服务作为SOA的一种类型，其初衷就是希望能够通过对外部提供一个合理抽象的接口，从而屏蔽内部的实现。只要接口定义不变，内部可以独立迭代，从而实现开发流程的扩展性。然而我们很难保证服务拆分和接口设计是合理的，尤其在业务快速迭代的过程中，整个系统的各种基础假设都会被持续迭代。然而一旦某个逻辑被暴露为微服务接口，其抽象就泄露到了整个系统，后续要修改或者下线这个接口的成本是极高的。这就导致了后续即使业务逻辑发生变化，我们也只能捏着鼻子在沿着错误的抽象来修修补补。</li>
</ul>
</li>
<li><p>部署困难。</p>
<ul>
<li>一个功能的上线可能涉及到多个微服务，那么怎么打包、上线顺序等等都是问题，当团队开发节奏加快后，频繁的部署使研发、运维人员苦不堪言，很多简单的修改都需要同时更新多个微服务，不但使得工作量大大增加，也使得部署的依赖更加复杂。</li>
<li>DevOps、敏捷等技术的运用遭受挑战。</li>
</ul>
</li>
<li><p>测试困难。</p>
<ul>
<li>本地代码调试困难。</li>
<li>Bug溯源、定位、追踪复杂。</li>
</ul>
</li>
<li><p>维护困难。</p>
<ul>
<li>网络波动对服务性能影响巨大。</li>
<li>对基础设施迭代不友好。数量庞大的微服务大大拖慢了基础设施迭代和推广的速度，又进一步使得微服务无法得到有效支撑。一个惨痛的现实就是，每次有紧急的基础设施升级，都必须手动升级数量庞大的微服务，带来了巨大的人力浪费。</li>
</ul>
</li>
</ul>
<h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h2><p>在讨论解决方案之前，应先定义清楚衡量系统架构的指标都有哪些（此处不由得联想到《演进式架构》，或者更广义的说，在讨论任何科学问题时，先行定义清楚问题域边界是至关重要的）。</p>
<p>在介绍最终衡量指标前，先对陶文的博客<a target="_blank" rel="noopener" href="https://github.com/taowen/modularization-examples">《代码防腐》</a>做简要陈述。代码腐败也叫软件熵，是指软件性能随着时间而逐渐恶化或反应性的递减，导致软件出错、不稳定。这并不是一个物理现象，因为软件实际上并不会衰变，而是缺乏敏捷反应、未能随环境变化而修改。显然，正如《没有银弹》一文所说，由于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">软件本质性</a>所引发出的 complexity、invisibility、conformity、changeability，再加上许多人为因素：软件开发者本人所处时空限制、能力限制导致其并不能做出现在看来“完美”的设计；商业软件本身需要去衡量各种成本，包括资金、人力、时间等等；缺乏完善的测试等。以上因素，导致开发者不得不在本就困难的问题基础上，缺乏思考、设计的情况下赶工开发，致使问题影响范围扩大，又由于没有严格的测试拦截，导致问题得不到有效的反映和遏制，再加之缺乏复盘性的总结学习，导致问题越来越难以解决，即腐败的味道愈加浓重。</p>
<p>什么样的系统是我们所希望的，我们又要如何去发现代码腐败。</p>
<p>首先陶文指出了系统应该具备的三点特性，现做出总结。</p>
<ul>
<li><p>Autonomy 独立性。</p>
<p>开发团队担心出现这样的症状：</p>
<ul>
<li>沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。</li>
<li>需求下线困难：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。</li>
</ul>
<p>独立性的愿景就是尽量减轻上述的症状，让拆分出来的代码更独立。用以下指标衡量系统的独立性：</p>
<ul>
<li>会议时间。</li>
<li>接口改动次数 / 接口实现改动次数 比率：我们期望大部分时候就可以只改接口实现，而不改接口本身。</li>
</ul>
</li>
<li><p>Consistency 一致性。</p>
<p>一致性是对可复用 git 仓库的要求，是为了防御常见的设计错误。用以下指标衡量系统的一致性：</p>
<ul>
<li>必要参数总量 / 参数总量 比率：把可复用 git 仓库对外提供的函数的参数分为两类，必要参数和非必要参数。非必要参数是指只有 10% 的调用方传递了的参数。</li>
<li>咨询量：可复用的 git 仓库，应该努力降低使用者的成本。 使用者的最大成本来自于沟通问询。如果文档不清楚，接入方式是手工的，必然会体现在咨询量上。</li>
<li>接入次数：使用次数只有1次或者2次，就不应该被抽取成可复用的 git 仓库。至少要被使用3次。</li>
<li>接入率：如果要抽出可复用的代码，出发点应该是一致性，是在团队关键成员达成了一致之后的有意识行为。</li>
<li>阻断率：阻断率指所有可接入的地方，有多少处上了强制检查，确保了违规行为会被阻断。</li>
</ul>
</li>
<li><p>Feedback 反馈性。</p>
<p>业务逻辑无论如何做拆分，最终仍然是要集成到一起跑起来的。 无论是编辑时拆分成文件、文件夹、git 仓库，还是运行时拆分成进程，拆分无可避免地引入了“降低反馈速度”的副作用。 一旦产生了分工，就会有你不了解的部分。这也是分工的本意所在，控制知识边界，让普通人也可以参与劳动。 但是软件是要整体集成到一起才能发挥其全部价值。这种“整体”与“部分”的矛盾，造成了反馈性问题。</p>
<p>开发团队担心出现这样的症状：</p>
<ul>
<li>故障定位慢。</li>
<li>获得真实反馈慢：代码写完了要等审核发版，错过了这个版本又要等一个月公司才会发下个版本。</li>
<li>本地测试难：稍微有点价值的测试都不是本地可以用 JUnit 写出来的。</li>
<li>与用户脱轨。</li>
</ul>
<p>反馈性的愿景是尽量减少获得反馈的摩檫力。业务逻辑拆分为什么会影响到反馈性呢？这仍然是要归结为人的沟通效率问题（《人月神话》）。能用标准化的方式解决的，就可以减少沟通。能尽量减少信息传递次数的，就可以有效减少传递过程中的信息衰减。用以下指标衡量系统的反馈性：</p>
<ul>
<li>工单流转时长。</li>
<li>故障定位时长。</li>
<li>代码集成时长。</li>
</ul>
</li>
</ul>
<p>其次陶文给出了应对代码腐败的策略。</p>
<ul>
<li><p>信息隐藏：封装、抽象、依赖倒置。</p>
<p>在依赖倒置的前提下，需要显式地提炼出最小化接口， 从而让更多的需求改动封闭在更上层的依赖关系里，更多去改实现代码，而不是改接口代码。</p>
<p>还有一个问题是，如何做到独立性？这里不能依赖人力的 code review，而应该依赖代码结构，限制改动范围。如此一来，模块的 git 仓库是不会造成全局影响。我们就可以放心的把新人分配去写一个独立的模块，而不用担心其设计选择造成大面积的代码腐化。code review 仅需要集中关照主板。并且评价“高内聚低耦合”的标准也可以用主板的代码改动行数进行量化（在完成需求的前提下，主板的代码改动行数越少越好）。</p>
</li>
<li><p>分层</p>
</li>
<li><p>持续改进</p>
<p>只对自己写的代码负责要体现在发布变更，告警定位这两个环节里。做好了这两点，就有了持续改进系统的基础保障。</p>
<ul>
<li><p>发布变更。单体应用最大的原罪就是变更的粒度太大了。而大粒度变更是稳定性的最大敌人。 切分变更有三种主要的做法：</p>
<ul>
<li><p>多进程：把单体进程切分成多进程，控制的是代码的变更。一次只变更其中的一个。因为大部分线上故障都是由变更引起的，所以 SRE 会非常强调部署流程的小心谨慎。 一旦发现有问题，就会被要求立即回滚。这也就导致了搭车上线是非常讨厌的事情，谁知道你搭车进来的改动会不会翻车。 所以拆分成多进程，各上各的就会变成非常强烈的需求。</p>
<p>但是用拆分进程的方式来解决上线慢的问题也会有一些缺点：</p>
<ul>
<li>反馈不集中：小流量的时候，引起的小规模的故障可能观察不出来。</li>
</ul>
</li>
<li><p>灰度数有限：集群规模比较小的时候，总共就几个进程，灰度的刻度就会很大。</p>
<ul>
<li>回滚慢：进程替换需要时间。</li>
</ul>
</li>
<li><p>灰度时间有限：上线观察一天已经很夸张了，要更长时间的观察是不好用上线的方式来实现的。</p>
<ul>
<li>上线顺序：进程之间经常有数据依赖，并不能总是保持向后兼容。</li>
</ul>
</li>
<li><p>多租户：把所有的业务数据分成租户，控制的是数据的变更。一次只升级一个租户的数据和代码。</p>
</li>
<li><p>多变种：分租户还是粒度太粗了，比如说挂掉一个城市也是不可接受的。那么可以在线上同时运行多个版本的代码，然后逐步的切流量，这其实控制的是配置的变更。在不改变进程的情况下，通过配置等方式更灵活地进行装配组合。这样发布和上线就可以解开为两个操作了。上线就是上线，改变进程里的可执行代码。 上线可以不把 feature flag 打开，而是保持原有的行为。 然后再慢慢地打开 feature flag 的流量开关。</p>
</li>
</ul>
<p>当然更极致的做法是同时分租户，也在租户升级的时候切流量。</p>
</li>
<li><p>告警定位</p>
<p>要减轻分工带来的负面影响，最重要的是做好“隔离”。虽然我们把所有的部件都集成到了一起了，但是我们仍然要在“运行时”通过各种手段人为制造出边界，把责任隔离出来。 把责任隔离出来，就是把运行时的行为，与背后负责的团队与个人对应起来。</p>
<ul>
<li><p>进程边界</p>
<p>把不同的 git 仓库跑在不同的进程里。这样只要看是哪个进程出的问题，就可以知道问题是由哪个 git 仓库引起的了。</p>
<p>进程边界的优点如下：</p>
<ul>
<li>完善的跨进程调用监控：相比进程内调用，跨进程调用的监控基础设施要完善得多。</li>
</ul>
</li>
<li><p>操作系统强制的配额和安全性：基础设施更好。</p>
<ul>
<li>隔离的内存状态：进程之间不会共享内存，从而产生监控逃逸的影响。</li>
</ul>
<p>进程边界的缺点如下：</p>
<ul>
<li>适用场景：在前端里启动独立的进程不是常规的做法。</li>
</ul>
</li>
<li><p>性能优化会漏掉依赖：经常我们会把配置等数据读取一次之后就缓存在进程内。这部分依赖就很容易逃逸出监控的范围。</p>
<ul>
<li>远离用户：拆分出来的进程往往是越来越靠后台，离用户越远，就越难以倾听到用户的声音。</li>
</ul>
<p>我们的目标是在出问题之后，能从运行时的现象找到对应的 git 仓库。</p>
</li>
<li><p>函数边界</p>
<p>无论是编程语言原生支持的同步调用栈，还是需要自研的异步调用栈，其目的都是隔离，从而给 caller/callee 关系建索引。</p>
</li>
<li><p>模块边界</p>
<p>如果有强制的模块规范，那甚至可以做到“内存状态”的隔离，用编译检查等手段禁止全局变量，禁止偷偷地访问另外一个模块的内部状态。 一个进程要读取一份配置，只有第一次RPC的时候我们才能监控到，后续缓存在内存里的访问就是不可见的了。 而模块则不用担心跨模块调用的开销，我们可以把配置缓存在另外一个模块里，这样每次读取配置都是跨模块的调用，从而可以被监控到。</p>
<p>模块和进程的核心区别就是模块可以适用于更多的运行时（比如iOS，微信小程序），可以用于拆分运行时调用关系更频繁更紧密的界面和流程。 进程边界的优势来自于社区共识，提前提供了大量开源的优秀基础设施。 但是并不意味着，除了进程边界，我们不能在进程内再为每个 git 仓库划出边界来，只是要付出一些自研代价罢了。 社区共识是不够的，在函数边界（特别是同步调用栈之外的其他调用关系），以及模块边界上都没有足够强的规范。 只要能在公司或者部门级别建立好共识，函数边界和模块边界完全可以满足问题定位的需求，甚至比进程边界做得更好。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>现给出ZXJY公司对于系统的衡量指标。</strong></p>
<ul>
<li>rpc 接口总数量。</li>
<li>接口改动次数 / 接口实现改动次数 比率。</li>
<li>微服务调用链上依赖关系的数量。</li>
<li>一次需求平均所需修改的 git 仓库数量</li>
<li>一个需求上线所需的时间。</li>
<li>没有循环依赖。依赖和耦合的最大区别在于，当我们说“A和B耦合”时，在字面含义中，A和B二者平等。然而，正确的模块关系根本不应该平等，而应该是单向依赖才对。所以我们应该说“A依赖B”，这样含义要清楚得多。A依赖B意味着，A模块可以调用B模块暴露的API，但B模块绝不允许调用A模块的API。单向依赖是红线，好的设计一定不会违反这条红线。</li>
<li>正交性：指一个模块提供的API中，多个方法之间是否有重复的功能。</li>
<li>紧凑性：指一个模块提供的API中，公有方法总数必须很少，每个方法的参数也必须很少。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>核心思路：降低微服务数量。</strong></p>
<p>为了更好的管理系统的复杂度，减缓系统的腐化，我们的架构目标主要是：</p>
<ul>
<li><p>服务接口的合理与简单高于具体功能实现的优雅。系统复杂度主要来自于服务对外的接口，因此我们的架构重点关注接口设计，而内部实现可以相对灵活。</p>
</li>
<li><p>易于迭代高于强大的预先设计。当前业务灵活多变而团队经验较为欠缺，很难做好太多预先设计，但系统必须具备快速迭代的能力。</p>
</li>
<li><p>团队和系统的自治高于功能复用。功能复用很容易带来沟通成本上升、抽象泄露、以及功能分化的风险。</p>
</li>
<li><p>风格的简单一致高于追求技术完美。</p>
</li>
<li><p>工具和自动化高于灵活与精确。我们希望尽可能的利用工具和自动化来阻断不合理的设计，降低对人的依赖。</p>
</li>
</ul>
<p><strong>核心方案：区分“项目”和“服务”。一个项目对应一个代码仓库（git repo），规模可以适当大一些，应当包含一个领域内的大部分逻辑。一个服务对应一个进程，可以是项目中的一个 module 或者是一个单独的 entrypoint。基础架构的部署系统提供了便于部署项目的能力，即项目中的代码修改之后，可以自动部署所有关联的服务。</strong></p>
<p>微服务架构最大的好处是给出了非常清晰的模块边界。以前我们会让一个微服务来对应一个功能模块，导致粒度非常细。问题在于随着业务的变化，边界也是会随之变化的，如果我们过早通过微服务来实现边界，后续修改的成本是极高的。因此我们不应该再轻易独立出微服务，而是尽量在服务内部划分清晰的功能边界。</p>
<p>目前我们的服务架构都是遵照三层架构，基本分为展示层、逻辑层、存储层，每一层内没有更多划分模块的规范。因为我们把系统功能拆分成为多个微服务，而且之前实践中往往把微服务拆的过小，因此一般逻辑都比较简单，每一层内不隔离问题也不大。不过之后每个微服务要处理相对完整的业务逻辑，粒度会变大，单个服务的复杂度会上升。因此简单的按层次来划分已经不够，此时的最佳实践应当是根据功能来划分。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面剖析电商项目。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/images/DDD/001/logic_view.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/DDD/001/code_struct.png" srcset="/img/loading.gif" lazyload></p>
<p>项目整体结构参考六边形架构，将业务逻辑隐藏在 backend 模块内，即六边形的内部。</p>
<p><img src="/images/DDD/001/code_struct_admin.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/DDD/001/code_struct_consumer.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/DDD/001/code_struct_job.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/DDD/001/code_struct_rpc.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/DDD/001/code_struct_web.png" srcset="/img/loading.gif" lazyload></p>
<p>admin、consumer、job、rpc、web 都属于接口，分别对应了web（B端与C端）、mq、定时任务、rpc这些系统可能的调用方，满足其需求。可以看出，接口相互之间互不影响，当需要满足新的调用方式时，只需要添加对应的模块，处理对应的请求即可，真正的业务逻辑永远保持在领域内。</p>
<p><img src="/images/DDD/001/code_struct_client.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/DDD/001/code_struct_common.png" srcset="/img/loading.gif" lazyload></p>
<p>由于使用 thrift 作为 rpc 协议，故在 common 模块内定义 thrift schema，在 client 封装对于 thrift 借口的调用，方便调用方使用。而 rpc 请求真正的处理者，是前文所讲的 rpc 模块内的 rpc handler。</p>
<p><img src="/images/DDD/001/code_struct_backend.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>application</p>
<p>application 层是对对外所暴露接口的实现，属于主适配器，有编排多个领域以及防腐层的职责。</p>
<p>usecase 实现了上层所有接口，通过编排各个领域中 service 所提供的基本能力，实现业务动作。如创建订单，我们需要查询商品、修改库存、使用优惠券、创建订单实体等一系列复杂行为，但是他们按照我们之前的领域划分，很有可能分属于不同领域，那么这时候就可以通过 usecase 将他们融合在一起。</p>
<p>commond/query CQRS模式中的 command 和 query。简单介绍，CQRS是一种读写分离模式，command 代表了对数据产生变化的操作，一般是新增、删除、更新，query 代表了不对数据产生变化的操作，一般是查询。在没有 CQRS 的系统中，不论是何种类型的请求分别经过 controller、service、storage 查询到数据库，再分别经过 storage、service、controller 返回给前端显示。但是从数据层面我们就知道，不同系统对于读写两类请求的需求与支持是不同的。故在 CQRS 模式中，读/写两类请求分别走不同的接口与路径，甚至可以实现为读/写访问不同的数据存储。</p>
<p>dto 是防腐层数据接口，将外部数据类型与领域内实体解耦。举例来说，thrift 接口使用的数据类型是在 thrift 文件中定义的 struct 通过 thrift 命令行命令生成的，rpc 接口的调用方和提供方都使用此数据结构，但是，领域中肯定使用 entity 实体与 model 值对象作为数据结构，这就需要 dto 作为中间层的数据结构，首先解耦了两边数据结构的直接关联，其次在整个 application 层都可以使用 dto 代表编排聚合后的数据结构。</p>
</li>
<li><p>component</p>
<p>严格来说，component 是真正的领域层，component 包下的每个子包，即对应了 DDD 中的一个子域（对于该项目，仍然是一个限界上下文对于一个子域）。其中 trade 属于核心域，负责交易相关内容，如查询订单、创建订单、预支付（创建支付订单与第三方支付单）、退款订单等。product 负责查询商品、查询优惠券、发送优惠券、使用优惠券、查询礼包等。</p>
<p>entity 实体是拥有 id（可能是多主键） 的对象。深入的说，抛开具体存储的技术不谈（不管是什么类型的数据库，还是文件等等），实体是可以被它的 id 唯一标识的，除了 id 以外的所有属性，都只是为了描述该实体，不能通过这些属性去判断两个实体是否相等。</p>
<p>model 值对象是没有 id 的对象。同理，一个值对象就是根据其属性所决定的，但是这里并没有说所有属性，具体判断两个值对象是否相等，由具体业务决定。</p>
<p>举个例子：社会上有很多人都叫王浩，但是他们的身份证 id 不同，从社会角度来说，他们就是两个完全独立的人。但是，市场上有很多同样品牌、同样款式、同样颜色、同样大小的衣服，在很多场景下，我们在 A 地看见这件衣服，当我们在 B 地再次看见时，就可以说是同一件衣服，我们没有给衣服编号的必要性，我们只是觉得根据这些属性去判断就足够了。当然，再次强调，这只是例子，如果你在开发的是某纺织工厂的系统，就是要为每一批产品，甚至每一件衣服编号，那这就是你的业务所需要的，衣服或许就应该是一个实体。</p>
<p>除此以外，entity 实体在内存中是可以变化的，可是 model 值对象不可以变化，即 model 值对象查询到以后，其所有属性值都是不可变的，没有 setter 方法。</p>
<p>port/repository 都属于从适配器，定义了领域所需要的底层逻辑接口。区别是，在此项目中，repository 所定义的接口都属于对某个 entity 实体的 CRUD。port 则没有此限制，仅代表了接口的含义。需要注意的是，现如今有很多 ORM 框架都只需要定义 java interface，由框架本身实现具体的增删改查逻辑，如 Mybatis、Hibernate 等。但是，把这些框架放在六边形架构中，就产生了一个问题，即领域内所定义的 repository 接口，是和具体实现（具体 ORM 框架）所绑定的，这是绝对不允许的，即领域内只关心业务问题，只要牵扯到了底层技术实现问题，那就是错的。所以，在使用这些框架时，我们依然把 repository 接口当作普通的抽象定义，在实现层，用这些框架的写法去定义框架所需要的 interface，来作为对 repository 的实现。</p>
<p>service 实现了领域内的业务逻辑。如创建订单、创建退款单等，注意，这里的每个动作，都是单一领域内的完整动作，即只是创建了一个“订单”而已（粗暴的理解，只是在订单表插入了一条记录，但这只是为了理解，切记，领域内不关心具体实现，具体实现可能要复杂很多），至于我们平常所认知的创建订单–商品、优惠券、活动等等相关概念的处理，他们都不属于此领域，故 service 中不牵扯这些概念。</p>
</li>
<li><p>infrastructure</p>
<p>六边形架构中的从适配器，用于对接数据、业务逻辑的底层实现，并且承担了防腐层的职责。以电商项目为例，商品、订单等功能对接电商中台，故查看商品详情、创建订单、退款订单等动作，底层数据、甚至逻辑就存储在“电商中台”。优惠券、代币等属于业务部门的功能，底层数据选择使用 mysql 存储。回想之前的主适配器，可以看出在整个六边形架构中，整个架构的依赖方向是向内的，即指向领域中心。用来约定外层行为的方式就是抽象，彻底与外层解耦。</p>
<p>对于领域内部而言，这些细节是不重要的，领域内不需要清楚具体的实现细节，对它而言，它只是根据约定，即 port/repository 所定义接口中声明的方法与数据结构，来实现领域的业务动作。</p>
</li>
</ul>
<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>微服务数量变少之后，可以很大程度上改善抽象泄露的问题，一个领域内的逻辑可以尽量保持在一个项目内部，不需要对外暴露内部接口。</p>
</li>
<li><p>在我们的基础设施足够强悍之前，微服务的数量变少总是可以大大的方便各种基础库的迭代。</p>
</li>
<li><p>项目内部的调用不需要过 rpc，可以充分利用 IDE 的自动化重构能力，在运行效率和开发效率上都会有明显提升。</p>
</li>
<li><p>项目足够自治，对外部依赖较少，更加便于自动化测试。</p>
</li>
<li><p>只有确实跨领域的逻辑才需要对外暴露接口，对于这些接口也可以进行更严格的 code review。如果微服务数量和拆分相对合理，应当期望微服务对外接口的变动是相对少的。这样我们可以强制要求所有涉及到接口变动的修改应当有更加严格的 code review 流程，从而保证系统设计的合理性。而微服务内部的变动可以相对灵活，因为重构和测试的成本都是较小的。</p>
</li>
<li><p>更易于消除循环依赖。</p>
</li>
<li><p>服务这一层抽象不是为了解决功能的划分，但是提供了两个益处：</p>
<ul>
<li>不同服务对应独立进程，提供了一定的运行时隔离，也便于单独扩容</li>
<li>一些展示层的代码可以放在上层模块中，使得模块之间容易避免循环依赖</li>
</ul>
<p>虽然不同服务对应了不同的进程，但是因为底层逻辑和存储都是共享的，因此只是提供了非常有限的隔离性。新建和删除服务的成本相对较低。但是每个服务都需要单独的部署，因此服务拆分也不宜太细。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>仓库规模更大，打包、编译、自动化测试等步骤可能更加耗时，一次部署涉及的服务数量会更多。虽然对于单个仓库的操作效率会降低，但是减少了一次需要所涉及的仓库数量，所以整体效率还是提升的。</li>
<li>多人开发同一仓库的情况变的更加严重，修改冲突的机会变大。大部分的修改应该是局限在一个 module 内部，甚至 module 内的一个 package 内部，通过限制修改范围，可以很大程度上避免冲突。</li>
<li>因为迭代是以项目为单位，中间的某些稳定模块也会因为其他模块的更改而多次部署。理论上基础架构的改进应当使得部署本身更加轻松和稳定，不会影响到整个系统的稳定。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Domain-Driven-Design/">Domain Driven Design</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SAC-001-概述</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/19/GO-GO-GO/">
                        <span class="hidden-mobile">GO!GO!GO!</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"64e7a0af76ea907275e7","clientSecret":"58fc6a6232d3179936704144df3ddeef170c2fdd","repo":"bolg-comment","owner":"Xzzz583722585","admin":["Xzzz583722585"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '423800a790ac446aec9ba5298cf3b8cb'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
