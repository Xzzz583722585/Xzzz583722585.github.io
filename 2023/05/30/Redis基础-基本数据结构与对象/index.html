

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Jon Xzzz">
  <meta name="keywords" content="">
  
  <title>Redis基础-基本数据结构与对象 - Jon Xzzz</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.jonxzzz.xyz","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SAmnq0afTzl9DvACTmD2ys0H-gzGzoHsz","app_key":"yxbky5wsCPQcibrgyi8HmBtm","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Jon Xzzz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis基础-基本数据结构与对象">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-05-30 23:44" pubdate>
        2023年5月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        浏览 <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis基础-基本数据结构与对象</h1>
            
            <div class="markdown-body">
              <p>我们使用redis时，最直观接触到的就是redis对象及其命令。那我们今天就一起了解下这些对象的实现细节。</p>
<h1 id="一-基本数据结构"><a href="#一-基本数据结构" class="headerlink" title="一.基本数据结构"></a>一.基本数据结构</h1><h2 id="1-简单动态字符串-SDS"><a href="#1-简单动态字符串-SDS" class="headerlink" title="1.简单动态字符串 SDS"></a>1.简单动态字符串 SDS</h2><p>redis是用C语言实现的，我们需要先认识一下C语言里面的字符串（以下简称C字符串）。</p>
<p>“Redis\0”这是一个C语言字符串，它具有以下特点：</p>
<ul>
<li>必须以 ‘\0’ 空字符结尾</li>
<li>系统不维护该字符串的长度（不像java的String类型有length），获取字符串长度必须遍历整个字符串，即时间复杂度为 O(n)</li>
<li>每次更改（缩短或增长）字符串都需要重新内存分配，否则可能造成内存泄漏或缓冲区溢出</li>
<li>只能保存文本数据</li>
<li>C语言有相关代码库，支持各类字符串操作</li>
</ul>
<p>对于redis而言，只有像log这类字符串一定没有变化的场景会使用C字符串实现以外，其余大多数场景都使用它自己的SDS来实现字符串，例如：</p>
<ul>
<li>命令里的key和value SET name “xqz”</li>
<li>各类嵌套对象 [“a”, “b”]</li>
<li>缓冲区：AOF缓冲区、客户端的输入输出缓冲区</li>
<li>等等</li>
</ul>
<p>SDS的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDS</span> </span>&#123;<br>	<span class="hljs-comment">// 记录buf中已经被使用的长度</span><br>  <span class="hljs-keyword">int</span> len;<br>  <span class="hljs-comment">// 记录buf中没有被使用的长度</span><br>  <span class="hljs-keyword">int</span> free;<br>  <span class="hljs-comment">// 实际存储字符串的地方</span><br>  <span class="hljs-comment">// 其末尾以&#x27;\0&#x27;结尾，不记录在上述两个长度内，即SDS实际字符长度为 len+free+1</span><br>  <span class="hljs-keyword">char</span>[] buf;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，我们可以解释 SDS 名称的由来：</p>
<ul>
<li>简单：相比于C字符串，要获取SDS内的字符串长度，可以直接通过len字段，时间复杂度为 O(1)</li>
<li>动态：每次对 SDS增长时，redis都会自己检查free是否充足，如果不够，那么就会自动进行内存分配以获取足够的空间，即redis保证了不会发生缓冲区溢出</li>
</ul>
<p>那么，我们又引申出一个小问题，那就是sds的内存分配策略：</p>
<ul>
<li>字符串增长时<ul>
<li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li>
<li><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/sds_edit.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>字符串减短时<ul>
<li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li>
</ul>
</li>
</ul>
<p>总结，SDS相比于C字符串的特点是：</p>
<ul>
<li>实际也以 ‘\0’ 空字符结尾</li>
<li>获取字符串长度的时间复杂度为 O(1)</li>
<li>每次更改（缩短或增长）字符串，调用者不需要重新内存分配，redis会保证不造成内存泄漏或缓冲区溢出</li>
<li>sds的所有api都是二进制安全的，即sds不仅可以保存文本数据，还可以保存任意格式的二进制数据</li>
<li>因为实际以 ‘\0’ 字符结尾，可以使用C语言相关代码库</li>
</ul>
<h2 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2.双向链表"></a>2.双向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> </span>&#123;<br>  <span class="hljs-comment">// 头节点指针</span><br>  ListNode head;<br>  <span class="hljs-comment">// 尾节点指针</span><br>  ListNode tail;<br>  <span class="hljs-comment">// 链表总长度</span><br>  uint64 len;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 前一个节点指针</span><br>  ListNode pre;<br>  <span class="hljs-comment">// 后一个节点指针</span><br>  ListNode next;<br>  <span class="hljs-comment">// 指向具体内容的指针</span><br>  Object value;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-键值对映射（字典）"><a href="#3-键值对映射（字典）" class="headerlink" title="3.键值对映射（字典）"></a>3.键值对映射（字典）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dict</span> </span>&#123;<br>  <span class="hljs-comment">// 为对象多态服务，DictType保存了针对每种不同类型键值对的特定函数</span><br>  DictType type;<br>  <span class="hljs-comment">// 为对象多态服务，保存了不同特定函数的可选参数</span><br>  Object privData;<br>  <span class="hljs-comment">// ht[0]指向正在使用的hash表，ht[1]正常情况下指向null，rehash过程中指向即将迁移过去的hash表</span><br>  DictHt[] ht;<br>  <span class="hljs-comment">// rehash索引</span><br>  <span class="hljs-keyword">int</span> rehashidx;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictHt</span> </span>&#123;<br>  <span class="hljs-comment">// hash桶，存储具体数据</span><br>  DictEntry[] table;<br>  <span class="hljs-comment">// 桶大小</span><br>  uint64 size; <br>  <span class="hljs-comment">// 桶已使用大小</span><br>  uint64 used;<br>  <span class="hljs-comment">// 用于计算对象下标，sizemask=size-1</span><br>  uint64 sizemask;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictEntry</span> </span>&#123;<br>  <span class="hljs-comment">// 只能是字符串类型</span><br>  Object key;<br>  <span class="hljs-comment">// 对象多态</span><br>  <span class="hljs-comment">// 另外，并没有使用字符串对象处理整数和普通对象，下面讲字符串对象时会涉及</span><br>  union &#123;<br>    <span class="hljs-comment">// value类行为对象</span><br>    Object v;<br>    <span class="hljs-comment">// value类型为无符号整数</span><br>    uint64 u64;<br>    <span class="hljs-comment">// value类型为有符号整数</span><br>    int64 s64;<br>  &#125; value;<br>  <span class="hljs-comment">// 拉链法解决hash冲突：key相同的下一个value对象</span><br>  DictEntry next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然提到hash，那么着重解决一下几个问题：</p>
<ul>
<li>hash函数怎么选择？</li>
<li>hash冲突如何解决？</li>
<li>如何维护hash冲突的概率？</li>
</ul>
<h3 id="3-1-hash函数如何选择？"><a href="#3-1-hash函数如何选择？" class="headerlink" title="3.1.hash函数如何选择？"></a>3.1.hash函数如何选择？</h3><p>redis选用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C">murmurhash2</a>算法生成key对应的hash值，记做hash(key)，则最终插入下标index=hash(key) &amp; ht[x].sizemask。这里面信息量比较大，我们一一介绍：</p>
<ul>
<li>若N为2的n次幂，则 H%N = H&amp;(N-1)，这是快速计算方式，并且后续会看到redis保证桶大小为2的n次幂（java的HashMap也有类似设计），这里也解释了为什么会有一个sizemask字段</li>
<li>ht[x]的含义是，若当前字典不是rehash状态，则x=0，否则x=1</li>
</ul>
<h3 id="3-2-hash冲突如何解决？"><a href="#3-2-hash冲突如何解决？" class="headerlink" title="3.2.hash冲突如何解决？"></a>3.2.hash冲突如何解决？</h3><p>一般的hash冲突解决方法有两种：开放定址法和拉链法，redis和java.HashMap均采用拉链法，即将hash到相同桶下标的entry组织成一个链表（java的HashMap在链表长度大于8时，会将该链表转换为一棵红黑树，即平衡树，依次来提高检索效率）。</p>
<p>另外，此处的链表不是双向链表，所以采用头插法快速添加新节点（多嘴说一句，并发环境下，头插法可能产生循环链表问题，jdk8前后的解决方法并不相同，感兴趣的小伙伴可以搜一搜，但是单线程的redis并不存在这个问题）</p>
<h3 id="3-3-如何维护hash冲突的概率？"><a href="#3-3-如何维护hash冲突的概率？" class="headerlink" title="3.3.如何维护hash冲突的概率？"></a>3.3.如何维护hash冲突的概率？</h3><p>介绍一个概念：负载因子=桶已被使用的大小/桶总大小，可以看出，若负载因子过大，则产生hash冲突的可能性就更高，若负载因子过小，则空间利用率就变低。因此，根据负载因子大小，在合适的时机调整桶大小就变的尤为重要。</p>
<p>下面是redis执行的rehash的具体步骤：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/rehash.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>负载因子过大：<ul>
<li>服务器没有执行 <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/server-bgsave.html">BGSAVE</a> 或 <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/server-bgrewriteaof.html">BGREWRITEAOF</a> 命令时，&gt;=1，这是因为这些命令都会采取写时复制的手段来优化子进程的执行效率，那么就需要降低非必要的内存写入操作</li>
<li>服务器执行 BGSAVE 或 BGREWRITEAOF 命令时，&gt;=5</li>
</ul>
</li>
<li>负载因子过小：&lt;0.1</li>
</ul>
<p>最后，需要注意，rehash过程不是一次性完成的，而是延迟、渐进式的完成的，其过程是：</p>
<ol>
<li>rehash开始，将rehashidx置为0，代表rehash开始</li>
<li>其后每次对该字典有增删改查（包括rehash开始时的那一次）操作时，都会将ht[0]桶rehashidx位置上的数据重新写入到ht[1]桶内，删除ht[0]桶rehashidx位置上的所有数据，rehashidx++</li>
<li>当ht[0]桶上所有数据都迁移完成后，将rehashidx置为-1，代表rehash结束</li>
</ol>
<p>很明显，在rehash期间，插入操作会直接在ht[1]桶上完成（保证ht[0]只减不增，另外，先插入到ht[0]再rehash到ht[1]也太傻了），删除、更改、查询操作都会先检索ht[0]，数据不存在时再检索ht[1]得到最终结果</p>
<h2 id="4-跳表"><a href="#4-跳表" class="headerlink" title="4.跳表"></a>4.跳表</h2><p>鉴于大学的数据结构课本或者《算法导论》这样的书上都没有跳表的内容，所以我们得先介绍下跳表这种数据结构（这里奉上原始论文，感兴趣的同学可以看看<a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf%EF%BC%89%E3%80%82">https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf）。</a></p>
<p>这是一个链表：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist1.png" srcset="/img/loading.gif" lazyload></p>
<p>我们给他加一点索引，用来加快检索速度：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist2.png" srcset="/img/loading.gif" lazyload></p>
<p>当数据量特别大的时候，我们可能需要多层索引，获取更好的检索速度：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist3.png" srcset="/img/loading.gif" lazyload></p>
<p>好了，我们可以做一个优化，即相同元素（初始元素及该元素代表的索引）只使用一个节点即可。</p>
<p>这就是跳表，我们来看下跳表如何检索一个元素（下述跳表中查找71）：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist4.png" srcset="/img/loading.gif" lazyload></p>
<p>其时间复杂度 = 索引的高度 * 每层索引遍历元素的个数，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。那么跳表的总高度 h = log2n。并且，上层两个索引中间对应的下层索引个数最多为3，即时间复杂度=O(log2n)。</p>
<p>空间复杂度显然等于 n/2+n/4+…+n/h=O(n)。</p>
<p>那么，接下来的问题就变成了，随着元素的插入/删除，我们应该如何去维护跳表的索引，以使其保持优良的性能？</p>
<p>一种设计方案是，还是假设每两个结点会抽出一个结点作为上一级索引的结点，那么当本层元素大于3时，我们就要将其分裂为两部分，并且在上层添加这两部分的索引。删除同理。好了，说到这你应该意识到，这是B树的设计。</p>
<p>另一种方案，即跳表天才的设计，用概率来维护索引。即每个元素都有1/2的概率建立上层索引，当数据量足够大时，我们有理由相信这种概率建立起来的索引是离散的，即所有元素不会堆积在一起。</p>
<p>那么，我们来看一下跳表如何插入元素。假设在我们插入元素时，有一个函数randomLevel(x)，其返回值表示应该为这个元素新建几层索引。例如，randomLevel(x)=2，则新建1层索引。我们保证，randomLevel(x)函数有1/2的概率返回1，有1/4的概率返回2，以此类推。有的小伙伴会问，为什么不是randomLevel(x)=1新建一层索引呢？这是因为，只要randomLevel(x)&gt;1那么就会新建第一层的索引，那么randomLevel(x)=1的概率为1/2，就等同于第一层索引不被建立的概率等于1/2，那么，只要randomLevel(x)=2我们再开始建立索引就可以了。</p>
<p>我们举一个插入87的例子，randomLevel(87)=3，</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist5.png" srcset="/img/loading.gif" lazyload></p>
<p>最后看一眼删除（删除87），我们只需要该元素整个删除即可（包括该元素代表的索引）：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist6.png" srcset="/img/loading.gif" lazyload></p>
<p>至此，我们可以介绍下redis的跳表了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br>  <span class="hljs-comment">// 指向跳表头节点</span><br>  <span class="hljs-comment">// 头节点不是实际的元素节点，即不计算在level、length内</span><br>  SkipListNode header;<br>  <span class="hljs-comment">// 指向跳表尾节点</span><br>  <span class="hljs-comment">// 尾节点是实际的元素节点</span><br>  SkipListNode tail;<br>  <span class="hljs-comment">// 层数最大的节点的层数</span><br>  <span class="hljs-keyword">int</span> level;<br>  <span class="hljs-comment">// 节点个数</span><br>  <span class="hljs-keyword">int</span> length;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 分数，redis跳表通过分数作为元素插入位置的依据</span><br>  <span class="hljs-comment">// 分数按从小到大的顺序排列</span><br>  <span class="hljs-comment">// 不同元素分数可以相同，但是对象不能相同。相同分数的不同对象按照字典序排列。</span><br>  <span class="hljs-keyword">double</span> score;<br>  <span class="hljs-comment">// 对象指针</span><br>  Object obj;<br>  <span class="hljs-comment">// 后退指针，指向紧邻的前一个元素。注意，后退指针不参与跳表的索引结构，就像B+树的叶子结点链表一样，将所有的元素节点连接起来。方便检索范围内的所有数据。</span><br>  SkipListNode backward;<br>  <span class="hljs-comment">// 层（上述的各层索引）</span><br>  <span class="hljs-comment">// Level1-Level32，L1可以看做之前讲的基础数据，L2-L32可以看做索引</span><br>  SkipListLevel[] level;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListLevel</span> </span>&#123;<br>  <span class="hljs-comment">// 前进指针，指向拥有同层索引的下一个节点</span><br>  SkipListNode forward;<br>  <span class="hljs-comment">// 跨度，注意，跨度并不参与实际的检索过程（有疑惑的抛开redis再看看前面的跳表介绍），只是用于计算同层两个节点间的元素个数</span><br>  uint32 span;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，我们看一下redis如何实现前述的randomLevel(x)函数的：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png" srcset="/img/loading.gif" lazyload></p>
<p>上述代码等同于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">func <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level+1</span><br>  <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>    level += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可见，redis设置的SKIPLIST_P=0.25，即每4个元素生成一个上层索引</p>
<h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSet</span> </span>&#123;<br>  <span class="hljs-comment">// 编码方式（注意与之后对象结构内的编码方式区分）</span><br>  <span class="hljs-comment">// 目前支持：int16、int32、int64</span><br>  uint32 encoding;<br>  <span class="hljs-comment">// 集合长度，即元素个数</span><br>  uint32 length;<br>  <span class="hljs-comment">// 具体数据，不会有重复值，按值大小从小往大排列</span><br>  <span class="hljs-comment">// 需要注意，具体数据类型与编码格式相关，并不是int8类型</span><br>  int8[] contents;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入元素的执行步骤：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/intsetAdd.png" srcset="/img/loading.gif" lazyload></p>
<p>整数数组的特点是：</p>
<ul>
<li>灵活：支持不同类型的整数</li>
<li>节约内存：并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li>
<li>一旦编码升级，就不会降级了</li>
</ul>
<h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h2><p>压缩列表是为节约内存而开发的，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。其编码格式为：</p>
<table>
<thead>
<tr>
<th align="left">记录整个压缩列表占用的内存字节数</th>
<th align="left">记录压缩列表尾节点距离起始位置的字节数</th>
<th align="left">记录节点个数</th>
<th align="left">具体节点</th>
<th align="left">具体节点</th>
<th align="left">具体节点</th>
<th align="left">特殊值0xFF，标志压缩列表结尾</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zlbytes</td>
<td align="left">zltail</td>
<td align="left">zllen</td>
<td align="left">entry1</td>
<td align="left">…</td>
<td align="left">entryn</td>
<td align="left">zlend</td>
</tr>
<tr>
<td align="left">4B</td>
<td align="left">4B</td>
<td align="left">2B</td>
<td align="left">不定</td>
<td align="left">不定</td>
<td align="left">不定</td>
<td align="left">1B</td>
</tr>
</tbody></table>
<p>需要特殊说明的：</p>
<ul>
<li>根据压缩列表地址p和zltail，我们可以计算出尾节点的起始位置p+zltail</li>
<li>若节点数&lt;65535，则zllen代表真实的节点数量，否则真实数量只能通过遍历压缩列表得到</li>
</ul>
<p>其中，entry的编码格式为：</p>
<table>
<thead>
<tr>
<th align="left">前一节点的长度（单位：B）</th>
<th align="left">记录了content的数据类型和长度</th>
<th align="left">具体值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">previous_entry_length</td>
<td align="left">encoding</td>
<td align="left">content</td>
</tr>
<tr>
<td align="left">1B or 5B</td>
<td align="left">1B、2Bor5B</td>
<td align="left">不定</td>
</tr>
</tbody></table>
<p>特殊说明：</p>
<ul>
<li>previous_entry_length<ul>
<li>若前一节点长度小于254B，则其长度就保存在1B内</li>
<li>否则，previous_entry_length长度为5B，其第一字节被设置为固定值0xFE（254），后4字节保存前一节点的实际长度</li>
</ul>
</li>
<li>encoding<ul>
<li>字节数组编码<ul>
<li>1B，00开头，content长度由去除头两位的其余位表达</li>
<li>2B，01开头，content长度由去除头两位的其余位表达</li>
<li>5B，10开头，content长度由去除头两位的其余位表达</li>
</ul>
</li>
<li>整数编码<ul>
<li>1B，11开头，不同编码代表了不同的int类型</li>
<li>特殊的，1111开头，对应节点没有content字段，剩余四位表达具体数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>压缩列表的遍历方式：</p>
<ol>
<li>根据压缩列表起始地址p和zltail，计算出尾节点的起始位置 pn=p+zltail</li>
<li>根据pn，获取到pn-1的起始地址、本节点数据的编码和长度，访问本节点数据</li>
<li>根据pn-1，获取到pn-2的起始地址、本节点数据的编码和长度，访问本节点数据</li>
<li>…</li>
<li>根据p1，获取到p0的起始地址、本节点数据的编码和长度，访问本节点数据</li>
<li>结束遍历</li>
</ol>
<p>最后，当我们插入或者删除数据时，有可能会导致原本用1B记录前一节点大小的previous_entry_length不够用了，从而引发一连串的节点更新，这种现象就叫做“连锁更新”</p>
<h1 id="二-对象"><a href="#二-对象" class="headerlink" title="二.对象"></a>二.对象</h1><p>首先，redis数据库中的数据都是通过键值对（字典）的形式组织的。其中，键key永远是字符串对象。</p>
<p>其次，redis中只有字符串对象可以被嵌套使用，其余对象（list、set、zset、hash对象）都不可以互相嵌套使用。例如，[“a”, “b”]是允许的，但[{“k1”: “v1”}, {“k2”: “v2”}]是不允许的。</p>
<p>下面是redis对象的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisObject</span> </span>&#123;<br>  <span class="hljs-comment">// 类型</span><br>  uint4 type;<br>  <span class="hljs-comment">// 具体的数据结构</span><br>  uint4 encoding;<br>  <span class="hljs-comment">// 引用计数</span><br>  <span class="hljs-keyword">int</span> refcount;<br>  <span class="hljs-comment">// 对象最后一次被命令程序访问的时间点</span><br>  <span class="hljs-keyword">int</span> lru;<br>  <span class="hljs-comment">// 指针，指向具体对象</span><br>  Object ptr;<br>&#125;<br><br><span class="hljs-comment">// 查看key对应的value.type</span><br>TYPE &#123;key&#125;<br><span class="hljs-comment">// 查看key对应的value.encoding</span><br>OBJECT ENCODING &#123;key&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-string对象"><a href="#1-string对象" class="headerlink" title="1.string对象"></a>1.string对象</h2><p>string对象可以用来存储整数（12345）、浮点数（123.45）、字符串（“xqz”），其底层的实现方式是不同的，我们逐个探讨。</p>
<h3 id="1-1-整数"><a href="#1-1-整数" class="headerlink" title="1.1.整数"></a>1.1.整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = <span class="hljs-keyword">int</span><br>obj.ptr = 具体的整数<br></code></pre></td></tr></table></figure>

<h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2.字符串"></a>1.2.字符串</h3><p>当创建的字符串长度 &gt; 39B时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = raw<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure>

<p>当创建的字符串长度 &lt;= 39B时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure>

<p>可以看到，存储字符串时，底层数据结构都是sds，但是具体的编码方式不同：</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">内存结构</th>
<th align="left">读写操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">raw</td>
<td align="left">obj和sds分开申请，两片独立的内存空间，使用ptr指针连接</td>
<td align="left">可读/可写</td>
</tr>
<tr>
<td align="left">embstr</td>
<td align="left">obj和sds同时申请，一片连续的内存空间，使用ptr指针连接</td>
<td align="left">只读</td>
</tr>
</tbody></table>
<h3 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3.浮点数"></a>1.3.浮点数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure>

<p>浮点数实际是通过字符串来存储的，在浮点数计算时，redis从sds内取出字符串，转换成浮点数进行计算，并将计算结果再次转换成字符串进行存储。另外，过长的整型数也是通过这种方式存储的。</p>
<h3 id="1-4-编码转换"><a href="#1-4-编码转换" class="headerlink" title="1.4.编码转换"></a>1.4.编码转换</h3><p>当我们执行操作将整形数据变为字符串时，该对象的编码格式也变成了raw，如 1+”a”这种操作。</p>
<p>之前也提到，embstr是只读的，所以当我们修改embstr编码的字符串时，其底层编码也会变为raw。</p>
<h2 id="2-list对象"><a href="#2-list对象" class="headerlink" title="2.list对象"></a>2.list对象</h2><p>同时满足以下两个条件的list对象使用ziplist编码，即压缩列表数据结构，否则使用linkedlist编码，即双向链表数据结构。</p>
<ol>
<li>list中元素个数小于512（list-max-ziplist-entries可调）</li>
<li>list中所有字符串元素长度小于64字节（list-max-ziplist-value可调）</li>
</ol>
<p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到linkedlist，将保存在压缩列表的元素遍历取出，转成双向链表节点保存。</p>
<p>反之，若一开始是linkedlist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<p>另外，redis 3.2版本后引入quicklist数据结构，本文暂不介绍。</p>
<h3 id="2-1-ziplist编码"><a href="#2-1-ziplist编码" class="headerlink" title="2.1.ziplist编码"></a>2.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure>

<h3 id="2-2-linkedlist编码"><a href="#2-2-linkedlist编码" class="headerlink" title="2.2.linkedlist编码"></a>2.2.linkedlist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = linkedlist<br>obj.ptr = 双向链表对象<br></code></pre></td></tr></table></figure>

<h2 id="3-hash对象"><a href="#3-hash对象" class="headerlink" title="3.hash对象"></a>3.hash对象</h2><p>同时满足以下两个条件的hash对象使用ziplist编码，即压缩列表数据结构，否则使用ht编码，即字典数据结构。</p>
<ol>
<li>hash中元素个数小于512（hash-max-ziplist-entries可调）</li>
<li>hash中所有字符串元素（键或值）长度小于64字节（hash-max-ziplist-value可调）</li>
</ol>
<p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在压缩列表的元素遍历取出，转成字典节点保存。</p>
<p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<h3 id="3-1-ziplist编码"><a href="#3-1-ziplist编码" class="headerlink" title="3.1.ziplist编码"></a>3.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure>

<p>插入元素时，会先往压缩列表中添加键对象，再往压缩列表中添加值对象。</p>
<h3 id="3-2-ht编码"><a href="#3-2-ht编码" class="headerlink" title="3.2.ht编码"></a>3.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure>

<h2 id="4-set对象"><a href="#4-set对象" class="headerlink" title="4.set对象"></a>4.set对象</h2><p>同时满足以下两个条件的set对象使用intset编码，即整数集合数据结构，否则使用ht编码，即字典数据结构。</p>
<ol>
<li>set中元素个数小于512（set-max-ziplist-entries可调）</li>
<li>set中所有元素均为整数</li>
</ol>
<p>若一开始是intset编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在整数集合的元素遍历取出，转成字典节点保存。</p>
<p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<h3 id="4-1-intset编码"><a href="#4-1-intset编码" class="headerlink" title="4.1.intset编码"></a>4.1.intset编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = intset<br>obj.ptr = 整数集合对象<br></code></pre></td></tr></table></figure>

<h3 id="4-2-ht编码"><a href="#4-2-ht编码" class="headerlink" title="4.2.ht编码"></a>4.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure>

<p>实现类似于java的HashSet，即字典键保存数据，字典值为NULL。</p>
<h2 id="5-zset有序集合对象"><a href="#5-zset有序集合对象" class="headerlink" title="5.zset有序集合对象"></a>5.zset有序集合对象</h2><p>同时满足以下两个条件的zset对象使用ziplist编码，即压缩列表数据结构，否则使用skiplist编码，这里指跳表+字典数据结构。</p>
<ol>
<li>zset中元素个数小于128（zset-max-ziplist-entries可调）</li>
<li>zset中所有字符串元素长度小于64字节（zset-max-ziplist-value可调）</li>
</ol>
<p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到skiplist，将保存在压缩列表的元素遍历取出，转成跳表+字典节点保存。</p>
<p>反之，若一开始是skiplist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<h3 id="5-1-ziplist编码"><a href="#5-1-ziplist编码" class="headerlink" title="5.1.ziplist编码"></a>5.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure>

<p>插入元素时，会遍历压缩列表所有元素，根据score从小往大的顺序（即靠近表头位置的元素score小），先往压缩列表中添加数据对象，再往压缩列表中添加score对象。</p>
<h3 id="5-2-skiplist编码"><a href="#5-2-skiplist编码" class="headerlink" title="5.2.skiplist编码"></a>5.2.skiplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = skiplist<br>obj.zsl = 跳表对象<br>obj.dict = 字典对象<br></code></pre></td></tr></table></figure>

<p>跳表中元素按score从小往大的顺序排列。</p>
<p>字典键等于数据元素（string类型），字典值等于score（double类型），即该字典的作用时从元素映射到对应score。</p>
<p>为什么需要跳表+字典两个数据结构？速度。如前所述，跳表可以提供优秀的范围查找能力，字典做不到。字典可以O(1) 地查看元素分值，跳表做不到（需要遍历找到节点）。</p>
<p>最后一点，跳表与字典对应的底层数据对象，是共用的，这是为了节约空间。</p>
<h1 id="三-对象其他细节"><a href="#三-对象其他细节" class="headerlink" title="三.对象其他细节"></a>三.对象其他细节</h1><h2 id="1-命令类型检查"><a href="#1-命令类型检查" class="headerlink" title="1.命令类型检查"></a>1.命令类型检查</h2><p>大体上可以将redis的操作键的命令分为两类</p>
<ol>
<li>可以对任意对象类型生效</li>
<li>只对命令绑定的对象类型生效</li>
</ol>
<p>对于第二种类型命令，redis会根据obj.type字段，在执行命令前主动检查：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/checkobject.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-命令多态实现"><a href="#2-命令多态实现" class="headerlink" title="2.命令多态实现"></a>2.命令多态实现</h2><ul>
<li>基于类型的多态：可以对任意对象类型生效的命令，会根据value对象具体类型，做不同处理</li>
<li>基于编码的多态：作用到具体对象上的命令，会根据对象编码，调用对应数据结构API实现命令</li>
</ul>
<h2 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3.内存回收机制"></a>3.内存回收机制</h2><p>c语言不像java，java虚拟机会帮助程序员管理对象占用的内存，在对象不被使用时自动释放内存。redis使用引用计数算法实现了一套内存管理机制，现简单介绍。</p>
<p>首先了解下redis对象生命周期</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/objectlife.png" srcset="/img/loading.gif" lazyload></p>
<p>与之对应的，之前说到的obj.refcount值是这样变化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建一个对象时，refcount初始化为1，因为不论有无key对象，服务器都需要持有这个对象</span><br>Object obj = <span class="hljs-keyword">new</span> StringObject();<br><br><span class="hljs-comment">// 对象被新程序使用时，调用incrRefCount(obj)函数，obj.refcount++</span><br><span class="hljs-comment">// 对象不再被新程序使用时，调用decrRefCount(obj)函数，obj.refcount--</span><br>...<br>  <br><span class="hljs-comment">// 最终，调用decrRefCount(obj)函数，将obj.refcount减为0，会导致该对象被redis服务器回收，内存被释放</span><br>decrRefCount(obj);<br></code></pre></td></tr></table></figure>

<p>涉及到函数列表：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">incrRefCount()</td>
<td align="left">refcount++</td>
</tr>
<tr>
<td align="left">decrRefCount()</td>
<td align="left">refcount–</td>
</tr>
<tr>
<td align="left">resetRefCount()</td>
<td align="left">refcount=0，但是不会释放对象</td>
</tr>
</tbody></table>
<h2 id="4-对象共享机制"><a href="#4-对象共享机制" class="headerlink" title="4.对象共享机制"></a>4.对象共享机制</h2><p>类似于java常量池机制，redis也会将常用字符串做为“常量”共享起来。在redis初始化服务器时，会创建0-9999共一万个整数字符串（通过redis.h/REDIS_SHARED_INTEGERS设置），后续共享使用。这些对象不仅是字符串对象可以共享，前述所有类型对象都可以使用。</p>
<p>但是，需要注意，redis只支持整数字符串的共享，这主要是因为要共享一个对象，当然需要判断两个引用对应的对象是否一致，整数对象可以在O(1)时间内验证，但当字符串复杂时，或其他结构的对象时（如list），这个验证过程会很消耗CPU并且不可控。</p>
<p>最后需要注意，当对象被共享时，其refcount++。</p>
<h2 id="5-对象空转时长"><a href="#5-对象空转时长" class="headerlink" title="5.对象空转时长"></a>5.对象空转时长</h2><p>前面提到的obj.lru记录了该对象最后一次被命令程序访问的时间点。</p>
<p>我们可以通过 OBJECT IDLETIME 命令查看值对象的 空转时长=当前时间-obj.lru。这个命令比较特殊，不会刷新obj.lru的值。</p>
<p>空转时长是当服务器内存不够时，用来判断该对象是否可以被回收时使用的，这个之后的专题会详细介绍。</p>
<p>至此，我们了解了redis所有的对象及其底层数据结构，希望对大家的工作学习有所帮助，谢谢～</p>
<p><strong>todo list:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 图完善</li>
<li><input disabled="" type="checkbox"> 源码解读</li>
<li><input disabled="" type="checkbox"> 指令及对应数据结构操作</li>
<li><input disabled="" type="checkbox"> 新版本数据结构</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/redis/">redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/finish/">finish</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/31/Redis%E5%9F%BA%E7%A1%80-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis基础-单机数据库</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/08/SAC-003-REST/">
                        <span class="hidden-mobile">SAC-003-REST</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"64e7a0af76ea907275e7","clientSecret":"58fc6a6232d3179936704144df3ddeef170c2fdd","repo":"bolg-comment","owner":"Xzzz583722585","admin":["Xzzz583722585"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '9a15c52c8692c7b6a9b1df0d7dff66bb'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
