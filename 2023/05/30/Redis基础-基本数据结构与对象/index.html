

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Jon Xzzz">
  <meta name="keywords" content="">
  
  <title>Redis基础-基本数据结构与对象 - Jon Xzzz</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.jonxzzz.xyz","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SAmnq0afTzl9DvACTmD2ys0H-gzGzoHsz","app_key":"yxbky5wsCPQcibrgyi8HmBtm","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Jon Xzzz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis基础-基本数据结构与对象">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-05-30 23:44" pubdate>
        2023年5月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      104
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        浏览 <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis基础-基本数据结构与对象</h1>
            
            <div class="markdown-body">
              <p>我们使用redis时，最直观接触到的就是redis对象及其命令。那我们今天就一起了解下这些对象的实现细节。</p>
<h1 id="一-基本数据结构"><a href="#一-基本数据结构" class="headerlink" title="一.基本数据结构"></a>一.基本数据结构</h1><h2 id="1-简单动态字符串-SDS"><a href="#1-简单动态字符串-SDS" class="headerlink" title="1.简单动态字符串 SDS"></a>1.简单动态字符串 SDS</h2><p>redis是用C语言实现的，我们需要先认识一下C语言里面的字符串（以下简称C字符串）。</p>
<p>“Redis\0”这是一个C语言字符串，它具有以下特点：</p>
<ul>
<li>必须以 ‘\0’ 空字符结尾</li>
<li>系统不维护该字符串的长度（不像java的String类型有length），获取字符串长度必须遍历整个字符串，即时间复杂度为 O(n)</li>
<li>每次更改（缩短或增长）字符串都需要重新内存分配，否则可能造成内存泄漏或缓冲区溢出</li>
<li>只能保存文本数据</li>
<li>C语言有相关代码库，支持各类字符串操作</li>
</ul>
<p>对于redis而言，只有像log这类字符串一定没有变化的场景会使用C字符串实现以外，其余大多数场景都使用它自己的SDS来实现字符串，例如：</p>
<ul>
<li>命令里的key和value SET name “xqz”</li>
<li>各类嵌套对象 [“a”, “b”]</li>
<li>缓冲区：AOF缓冲区、客户端的输入输出缓冲区</li>
<li>等等</li>
</ul>
<p>SDS的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDS</span> </span>&#123;<br>	<span class="hljs-comment">// 记录buf中已经被使用的长度</span><br>  <span class="hljs-keyword">int</span> len;<br>  <span class="hljs-comment">// 记录buf中没有被使用的长度</span><br>  <span class="hljs-keyword">int</span> free;<br>  <span class="hljs-comment">// 实际存储字符串的地方</span><br>  <span class="hljs-comment">// 其末尾以&#x27;\0&#x27;结尾，不记录在上述两个长度内，即SDS实际字符长度为 len+free+1</span><br>  <span class="hljs-keyword">char</span>[] buf;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，我们可以解释 SDS 名称的由来：</p>
<ul>
<li>简单：相比于C字符串，要获取SDS内的字符串长度，可以直接通过len字段，时间复杂度为 O(1)</li>
<li>动态：每次对 SDS增长时，redis都会自己检查free是否充足，如果不够，那么就会自动进行内存分配以获取足够的空间，即redis保证了不会发生缓冲区溢出</li>
</ul>
<p>那么，我们又引申出一个小问题，那就是sds的内存分配策略：</p>
<ul>
<li>字符串增长时<ul>
<li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li>
<li><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/sds_edit.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>字符串减短时<ul>
<li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li>
</ul>
</li>
</ul>
<p>总结，SDS相比于C字符串的特点是：</p>
<ul>
<li>实际也以 ‘\0’ 空字符结尾</li>
<li>获取字符串长度的时间复杂度为 O(1)</li>
<li>每次更改（缩短或增长）字符串，调用者不需要重新内存分配，redis会保证不造成内存泄漏或缓冲区溢出</li>
<li>sds的所有api都是二进制安全的，即sds不仅可以保存文本数据，还可以保存任意格式的二进制数据</li>
<li>因为实际以 ‘\0’ 字符结尾，可以使用C语言相关代码库</li>
</ul>
<h2 id="2-双向链表LinkedList（已经被快速链表代替）"><a href="#2-双向链表LinkedList（已经被快速链表代替）" class="headerlink" title="2.双向链表LinkedList（已经被快速链表代替）"></a><del>2.双向链表LinkedList（已经被快速链表代替）</del></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> </span>&#123;<br>  <span class="hljs-comment">// 头节点指针</span><br>  ListNode head;<br>  <span class="hljs-comment">// 尾节点指针</span><br>  ListNode tail;<br>  <span class="hljs-comment">// 链表总长度</span><br>  uint64 len;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 前一个节点指针</span><br>  ListNode pre;<br>  <span class="hljs-comment">// 后一个节点指针</span><br>  ListNode next;<br>  <span class="hljs-comment">// 指向具体内容的指针</span><br>  Object value;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-键值对映射HashTable（字典）"><a href="#3-键值对映射HashTable（字典）" class="headerlink" title="3.键值对映射HashTable（字典）"></a>3.键值对映射HashTable（字典）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dict</span> </span>&#123;<br>  <span class="hljs-comment">// 为对象多态服务，DictType保存了针对每种不同类型键值对的特定函数</span><br>  DictType type;<br>  <span class="hljs-comment">// 为对象多态服务，保存了不同特定函数的可选参数</span><br>  Object privData;<br>  <span class="hljs-comment">// ht[0]指向正在使用的hash表，ht[1]正常情况下指向null，rehash过程中指向即将迁移过去的hash表</span><br>  DictHt[] ht;<br>  <span class="hljs-comment">// rehash索引</span><br>  <span class="hljs-keyword">int</span> rehashidx;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictHt</span> </span>&#123;<br>  <span class="hljs-comment">// hash桶，存储具体数据</span><br>  DictEntry[] table;<br>  <span class="hljs-comment">// 桶大小</span><br>  uint64 size; <br>  <span class="hljs-comment">// 桶已使用大小</span><br>  uint64 used;<br>  <span class="hljs-comment">// 用于计算对象下标，sizemask=size-1</span><br>  uint64 sizemask;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictEntry</span> </span>&#123;<br>  <span class="hljs-comment">// 只能是字符串类型</span><br>  Object key;<br>  <span class="hljs-comment">// 对象多态</span><br>  <span class="hljs-comment">// 另外，并没有使用字符串对象处理整数和普通对象，下面讲字符串对象时会涉及</span><br>  union &#123;<br>    <span class="hljs-comment">// value类行为对象</span><br>    Object v;<br>    <span class="hljs-comment">// value类型为无符号整数</span><br>    uint64 u64;<br>    <span class="hljs-comment">// value类型为有符号整数</span><br>    int64 s64;<br>  &#125; value;<br>  <span class="hljs-comment">// 拉链法解决hash冲突：key相同的下一个value对象</span><br>  DictEntry next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然提到hash，那么着重解决一下几个问题：</p>
<ul>
<li>hash函数怎么选择？</li>
<li>hash冲突如何解决？</li>
<li>如何维护hash冲突的概率？</li>
</ul>
<h3 id="3-1-hash函数如何选择？"><a href="#3-1-hash函数如何选择？" class="headerlink" title="3.1.hash函数如何选择？"></a>3.1.hash函数如何选择？</h3><p>redis选用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C">murmurhash2</a>算法生成key对应的hash值，记做hash(key)，则最终插入下标index=hash(key) &amp; ht[x].sizemask。这里面信息量比较大，我们一一介绍：</p>
<ul>
<li>若N为2的n次幂，则 H%N = H&amp;(N-1)，这是快速计算方式，并且后续会看到redis保证桶大小为2的n次幂（java的HashMap也有类似设计），这里也解释了为什么会有一个sizemask字段</li>
<li>ht[x]的含义是，若当前字典不是rehash状态，则x=0，否则x=1</li>
</ul>
<h3 id="3-2-hash冲突如何解决？"><a href="#3-2-hash冲突如何解决？" class="headerlink" title="3.2.hash冲突如何解决？"></a>3.2.hash冲突如何解决？</h3><p>一般的hash冲突解决方法有两种：开放定址法和拉链法，redis和java.HashMap均采用拉链法，即将hash到相同桶下标的entry组织成一个链表（java的HashMap在链表长度大于8时，会将该链表转换为一棵红黑树，即平衡树，依次来提高检索效率）。</p>
<p>另外，此处的链表不是双向链表，所以采用头插法快速添加新节点（多嘴说一句，并发环境下，头插法可能产生循环链表问题，jdk8前后的解决方法并不相同，感兴趣的小伙伴可以搜一搜，但是单线程的redis并不存在这个问题）</p>
<h3 id="3-3-如何维护hash冲突的概率？"><a href="#3-3-如何维护hash冲突的概率？" class="headerlink" title="3.3.如何维护hash冲突的概率？"></a>3.3.如何维护hash冲突的概率？</h3><p>介绍一个概念：负载因子=桶已被使用的大小/桶总大小，可以看出，若负载因子过大，则产生hash冲突的可能性就更高，若负载因子过小，则空间利用率就变低。因此，根据负载因子大小，在合适的时机调整桶大小就变的尤为重要。</p>
<p>下面是redis执行的rehash的具体步骤：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/rehash.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>负载因子过大：<ul>
<li>服务器没有执行 <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/server-bgsave.html">BGSAVE</a> 或 <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/server-bgrewriteaof.html">BGREWRITEAOF</a> 命令时，&gt;=1，这是因为这些命令都会采取写时复制的手段来优化子进程的执行效率，那么就需要降低非必要的内存写入操作</li>
<li>服务器执行 BGSAVE 或 BGREWRITEAOF 命令时，&gt;=5</li>
</ul>
</li>
<li>负载因子过小：&lt;0.1</li>
</ul>
<p>最后，需要注意，rehash过程不是一次性完成的，而是延迟、渐进式的完成的，其过程是：</p>
<ol>
<li>rehash开始，将rehashidx置为0，代表rehash开始</li>
<li>其后每次对该字典有增删改查（包括rehash开始时的那一次）操作时，都会将ht[0]桶rehashidx位置上的数据重新写入到ht[1]桶内，删除ht[0]桶rehashidx位置上的所有数据，rehashidx++</li>
<li>当ht[0]桶上所有数据都迁移完成后，将rehashidx置为-1，代表rehash结束</li>
</ol>
<p>很明显，在rehash期间，插入操作会直接在ht[1]桶上完成（保证ht[0]只减不增，另外，先插入到ht[0]再rehash到ht[1]也太傻了），删除、更改、查询操作都会先检索ht[0]，数据不存在时再检索ht[1]得到最终结果</p>
<h2 id="4-跳表SkipList"><a href="#4-跳表SkipList" class="headerlink" title="4.跳表SkipList"></a>4.跳表SkipList</h2><p>鉴于大学的数据结构课本或者《算法导论》这样的书上都没有跳表的内容，所以我们得先介绍下跳表这种数据结构（这里奉上原始论文，感兴趣的同学可以看看<a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf%EF%BC%89%E3%80%82">https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf）。</a></p>
<p>这是一个链表：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist1.png" srcset="/img/loading.gif" lazyload></p>
<p>我们给他加一点索引，用来加快检索速度：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist2.png" srcset="/img/loading.gif" lazyload></p>
<p>当数据量特别大的时候，我们可能需要多层索引，获取更好的检索速度：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist3.png" srcset="/img/loading.gif" lazyload></p>
<p>好了，我们可以做一个优化，即相同元素（初始元素及该元素代表的索引）只使用一个节点即可。</p>
<p>这就是跳表，我们来看下跳表如何检索一个元素（下述跳表中查找71）：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist4.png" srcset="/img/loading.gif" lazyload></p>
<p>其时间复杂度 = 索引的高度 * 每层索引遍历元素的个数，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。那么跳表的总高度 h = log2n。并且，上层两个索引中间对应的下层索引个数最多为3，即时间复杂度=O(log2n)。</p>
<p>空间复杂度显然等于 n/2+n/4+…+n/h=O(n)。</p>
<p>那么，接下来的问题就变成了，随着元素的插入/删除，我们应该如何去维护跳表的索引，以使其保持优良的性能？</p>
<p>一种设计方案是，还是假设每两个结点会抽出一个结点作为上一级索引的结点，那么当本层元素大于3时，我们就要将其分裂为两部分，并且在上层添加这两部分的索引。删除同理。好了，说到这你应该意识到，这是B树的设计。</p>
<p>另一种方案，即跳表天才的设计，用概率来维护索引。即每个元素都有1/2的概率建立上层索引，当数据量足够大时，我们有理由相信这种概率建立起来的索引是离散的，即所有元素不会堆积在一起。</p>
<p>那么，我们来看一下跳表如何插入元素。假设在我们插入元素时，有一个函数randomLevel(x)，其返回值表示应该为这个元素新建几层索引。例如，randomLevel(x)=2，则新建1层索引。我们保证，randomLevel(x)函数有1/2的概率返回1，有1/4的概率返回2，以此类推。有的小伙伴会问，为什么不是randomLevel(x)=1新建一层索引呢？这是因为，只要randomLevel(x)&gt;1那么就会新建第一层的索引，那么randomLevel(x)=1的概率为1/2，就等同于第一层索引不被建立的概率等于1/2，那么，只要randomLevel(x)=2我们再开始建立索引就可以了。</p>
<p>我们举一个插入87的例子，randomLevel(87)=3，</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist5.png" srcset="/img/loading.gif" lazyload></p>
<p>最后看一眼删除（删除87），我们只需要该元素整个删除即可（包括该元素代表的索引）：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png" srcset="/img/loading.gif" lazyload></p>
<p>至此，我们可以介绍下redis的跳表了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br>  <span class="hljs-comment">// 指向跳表头节点</span><br>  <span class="hljs-comment">// 头节点不是实际的元素节点，即不计算在level、length内</span><br>  SkipListNode header;<br>  <span class="hljs-comment">// 指向跳表尾节点</span><br>  <span class="hljs-comment">// 尾节点是实际的元素节点</span><br>  SkipListNode tail;<br>  <span class="hljs-comment">// 层数最大的节点的层数</span><br>  <span class="hljs-keyword">int</span> level;<br>  <span class="hljs-comment">// 节点个数</span><br>  <span class="hljs-keyword">int</span> length;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 分数，redis跳表通过分数作为元素插入位置的依据</span><br>  <span class="hljs-comment">// 分数按从小到大的顺序排列</span><br>  <span class="hljs-comment">// 不同元素分数可以相同，但是对象不能相同。相同分数的不同对象按照字典序排列。</span><br>  <span class="hljs-keyword">double</span> score;<br>  <span class="hljs-comment">// 对象指针</span><br>  Object obj;<br>  <span class="hljs-comment">// 后退指针，指向紧邻的前一个元素。注意，后退指针不参与跳表的索引结构，就像B+树的叶子结点链表一样，将所有的元素节点连接起来。方便检索范围内的所有数据。</span><br>  SkipListNode backward;<br>  <span class="hljs-comment">// 层（上述的各层索引）</span><br>  <span class="hljs-comment">// Level1-Level32，L1可以看做之前讲的基础数据，L2-L32可以看做索引</span><br>  SkipListLevel[] level;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListLevel</span> </span>&#123;<br>  <span class="hljs-comment">// 前进指针，指向拥有同层索引的下一个节点</span><br>  SkipListNode forward;<br>  <span class="hljs-comment">// 跨度，注意，跨度并不参与实际的检索过程（有疑惑的抛开redis再看看前面的跳表介绍），只是用于计算同层两个节点间的元素个数</span><br>  uint32 span;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，我们看一下redis如何实现前述的randomLevel(x)函数的：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png" srcset="/img/loading.gif" lazyload></p>
<p>上述代码等同于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">func <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level+1</span><br>  <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>    level += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可见，redis设置的SKIPLIST_P=0.25，即每4个元素生成一个上层索引</p>
<h2 id="5-整数集合IntSet"><a href="#5-整数集合IntSet" class="headerlink" title="5.整数集合IntSet"></a>5.整数集合IntSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSet</span> </span>&#123;<br>  <span class="hljs-comment">// 编码方式（注意与之后对象结构内的编码方式区分）</span><br>  <span class="hljs-comment">// 目前支持：int16、int32、int64</span><br>  uint32 encoding;<br>  <span class="hljs-comment">// 集合长度，即元素个数</span><br>  uint32 length;<br>  <span class="hljs-comment">// 具体数据，不会有重复值，按值大小从小往大排列</span><br>  <span class="hljs-comment">// 需要注意，具体数据类型与编码格式相关，并不是int8类型</span><br>  int8[] contents;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入元素的执行步骤：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/intsetAdd.png" srcset="/img/loading.gif" lazyload></p>
<p>整数数组的特点是：</p>
<ul>
<li>灵活：支持不同类型的整数</li>
<li>节约内存：并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li>
<li>一旦编码升级，就不会降级了</li>
</ul>
<h2 id="6-压缩列表ZipList（已经被快速链表代替）"><a href="#6-压缩列表ZipList（已经被快速链表代替）" class="headerlink" title="6.压缩列表ZipList（已经被快速链表代替）"></a><del>6.压缩列表ZipList（已经被快速链表代替）</del></h2><p>压缩列表是为节约内存而开发的，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。其编码格式为：</p>
<table>
<thead>
<tr>
<th align="left">记录整个压缩列表占用的内存字节数</th>
<th align="left">记录压缩列表尾节点距离起始位置的字节数</th>
<th align="left">记录节点个数</th>
<th align="left">具体节点</th>
<th align="left">具体节点</th>
<th align="left">具体节点</th>
<th align="left">特殊值0xFF，标志压缩列表结尾</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zlbytes</td>
<td align="left">zltail</td>
<td align="left">zllen</td>
<td align="left">entry1</td>
<td align="left">…</td>
<td align="left">entryn</td>
<td align="left">zlend</td>
</tr>
<tr>
<td align="left">4B</td>
<td align="left">4B</td>
<td align="left">2B</td>
<td align="left">不定</td>
<td align="left">不定</td>
<td align="left">不定</td>
<td align="left">1B</td>
</tr>
</tbody></table>
<p>需要特殊说明的：</p>
<ul>
<li>根据压缩列表地址p和zltail，我们可以计算出尾节点的起始位置p+zltail</li>
<li>若节点数&lt;65535，则zllen代表真实的节点数量，否则真实数量只能通过遍历压缩列表得到</li>
</ul>
<p>其中，entry的编码格式为：</p>
<table>
<thead>
<tr>
<th align="left">前一节点的长度（单位：B）</th>
<th align="left">记录了content的数据类型和长度</th>
<th align="left">具体值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">previous_entry_length</td>
<td align="left">encoding</td>
<td align="left">content</td>
</tr>
<tr>
<td align="left">1B or 5B</td>
<td align="left">1B、2Bor5B</td>
<td align="left">不定</td>
</tr>
</tbody></table>
<p>特殊说明：</p>
<ul>
<li>previous_entry_length<ul>
<li>若前一节点长度小于254B，则其长度就保存在1B内</li>
<li>否则，previous_entry_length长度为5B，其第一字节被设置为固定值0xFE（254），后4字节保存前一节点的实际长度</li>
</ul>
</li>
<li>encoding<ul>
<li>字节数组编码<ul>
<li>1B，00开头，content长度由去除头两位的其余位表达</li>
<li>2B，01开头，content长度由去除头两位的其余位表达</li>
<li>5B，10开头，content长度由去除头两位的其余位表达</li>
</ul>
</li>
<li>整数编码<ul>
<li>1B，11开头，不同编码代表了不同的int类型</li>
<li>特殊的，1111开头，对应节点没有content字段，剩余四位表达具体数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>压缩列表的遍历方式：</p>
<ol>
<li>根据压缩列表起始地址p和zltail，计算出尾节点的起始位置 pn=p+zltail</li>
<li>根据pn，获取到pn-1的起始地址、本节点数据的编码和长度，访问本节点数据</li>
<li>根据pn-1，获取到pn-2的起始地址、本节点数据的编码和长度，访问本节点数据</li>
<li>…</li>
<li>根据p1，获取到p0的起始地址、本节点数据的编码和长度，访问本节点数据</li>
<li>结束遍历</li>
</ol>
<p>最后，当我们插入或者删除数据时，有可能会导致原本用1B记录前一节点大小的previous_entry_length不够用了，从而引发一连串的节点更新，这种现象就叫做“连锁更新”。连锁更新时，最终压缩列表的大小需要依次计算得出，时间复杂度为O(n)，但是最终只需要一次内存分配。</p>
<p>总结下压缩列表的优缺点：</p>
<ul>
<li>优点<ul>
<li>节省空间</li>
</ul>
</li>
<li>缺点<ul>
<li>因为需要遍历访问，不适合保存过多元素</li>
<li>因为可能会引发连锁更新，所以不适合保存过大元素</li>
</ul>
</li>
</ul>
<h2 id="7-快速链表QuickList"><a href="#7-快速链表QuickList" class="headerlink" title="7.快速链表QuickList"></a>7.快速链表QuickList</h2><p>简单说，快速链表=双向链表+压缩列表，即双向链表的每个节点是一个压缩列表。这么做的目的是在获得压缩列表节约空间的好处同时，解决压缩列表无法存储过多元素的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quicklist</span> </span>&#123;<br>    <span class="hljs-comment">// quicklist 的链表头</span><br>    QuicklistNode head;<br>    <span class="hljs-comment">// quicklist 的链表尾</span><br>    QuicklistNode tail;<br>    <span class="hljs-comment">// 所有 ziplist 中的总元素个数</span><br>    <span class="hljs-keyword">long</span> count;<br>    <span class="hljs-comment">// quicklistNodes 的个数</span><br>    <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-comment">// 控制每个node中ziplist的元素个数</span><br>    <span class="hljs-comment">// 负数-n表示ziplist大小小于2^(n+1)KB</span><br>    <span class="hljs-comment">// 正数n表示ziplist元素个数小于n</span><br>    <span class="hljs-keyword">long</span> fill;<br>    <span class="hljs-comment">// 其他</span><br>    ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuicklistNode</span> </span>&#123;<br>    <span class="hljs-comment">// 前一个链表节点</span><br>    QuicklistNode prev;<br>    <span class="hljs-comment">// 后一个链表节点</span><br>    QuicklistNode next;<br>    <span class="hljs-comment">// 本节点是存储处元素的 ziplist</span><br>    <span class="hljs-comment">// 字节形式存储</span><br>    <span class="hljs-keyword">char</span> zl;<br>    <span class="hljs-comment">// ziplist 的字节大小</span><br>    <span class="hljs-keyword">int</span> sz;<br>    <span class="hljs-comment">// ziplist 的元素个数</span><br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-comment">// 原始字节=1</span><br>    <span class="hljs-comment">// 压缩存储=2</span><br>    <span class="hljs-keyword">int</span> encoding;<br>    <span class="hljs-comment">// 存储方式</span><br>    <span class="hljs-comment">// null=1</span><br>    <span class="hljs-comment">// ZIPLIST=2</span><br>    <span class="hljs-keyword">int</span> container;<br>    <span class="hljs-comment">// 数据是否被压缩</span><br>    <span class="hljs-keyword">int</span> recompress;<br>    <span class="hljs-comment">// 数据能否被压缩</span><br>    <span class="hljs-keyword">int</span> attempted_compress;<br>    <span class="hljs-comment">// 预留的 bit 位</span><br>    <span class="hljs-keyword">int</span> extra;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终结果如图所示：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/quicklist.png" srcset="/img/loading.gif" lazyload></p>
<p>当往快速链表中插入数据时（以链表tail插入为例），若tail对应的ziplist已满，则需要创建新的node，当前节点的next指向新node，tail也指向新node，把元素插入到新node的ziplist中去。</p>
<h2 id="8-紧凑链表ListPack"><a href="#8-紧凑链表ListPack" class="headerlink" title="8.紧凑链表ListPack"></a>8.紧凑链表ListPack</h2><h3 id="8-1-编码格式"><a href="#8-1-编码格式" class="headerlink" title="8.1.编码格式"></a>8.1.编码格式</h3><p>本质上说，quickList并没有从根本上解决zipList连锁更新的问题，他只是将连锁更新的范围控制在一个节点内。并且，链表指针也会消耗内存空间，这不符合压缩列表的初衷。因此，根本解决方案就是紧凑列表ListPack。</p>
<p>压缩列表之所以会出现连锁更新的问题，本质上是因为单个元素大小的变动，会影响其相邻元素的previous_entry_length字段占用的空间大小，从而级联影响下去。那我们就需要在干掉这个previous_entry_length的情况下，依然支持对元素进行遍历。</p>
<p>我们看看ListPack的编码格式：</p>
<table>
<thead>
<tr>
<th align="left">记录整个紧凑列表占用的内存字节数</th>
<th align="left">记录紧凑列表的元素总数</th>
<th align="left">具体节点</th>
<th align="left">具体节点</th>
<th align="left">具体节点</th>
<th align="left">特殊值0xFF，标志j紧凑列表结尾</th>
</tr>
</thead>
<tbody><tr>
<td align="left">totalBytes</td>
<td align="left">numElements</td>
<td align="left">element1</td>
<td align="left">…</td>
<td align="left">elementn</td>
<td align="left">listpackEndByte</td>
</tr>
<tr>
<td align="left">4B</td>
<td align="left">2B</td>
<td align="left">不定</td>
<td align="left">不定</td>
<td align="left">不定</td>
<td align="left">1B</td>
</tr>
</tbody></table>
<p>需要特殊说明的：</p>
<ul>
<li>若节点数&lt;65535，则numElements代表真实的节点数量，否则真实数量只能通过遍历紧凑列表得到</li>
</ul>
<p>其中，element的编码格式为：</p>
<table>
<thead>
<tr>
<th align="left">当前元素数据类型以及值长度</th>
<th align="left">具体值</th>
<th>当前元素总长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">encodingType</td>
<td align="left">data</td>
<td>tolLen</td>
</tr>
<tr>
<td align="left">不定</td>
<td align="left">不定</td>
<td>不定</td>
</tr>
</tbody></table>
<p>需要特殊说明的：</p>
<ul>
<li>encodingType和tolLen一定有值，但是data不一定，因为若data过小，会直接存储在encodingType内（下面会介绍）。</li>
<li>element只记录了当前元素的长度，所以不会引起压缩列表那样的连锁更新。</li>
</ul>
<p>编码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>|xxxxxxx	// 表示<span class="hljs-number">7</span>位无符号整数，encodingType后<span class="hljs-number">7</span>位为data<br><span class="hljs-attribute">10</span>|xxxxxx	// 表示短字符串，后<span class="hljs-number">6</span>位表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">110</span>|xxxxx	// 表示<span class="hljs-number">13</span>位有符号整数，后<span class="hljs-number">5</span>位+下个字节存储具体数字<br><span class="hljs-attribute">1110</span>|xxxx	// 表示<span class="hljs-number">12</span>位长度的字符串，后<span class="hljs-number">4</span>位+下个字节表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0000</span>	// 表示长字符串，后<span class="hljs-number">4</span>字节表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0001</span>	// 表示<span class="hljs-number">16</span>位有符号整数，后<span class="hljs-number">2</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0010</span>	// 表示<span class="hljs-number">24</span>位有符号整数，后<span class="hljs-number">3</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0011</span>	// 表示<span class="hljs-number">32</span>位有符号整数，后<span class="hljs-number">4</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0100</span>	// 表示<span class="hljs-number">64</span>位有符号整数，后<span class="hljs-number">8</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0101</span> - <span class="hljs-number">1111</span>|<span class="hljs-number">1110</span>	// 未使用<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">1111</span>	// 结尾标志占用<br></code></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li>处于复杂度和性能考虑，并未使用1111|0001 - 1111|1110这些编码去表达各种长度的有/无符号整数。</li>
</ul>
<p>最后是当前元素总长度的编码方式。由于encodingType及data的长度不固定，所以tolLen的长度也不是固定的。其编码方式是从当前的element的最右侧（结束位置）开始，一字节一字节的解析。其中，每一字节的最高位表示是否还需要更多的字节（0不需要，1需要），剩余7位就是长度的二进制表示部分。我们通过从右往左不断遍历每一字节，获取长度的所有二进制位，最终将他们拼接起来就是tolLen的值了。</p>
<p>例如，tolLen=500时，500的二进制表示为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">111110100</span><br></code></pre></td></tr></table></figure>

<p>那么，我们就需要用两个字节来表示它：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>]<span class="hljs-number">0000011</span> [<span class="hljs-number">1</span>]<span class="hljs-number">1110100</span><br></code></pre></td></tr></table></figure>

<h3 id="8-2-正向查询元素"><a href="#8-2-正向查询元素" class="headerlink" title="8.2.正向查询元素"></a>8.2.正向查询元素</h3><p>正向遍历使用不到tolLen，我们只需要根据encodingType就可以确定data的起始位置和长度了，并据此计算出tolLen的长度，即整个元素的长度。这个过程是：</p>
<ol>
<li>指针跳转到头元素的起始位置</li>
<li>解析encodingType，获取data的起始位置和长度</li>
<li>解析data内容</li>
<li>计算encodingType+data的长度，即为len</li>
<li>根据len推导出tolLen的长度，即知道了元素的总长度</li>
<li>跳转指针到下一个元素的起始位置</li>
</ol>
<h3 id="8-3-逆向查询元素"><a href="#8-3-逆向查询元素" class="headerlink" title="8.3.逆向查询元素"></a>8.3.逆向查询元素</h3><ol>
<li>指针跳转到尾元素的结束位置</li>
<li>从右往左解析当前元素的tolLen</li>
<li>计算出当前元素的起始位置和前一个元素的结束位置</li>
<li>从当前元素的起始位置开始，解析encodingType，获取data的起始位置和长度</li>
<li>解析data内容</li>
<li>跳转指针到前一个元素的结束位置</li>
</ol>
<h1 id="二-拓展数据结构"><a href="#二-拓展数据结构" class="headerlink" title="二.拓展数据结构"></a>二.拓展数据结构</h1><h2 id="1-位图BitMap"><a href="#1-位图BitMap" class="headerlink" title="1.位图BitMap"></a>1.位图BitMap</h2><p>位图底层就是用字符串实现的，适合记录二值状态的数据。众所周知，字符串包含多个字符，一个字符包含多个字节，一个字节又由8个bit位组成，位图正是利用每个bit位存储二值数据。</p>
<h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2.HyperLogLog"></a>2.HyperLogLog</h2><p>首先需要清楚，HyperLogLog是用来解决基数统计相关问题的。</p>
<p>这里所谓基数，就是一个集合中不重复的元素个数。举个例子：有一个数字集合{2,1,3,1,2}，它没有顺序，数字也会重复，其基数就是{1,2,3}的长度，即3。</p>
<p>基数统计就是计算出这个集合的基数，即不重复的元素的个数。HyperLogLog算法就是用来解决基数统计问题的，关于该算法的详情可以看这篇文章<a href="/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/" title="[基数统计算法]">[基数统计算法]</a>。</p>
<p>可以完成基数统计的方式如下：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>HashTable</td>
<td>准确，没有误差</td>
<td>内存占用比最大</td>
</tr>
<tr>
<td>BitMap</td>
<td>准确，没有误差<br />内存占用比HashTable小</td>
<td>内存占用比HyperLogLog大</td>
</tr>
<tr>
<td>HyperLogLog</td>
<td>固定占用内存12KB，就可以支持2^64个元素的基数统计</td>
<td>基于概率的算法，存在误差</td>
</tr>
</tbody></table>
<h2 id="3-GEO"><a href="#3-GEO" class="headerlink" title="3.GEO"></a>3.GEO</h2><p>GEO经常用于LBS，即基于位置的服务，指的是使用地理数据信息向用户提供服务的软件应用，例如附近美食、打车等。众所周知，我们可以使用一组经纬度信息唯一表达地理位置信息。如北京的经纬度坐标是(39.9042, 116.4074)，含义是北京处于北纬39.9042度，东经116.4074度。</p>
<h3 id="3-1-GEOHash编码"><a href="#3-1-GEOHash编码" class="headerlink" title="3.1.GEOHash编码"></a>3.1.GEOHash编码</h3><p>在Redis中，正是将经纬度信息作为有序集合Sorted Set的score，将业务数据作为value进行存储。但是，数组并不能直接作为score存储，需要将其转换为浮点类型数字，这就是GEOHash编码了。</p>
<p>经纬度信息的范围都是[-180, 180]，我们可以通过二分查找的方式不断接近真实的经纬度，还是以北京(39.9042, 116.4074)为例：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash1.png" srcset="/img/loading.gif" lazyload></p>
<p>如图所示，维度39.9042经过三次二分最终落在区间[0, 45)内，从根节点到叶子节点的路径编码是100，也就是说，我们通过编码100就知道北京的维度在区间[0, 45)内。可想而知，随着上述二叉树的高度不断增高，即叶子节点区间更加精细，我们通过编码得到的经纬度误差也就越低。</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash2.png" srcset="/img/loading.gif" lazyload></p>
<p>同理，北京的经度编码为110。</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash3.jpg" srcset="/img/loading.gif" lazyload></p>
<p>至此，我们实际上是将整个地球的表面切割为一个个小方块，编码位数越长，每个小方块越小，即小方块所代表的经纬度精度越高。</p>
<p>然后将经纬度的编码进行整合，经度编码全部放在偶数位，纬度编码全部放在奇数位，那北京的最终编码为：111000。如此一来，一般情况下，经纬度相邻的位置，其小方格也相邻，即地理位置也是相邻的。但是，对于一些临界值，经纬度相邻，小方格可能差的很远，所以我们一般通过查询给定小方格四周4到8个小方格来查找相邻地理位置。</p>
<h1 id="三-对象"><a href="#三-对象" class="headerlink" title="三.对象"></a>三.对象</h1><p>首先，redis数据库中的数据都是通过键值对（字典）的形式组织的。其中，键key永远是字符串对象。</p>
<p>其次，redis中只有字符串对象可以被嵌套使用，其余对象（list、set、zset、hash对象）都不可以互相嵌套使用。例如，[“a”, “b”]是允许的，但[{“k1”: “v1”}, {“k2”: “v2”}]是不允许的。</p>
<p>下面是redis对象的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisObject</span> </span>&#123;<br>  <span class="hljs-comment">// 类型</span><br>  uint4 type;<br>  <span class="hljs-comment">// 具体的数据结构</span><br>  uint4 encoding;<br>  <span class="hljs-comment">// 引用计数</span><br>  <span class="hljs-keyword">int</span> refcount;<br>  <span class="hljs-comment">// 对象最后一次被命令程序访问的时间点</span><br>  <span class="hljs-keyword">int</span> lru;<br>  <span class="hljs-comment">// 指针，指向具体对象</span><br>  Object ptr;<br>&#125;<br><br><span class="hljs-comment">// 查看key对应的value.type</span><br>TYPE &#123;key&#125;<br><span class="hljs-comment">// 查看key对应的value.encoding</span><br>OBJECT ENCODING &#123;key&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-string对象"><a href="#1-string对象" class="headerlink" title="1.string对象"></a>1.string对象</h2><p>string对象可以用来存储整数（12345）、浮点数（123.45）、字符串（“xqz”），其底层的实现方式是不同的，我们逐个探讨。</p>
<h3 id="1-1-整数"><a href="#1-1-整数" class="headerlink" title="1.1.整数"></a>1.1.整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = <span class="hljs-keyword">int</span><br>obj.ptr = 具体的整数<br></code></pre></td></tr></table></figure>

<h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2.字符串"></a>1.2.字符串</h3><p>当创建的字符串长度 &gt; 39B时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = raw<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure>

<p>当创建的字符串长度 &lt;= 39B时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure>

<p>可以看到，存储字符串时，底层数据结构都是sds，但是具体的编码方式不同：</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">内存结构</th>
<th align="left">读写操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">raw</td>
<td align="left">obj和sds分开申请，两片独立的内存空间，使用ptr指针连接</td>
<td align="left">可读/可写</td>
</tr>
<tr>
<td align="left">embstr</td>
<td align="left">obj和sds同时申请，一片连续的内存空间，使用ptr指针连接</td>
<td align="left">只读</td>
</tr>
</tbody></table>
<h3 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3.浮点数"></a>1.3.浮点数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure>

<p>浮点数实际是通过字符串来存储的，在浮点数计算时，redis从sds内取出字符串，转换成浮点数进行计算，并将计算结果再次转换成字符串进行存储。另外，过长的整型数也是通过这种方式存储的。</p>
<h3 id="1-4-编码转换"><a href="#1-4-编码转换" class="headerlink" title="1.4.编码转换"></a>1.4.编码转换</h3><p>当我们执行操作将整形数据变为字符串时，该对象的编码格式也变成了raw，如 1+”a”这种操作。</p>
<p>之前也提到，embstr是只读的，所以当我们修改embstr编码的字符串时，其底层编码也会变为raw。</p>
<h2 id="2-list对象"><a href="#2-list对象" class="headerlink" title="2.list对象"></a>2.list对象</h2><p>同时满足以下两个条件的list对象使用ziplist编码，即压缩列表数据结构，否则使用linkedlist编码，即双向链表数据结构。</p>
<ol>
<li>list中元素个数小于512（list-max-ziplist-entries可调）</li>
<li>list中所有字符串元素长度小于64字节（list-max-ziplist-value可调）</li>
</ol>
<p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到linkedlist，将保存在压缩列表的元素遍历取出，转成双向链表节点保存。</p>
<p>反之，若一开始是linkedlist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<p>另外，redis 3.2版本后引入quicklist数据结构，本文暂不介绍。</p>
<h3 id="2-1-ziplist编码"><a href="#2-1-ziplist编码" class="headerlink" title="2.1.ziplist编码"></a>2.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure>

<h3 id="2-2-linkedlist编码"><a href="#2-2-linkedlist编码" class="headerlink" title="2.2.linkedlist编码"></a>2.2.linkedlist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = linkedlist<br>obj.ptr = 双向链表对象<br></code></pre></td></tr></table></figure>

<h2 id="3-hash对象"><a href="#3-hash对象" class="headerlink" title="3.hash对象"></a>3.hash对象</h2><p>同时满足以下两个条件的hash对象使用ziplist编码，即压缩列表数据结构，否则使用ht编码，即字典数据结构。</p>
<ol>
<li>hash中元素个数小于512（hash-max-ziplist-entries可调）</li>
<li>hash中所有字符串元素（键或值）长度小于64字节（hash-max-ziplist-value可调）</li>
</ol>
<p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在压缩列表的元素遍历取出，转成字典节点保存。</p>
<p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<h3 id="3-1-ziplist编码"><a href="#3-1-ziplist编码" class="headerlink" title="3.1.ziplist编码"></a>3.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure>

<p>插入元素时，会先往压缩列表中添加键对象，再往压缩列表中添加值对象。</p>
<h3 id="3-2-ht编码"><a href="#3-2-ht编码" class="headerlink" title="3.2.ht编码"></a>3.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure>

<h2 id="4-set对象"><a href="#4-set对象" class="headerlink" title="4.set对象"></a>4.set对象</h2><p>同时满足以下两个条件的set对象使用intset编码，即整数集合数据结构，否则使用ht编码，即字典数据结构。</p>
<ol>
<li>set中元素个数小于512（set-max-ziplist-entries可调）</li>
<li>set中所有元素均为整数</li>
</ol>
<p>若一开始是intset编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在整数集合的元素遍历取出，转成字典节点保存。</p>
<p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<h3 id="4-1-intset编码"><a href="#4-1-intset编码" class="headerlink" title="4.1.intset编码"></a>4.1.intset编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = intset<br>obj.ptr = 整数集合对象<br></code></pre></td></tr></table></figure>

<h3 id="4-2-ht编码"><a href="#4-2-ht编码" class="headerlink" title="4.2.ht编码"></a>4.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure>

<p>实现类似于java的HashSet，即字典键保存数据，字典值为NULL。</p>
<h3 id="4-3-聚合统计操作"><a href="#4-3-聚合统计操作" class="headerlink" title="4.3.聚合统计操作"></a>4.3.聚合统计操作</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 返回给定所有集合的并集</span><br><span class="hljs-function"><span class="hljs-title">SUNION</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回给定所有集合的并集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SUNIONSTORE</span></span> dest key1 key2 ...<br><br><span class="hljs-comment">// 返回给定所有集合的交集</span><br><span class="hljs-function"><span class="hljs-title">SINTER</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回给定所有集合的交集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SINTERSTORE</span></span> dest key1 key2 ...<br><br><span class="hljs-comment">// 返回key1集合与其他所有集合的差集</span><br><span class="hljs-function"><span class="hljs-title">SDIFF</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回key1集合与其他所有集合的差集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SDIFFSTORE</span></span> dest key1 key2 ...<br></code></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li>由于这些统计计算比较耗时，执行上述命令可能会阻塞主线程。因此，对于SUNION、SINTER、SDIFF这类纯读命令，可以在从库上执行。</li>
<li>如果服务器处于集群模式，即数据分散在多个实例上，那么使用上述的统计命令时，可能由于多个key存在多个实例上，导致结果错误或直接报错。即上述命令不支持跨机器查询。</li>
</ul>
<p>所以，实际开发中，复杂的聚合统计操作不应该使用Redis完成。</p>
<h2 id="5-zset有序集合对象"><a href="#5-zset有序集合对象" class="headerlink" title="5.zset有序集合对象"></a>5.zset有序集合对象</h2><p>同时满足以下两个条件的zset对象使用ziplist编码，即压缩列表数据结构，否则使用skiplist编码，这里指跳表+字典数据结构。</p>
<ol>
<li>zset中元素个数小于128（zset-max-ziplist-entries可调）</li>
<li>zset中所有字符串元素长度小于64字节（zset-max-ziplist-value可调）</li>
</ol>
<p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到skiplist，将保存在压缩列表的元素遍历取出，转成跳表+字典节点保存。</p>
<p>反之，若一开始是skiplist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p>
<h3 id="5-1-ziplist编码"><a href="#5-1-ziplist编码" class="headerlink" title="5.1.ziplist编码"></a>5.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure>

<p>插入元素时，会遍历压缩列表所有元素，根据score从小往大的顺序（即靠近表头位置的元素score小），先往压缩列表中添加数据对象，再往压缩列表中添加score对象。</p>
<h3 id="5-2-skiplist编码"><a href="#5-2-skiplist编码" class="headerlink" title="5.2.skiplist编码"></a>5.2.skiplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = skiplist<br>obj.zsl = 跳表对象<br>obj.dict = 字典对象<br></code></pre></td></tr></table></figure>

<p>跳表中元素按score从小往大的顺序排列。</p>
<p>字典键等于数据元素（string类型），字典值等于score（double类型），即该字典的作用时从元素映射到对应score。</p>
<p>为什么需要跳表+字典两个数据结构？速度。如前所述，跳表可以提供优秀的范围查找能力，字典做不到。字典可以O(1) 地查看元素分值，跳表做不到（需要遍历找到节点）。</p>
<p>最后一点，跳表与字典对应的底层数据对象，是共用的，这是为了节约空间。</p>
<h1 id="四-自定义数据结构"><a href="#四-自定义数据结构" class="headerlink" title="四.自定义数据结构"></a>四.自定义数据结构</h1><h2 id="1-自定义新数据类型的底层结构"><a href="#1-自定义新数据类型的底层结构" class="headerlink" title="1.自定义新数据类型的底层结构"></a>1.自定义新数据类型的底层结构</h2><p>我们开发一个新数据类型：单链表。使用singlelist.h文件保存单链表的基本定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleList</span> </span>&#123;<br>    SingleListNode head;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleListNode</span> </span>&#123;<br>    String value;<br>    SingleListNode next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-增加新数据类型的全局定义"><a href="#2-增加新数据类型的全局定义" class="headerlink" title="2.增加新数据类型的全局定义"></a>2.增加新数据类型的全局定义</h2><p>在server.h文件中新增单链表的全局定义。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">...<br><span class="hljs-comment">// 数字7是根据现有枚举值追加的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_SINGLE_LIST 7</span><br></code></pre></td></tr></table></figure>

<h2 id="3-开发新数据类型的构造和析构函数"><a href="#3-开发新数据类型的构造和析构函数" class="headerlink" title="3.开发新数据类型的构造和析构函数"></a>3.开发新数据类型的构造和析构函数</h2><p>根据Redis规范，新建t_singlelist.c文件保存单链表的各种操作，如构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">SingleList <span class="hljs-title">newSingleList</span><span class="hljs-params">()</span> </span>&#123;<br>    SingleList list = zmalloc(sizeof());<br>    list.head = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在object.c文件中增加新数据结构的全局创建函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">robj <span class="hljs-title">createSingleList</span><span class="hljs-params">()</span> </span>&#123;<br>    SingleList list = newSingleList();<br>    robj o = createObject(OBJ_SINGLE_LIST, list);<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>createObject函数是Redis提供的创建Redis对象的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">robj <span class="hljs-title">createObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, Object ptr)</span> </span>&#123;<br>    robj o = zmalloc(sizeof());<br>    o.type = type;<br>    o.ptr = ptr;<br>    ...<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>析构函数创建过程类似。</p>
<h2 id="4-开发新数据类型的命令操作"><a href="#4-开发新数据类型的命令操作" class="headerlink" title="4.开发新数据类型的命令操作"></a>4.开发新数据类型的命令操作</h2><p>我们新增一个往单链表末尾插入元素的命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SLINSERT key value<br></code></pre></td></tr></table></figure>

<p>首先，在t_singlelist.c文件中实现该操作的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slinsertCommand</span><span class="hljs-params">(RedisClient c)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，在server.h文件中声明这个函数，以便在server.c文件中可以引用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slinsertCommand</span><span class="hljs-params">(RedisClient c)</span></span><br></code></pre></td></tr></table></figure>

<p>最后，在server.c文件中将命令与实现函数关联起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">redisCommandTable[] = [<br>    ...<br>    &#123;<span class="hljs-string">&quot;SLINSERT&quot;</span>, slinsertCommand, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;m&quot;</span>, ....&#125;<br>]<br></code></pre></td></tr></table></figure>

<h1 id="五-对象其他细节"><a href="#五-对象其他细节" class="headerlink" title="五.对象其他细节"></a>五.对象其他细节</h1><h2 id="1-命令类型检查"><a href="#1-命令类型检查" class="headerlink" title="1.命令类型检查"></a>1.命令类型检查</h2><p>大体上可以将redis的操作键的命令分为两类</p>
<ol>
<li>可以对任意对象类型生效</li>
<li>只对命令绑定的对象类型生效</li>
</ol>
<p>对于第二种类型命令，redis会根据obj.type字段，在执行命令前主动检查：</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/checkobject.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-命令多态实现"><a href="#2-命令多态实现" class="headerlink" title="2.命令多态实现"></a>2.命令多态实现</h2><ul>
<li>基于类型的多态：可以对任意对象类型生效的命令，会根据value对象具体类型，做不同处理</li>
<li>基于编码的多态：作用到具体对象上的命令，会根据对象编码，调用对应数据结构API实现命令</li>
</ul>
<h2 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3.内存回收机制"></a>3.内存回收机制</h2><p>c语言不像java，java虚拟机会帮助程序员管理对象占用的内存，在对象不被使用时自动释放内存。redis使用引用计数算法实现了一套内存管理机制，现简单介绍。</p>
<p>首先了解下redis对象生命周期</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/objectlife.png" srcset="/img/loading.gif" lazyload></p>
<p>与之对应的，之前说到的obj.refcount值是这样变化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建一个对象时，refcount初始化为1，因为不论有无key对象，服务器都需要持有这个对象</span><br>Object obj = <span class="hljs-keyword">new</span> StringObject();<br><br><span class="hljs-comment">// 对象被新程序使用时，调用incrRefCount(obj)函数，obj.refcount++</span><br><span class="hljs-comment">// 对象不再被新程序使用时，调用decrRefCount(obj)函数，obj.refcount--</span><br>...<br>  <br><span class="hljs-comment">// 最终，调用decrRefCount(obj)函数，将obj.refcount减为0，会导致该对象被redis服务器回收，内存被释放</span><br>decrRefCount(obj);<br></code></pre></td></tr></table></figure>

<p>涉及到函数列表：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">incrRefCount()</td>
<td align="left">refcount++</td>
</tr>
<tr>
<td align="left">decrRefCount()</td>
<td align="left">refcount–</td>
</tr>
<tr>
<td align="left">resetRefCount()</td>
<td align="left">refcount=0，但是不会释放对象</td>
</tr>
</tbody></table>
<h2 id="4-对象共享机制"><a href="#4-对象共享机制" class="headerlink" title="4.对象共享机制"></a>4.对象共享机制</h2><p>类似于java常量池机制，redis也会将常用字符串做为“常量”共享起来。在redis初始化服务器时，会创建0-9999共一万个整数字符串（通过redis.h/REDIS_SHARED_INTEGERS设置），后续共享使用。这些对象不仅是字符串对象可以共享，前述所有类型对象都可以使用。</p>
<p>但是，需要注意，redis只支持整数字符串的共享，这主要是因为要共享一个对象，当然需要判断两个引用对应的对象是否一致，整数对象可以在O(1)时间内验证，但当字符串复杂时，或其他结构的对象时（如list），这个验证过程会很消耗CPU并且不可控。</p>
<p>最后需要注意，当对象被共享时，其refcount++。</p>
<h2 id="5-对象空转时长"><a href="#5-对象空转时长" class="headerlink" title="5.对象空转时长"></a>5.对象空转时长</h2><p>前面提到的obj.lru记录了该对象最后一次被命令程序访问的时间点。</p>
<p>我们可以通过 OBJECT IDLETIME 命令查看值对象的 空转时长=当前时间-obj.lru。这个命令比较特殊，不会刷新obj.lru的值。</p>
<p>空转时长是当服务器内存不够时，用来判断该对象是否可以被回收时使用的，这个之后的专题会详细介绍。</p>
<p>至此，我们了解了redis所有的对象及其底层数据结构，希望对大家的工作学习有所帮助，谢谢～</p>
<p><strong>todo list:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 图完善</li>
<li><input disabled="" type="checkbox"> 源码解读</li>
<li><input disabled="" type="checkbox"> 指令及对应数据结构操作</li>
<li><input disabled="" type="checkbox"> 新版本数据结构</li>
<li><input disabled="" type="checkbox"> 布隆过滤器</li>
<li><input disabled="" type="checkbox"> Stream</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/redis/">redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/finish/">finish</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/31/Redis%E5%9F%BA%E7%A1%80-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis基础-单机数据库</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/08/SAC-003-REST/">
                        <span class="hidden-mobile">SAC-003-REST</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"64e7a0af76ea907275e7","clientSecret":"58fc6a6232d3179936704144df3ddeef170c2fdd","repo":"bolg-comment","owner":"Xzzz583722585","admin":["Xzzz583722585"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '9a15c52c8692c7b6a9b1df0d7dff66bb'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
