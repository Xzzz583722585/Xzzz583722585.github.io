

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Jon Xzzz">
  <meta name="keywords" content="">
  
  <title>redis面试题 - Jon Xzzz</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.jonxzzz.xyz","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SAmnq0afTzl9DvACTmD2ys0H-gzGzoHsz","app_key":"yxbky5wsCPQcibrgyi8HmBtm","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Jon Xzzz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="redis面试题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-07-09 14:57" pubdate>
        2023年7月9日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      155
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        浏览 <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">redis面试题</h1>
            
            <div class="markdown-body">
              <h1 id="基础通用"><a href="#基础通用" class="headerlink" title="基础通用"></a>基础通用</h1><h2 id="1-业务使用场景"><a href="#1-业务使用场景" class="headerlink" title="1.业务使用场景"></a>1.业务使用场景</h2><p><strong>缓存</strong>：</p>
<p>对于我们的系统而言，缓存的目的是为了减少对底层数据库、RPC的访问，一是加快了访问速度，二是降低层次请求压力。</p>
<p>Redis适用于缓存的原因有：</p>
<ol>
<li>基于内存的数据库，处理速度快</li>
<li>有内置的数据过期、内存淘汰策略</li>
</ol>
<p>首先需要明确，由于Redis并不是内嵌在访问数据库的关键路径上，所以应用程序需要去处理缓存命中、缓存丢失、缓存更新，即Redis此时是作为旁路缓存在使用的。</p>
<p>Redis作为缓存有两种类型：</p>
<ul>
<li>只读缓存：只加速读请求。优点是写操作都在数据库完成，数据库提供数据可靠性保障，不会有数据丢失的风险。适合于数据一致性要求高的场景。缺点是相比于下面要讲的读写缓存，会降低一次读请求的处理速度。<ul>
<li>应用需要读数据时，会先访问Redis，若Redis有该数据，则直接返回。否则访问数据库，并更新缓存，然后返回。</li>
<li>应用需要写数据时，一般考虑先更新数据库，再删除缓存的方案。然后读请求会发生缓存缺失，访问数据库后更新缓存。</li>
</ul>
</li>
<li>读写缓存：可以加速读写请求。优点是读请求不会由于数据更新导致未命中。适合于对访问性能要求高的场景。缺点是高并发场景下保证数据一致性困难。<ul>
<li>应用需要读数据时，会先访问Redis，若Redis有该数据，则直接返回。否则访问数据库，并更新缓存，然后返回。</li>
<li>应用需要写数据时<ul>
<li>同步直写模式：数据同时写Redis和数据库，两边都完成后再给应用返回<ul>
<li>优点：数据可靠性高</li>
<li>缺点：降低写请求失败概率、处理性能</li>
</ul>
</li>
<li>异步写回模式：数据先写在缓存，等到合适的时机同步到数据库。一般Redis不实现这类缓存。<ul>
<li>优点：写请求处理性能好</li>
<li>缺点：有数据丢失、不一致风险，需要应用自己实现写回机制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>分布式锁</strong>：</p>
<ul>
<li><p>redis实现</p>
<p>回顾下临界资源访问的四个原则：</p>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ol>
<p>实现分布式锁需要注意两个问题：</p>
<ol>
<li>加锁和解锁的过程需要具有原子性</li>
<li>分布式锁服务需要保障可靠性</li>
</ol>
<p>我们以单数量的锁为例，即每把锁同时只能被获取一次，看看单实例Redis实现分布式锁的过程：</p>
<p>加锁过程：</p>
<ol>
<li>读取锁变量</li>
<li>判断锁变量值</li>
<li>修改锁变量值</li>
</ol>
<p>加锁实现方案，使用SET命令进行加锁，使用NX选项判断key值不存在时才加锁，使用PX选项设置过期时间。这样，就实现了空闲让进、忙则等待、有限等待的原则。至于让权等待，对于Redis层而言，加锁失败不会阻塞后续命令处理。对于应用层而言，可以适当重试或直接抛异常。另外，我们最好给每把锁都设置合适的唯一key，防止客户端之间误操作。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> key <span class="hljs-comment">value NX PX 1000</span><br></code></pre></td></tr></table></figure>

<p>解锁过程：</p>
<ol>
<li>读取锁变量</li>
<li>判断锁变量值</li>
<li>删除锁变量</li>
</ol>
<p>解锁实现方案：</p>
<ul>
<li>使用lua脚本</li>
<li>使用事务+pipeline+watch</li>
</ul>
<p>我们再看下Redis集群实现的高可靠分布式锁方案Redlock：</p>
<ol>
<li>客户端获取当前时间</li>
<li>向所有实例发起加锁操作，并统计每个实例的耗时</li>
<li>若加锁成功，则直接返回：<ol>
<li>超过半数的实例加锁成功</li>
<li>获取锁的总耗时没有超过锁的有效时间</li>
</ol>
</li>
<li>若加锁失败，则释放所有实例上的锁</li>
</ol>
</li>
<li><p>Mysql实现</p>
<p>唯一索引</p>
<p>缺点：</p>
<ul>
<li>没有失效时间</li>
<li>唯一索引冲突立即报错，只能非阻塞</li>
<li>不可重入</li>
</ul>
</li>
<li><p>ETCD实现</p>
<p>加锁：</p>
<ul>
<li><p>创建租约（设置失效时间）</p>
<ul>
<li>lease.grant</li>
<li>lease.keepAliveOnce</li>
</ul>
</li>
<li><p>lock.lock 获取锁</p>
</li>
</ul>
<p>解锁：</p>
<ul>
<li>失效租约 lease.revokeLease</li>
<li>lock.unlock 释放锁</li>
</ul>
</li>
<li><p>zookeeper实现</p>
<p>加锁：</p>
<ul>
<li>设置临时目录，就拥有了过期时间</li>
<li>设置有序目录，获取目录后检查是否为最小id，若是则获取到锁，否则监控自己的前一个节点，当他失效时再次检查是否获取到锁</li>
</ul>
<p>解锁：</p>
<ul>
<li>会话结束，自动删除临时节点，触发后一个节点的通知</li>
<li>会话超时，自动删除临时节点，触发后一个节点的通知</li>
</ul>
</li>
</ul>
<p><strong>延迟队列</strong></p>
<p>todo</p>
<p><strong>消息队列</strong>：</p>
<p>可以使用LIST、STREAMS对象实现简单的消息队列，但我们的系统中使用的是kafka</p>
<h2 id="2-缓存与数据库的数据不一致"><a href="#2-缓存与数据库的数据不一致" class="headerlink" title="2.缓存与数据库的数据不一致"></a>2.缓存与数据库的数据不一致</h2><ul>
<li>只读缓存<ul>
<li>更新缓存：缓存被更新后不一定会马上被利用，所以一是浪费内存，二是很多时候缓存中的值是根据数据库值计算得出，白白浪费了计算资源。<ul>
<li>先更新缓存，再更新数据库<ul>
<li>异常情况<ul>
<li>部分失败场景：数据库更新失败时，缓存与数据库的数据不一致，若后续没有办法识别这一情况，则数据永久丢失：增加重试机制，降低失败可能性</li>
<li>读写并发场景：对业务无影响</li>
<li>写写并发场景：由于并发导致缓存与数据库更新顺序不一致，造成数据不一致：分布式锁</li>
</ul>
</li>
</ul>
</li>
<li>先更新数据库，再更新缓存<ul>
<li>异常情况<ul>
<li>部分失败场景：缓存更新失败时，缓存与数据库的数据不一致，后续请求会直接命中缓存，得到旧值：增加重试机制，降低失败可能性</li>
<li>读写并发场景：对业务影响小，可以忽略</li>
<li>写写并发场景：由于并发导致缓存与数据库更新顺序不一致，造成数据不一致：分布式锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>删除缓存<ul>
<li>先删除缓存，再更新数据库<ul>
<li>异常情况<ul>
<li>部分失败场景：数据库更新失败，导致下次访问缓存缺失：增加重试机制，降低失败可能性</li>
<li>读写并发场景：线程A先删除缓存，此时线程B访问缓存，发生缓存丢失，于是访问数据库，更新缓存为旧值，最后线程A再更新数据库为新值。发生缓存不一致：延迟双删机制不能从根本上解决问题，还是需要分布式锁</li>
<li>写写并发场景：对业务无影响</li>
</ul>
</li>
</ul>
</li>
<li>先更新数据库，再删除缓存：推荐<ul>
<li>异常情况<ul>
<li>部分失败场景：Redis更新失败，导致Redis与数据库数据不一致，下次访问到Redis中的旧值：增加重试机制，降低失败可能性</li>
<li>读写并发场景：线程A先更新数据库为新值，此时线程B访问缓存，得到旧值，最后线程A再删除缓存：对业务影响小，可以忽略</li>
<li>写写并发场景：对业务无影响</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>综上所述：<ul>
<li>部分失败问题：增加重试机制，降低失败可能性。重试可以升级为异步重试，利用消息队列，提高消息的可靠性。异步重试又可以再一次升级为订阅数据库变更日志，放入MQ中，异步执行第二步操作，好处是应用程序主体不关心重试的动作。</li>
<li>缓存被旧值回写的问题：延迟双删，但延迟双删无论如何优化，都不能很好的把握延迟的时间，所以还是推荐“先更新数据库，再删除缓存”的策略</li>
<li>写写并发导致的缓存与数据库写顺序不一致问题：删除缓存策略对业务无影响。更新缓存策略，本质上需要并发控制，即通过分布式锁解决</li>
</ul>
</li>
</ul>
</li>
<li>读写缓存<ul>
<li>同步直写模式：Redis与数据库数据一致。应用程序需要保证写Redis和写数据库的原子性，异常情况与只读缓存差不多，但是此时需要保证写Redis与写数据库都成功，否则进行数据回滚，所以不存在上述问题。</li>
<li>异步写回模式：会发生数据丢失。Redis不适用这种模式</li>
</ul>
</li>
</ul>
<p>无论哪种模式，都需要给缓存数据设置合理的过期时间，防止错误数据长时间影响业务。如果要追求强一致性，引入分布式事务，那势必会影响性能，与缓存的初衷不符。</p>
<h2 id="6-缓存雪崩"><a href="#6-缓存雪崩" class="headerlink" title="6.缓存雪崩"></a>6.缓存雪崩</h2><p>缓存雪崩是指大量请求无法在缓存中处理，进而发送到数据库，导致数据库压力激增。原因：</p>
<ol>
<li>大量数据同时过期<ol>
<li>避免给大量数据设置相同的过期时间，可以增加小幅度的随机值</li>
<li>对非核心数据的请求可以服务降级</li>
<li>新上线的业务或数据</li>
</ol>
</li>
<li>缓存实例大量故障<ol>
<li>事前预防，利用主从复制机制、分片机制提高缓存系统可用性</li>
<li>服务熔断、限流，避免拖垮整个服务</li>
<li>数据预热</li>
</ol>
</li>
</ol>
<h2 id="7-缓存击穿"><a href="#7-缓存击穿" class="headerlink" title="7.缓存击穿"></a>7.缓存击穿</h2><p>缓存击穿是指针对某个访问非常频繁的热点数据，无法在缓存中进行处理，进而大量请求发送到数据库，导致数据库压力激增。原因：</p>
<ol>
<li>热点数据过期<ol>
<li>不设置过期时间</li>
</ol>
</li>
</ol>
<h2 id="8-缓存穿透"><a href="#8-缓存穿透" class="headerlink" title="8.缓存穿透"></a>8.缓存穿透</h2><p>缓存穿透是指要访问的数据既不在缓存中，也不在数据库，如此一来，缓存就成了摆设，并且每次请求都会访问缓存和数据库。</p>
<p>原因：</p>
<ol>
<li>业务层误操作</li>
<li>恶意访问没有的数据</li>
</ol>
<p>解决方案：</p>
<ol>
<li>设置缓存空值或缺省值</li>
<li>利用布隆过滤器做数据存在性检查</li>
<li>请求前置进行安全性、合法性检查</li>
</ol>
<h2 id="10-缓存无底洞"><a href="#10-缓存无底洞" class="headerlink" title="10.缓存无底洞"></a>10.缓存无底洞</h2><p>对于分片级群，范围查询或更新会涉及多个集群实例，有时候我们为了提升查询的效率，选择增加集群节点，反而使查询性能下降。</p>
<p>原因：</p>
<ol>
<li>多个实例的交互涉及多个网络I/O，客户端或中间件还需要管理并合并数据，增加实例后，会有更多的网络I/O，性能可能反而下降</li>
</ol>
<p>解决方案：</p>
<ol>
<li>尽量避免范围查询</li>
<li>经常用到的范围查询，其涉及的键想办法映射到少数几个固定节点上</li>
<li>优化连接的使用效率，使用长连接、连接池、NIO等技术</li>
</ol>
<h2 id="11-Redis为什么快"><a href="#11-Redis为什么快" class="headerlink" title="11.Redis为什么快"></a>11.Redis为什么快</h2><p>Redis可以达到微妙级别的请求处理速度，我们以请求的处理流程视角来分析这个问题：</p>
<ol>
<li>新版本的Redis客户端具有缓存功能，可以快速返回查询结果</li>
<li>新版本的Redis客户端使用RESP3协议，有利于服务器更快速地解析命令</li>
<li>Redis服务器采用Reactor模式的网络处理模型，可以高效的处理套接字请求，而不会导致服务器主进程被网络I/O阻塞</li>
<li>Redis是内存数据库，所有操作都在内存上完成，内存本身的访问速度很快。</li>
<li>Redis实现了很多高性能的数据结构，而处理Redis命令的底层就是操作这些数据结构。<ol>
<li>利用HashTable存储对象键值对，可以达到平均O(1)的时间复杂度</li>
</ol>
</li>
</ol>
<h2 id="12-Redis潜在的慢操作有哪些"><a href="#12-Redis潜在的慢操作有哪些" class="headerlink" title="12.Redis潜在的慢操作有哪些"></a>12.Redis潜在的慢操作有哪些</h2><p> 首先我们要知道如何判断Redis变慢了。我们可以测量低压力，无干扰情况下的系统基线性能，以此为依据，查看实际运行中的Redis响应速度，是否超出基线的两倍甚至更多。</p>
<p>然后介绍一些常见的拖慢Redis处理速度的原因：</p>
<ol>
<li>数据结构方面：<ol>
<li>利用HashTable存储对象键值对：<ol>
<li>当产生hash冲突时会降低本次的查询速度</li>
<li>rehash过程中，每处理一次请求，会将当前下标的链表迁移到备用桶上去，一定程度上降低了本次请求的速度</li>
</ol>
</li>
<li>范围操作比较耗时，如：HGETALL、SMEMBERS等，可以用SCAN系列的命令分批查询</li>
</ol>
</li>
<li>请求处理方面：<ol>
<li>处理请求<ol>
<li>Redis将套接字产生的文件事件放放入一个队列内，使用单线程依次处理。如果每个请求耗时较高，就会影响其后的所有命令处理。常见的耗时请求有：<ol>
<li>操作bigkey</li>
<li>复杂度较高的命令：集合全量查询和聚合操作</li>
<li>Redis采用惰性过期机制，是主线程处理请求时删除过期数据的。如果此时有大量过期数据，会有阻塞风险</li>
<li>主线程执行内存淘汰策略。如果写入请求时当前内存已经超过限制，那么就会进行内存淘汰，会有阻塞风险</li>
</ol>
</li>
<li>虽然Redis采用I/O多路复用技术，使得服务器可以同时监听多个套接字的事件，但是，依然是由主进程读写客户端数据。Redis6.0版本解决了这个问题。</li>
<li>操作系统内存不足导致内存置换</li>
</ol>
</li>
<li>磁盘<ol>
<li>AOF开启always机制，每次写入操作都会将其写进磁盘，而磁盘处理速度远远慢于内存处理速度，会降低命令执行速度。另外，AOF重写进程或者系统其他进程都会抢占磁盘I/O，从而阻塞AOF刷盘。</li>
<li>生成RDB文件，进行AOF重写虽然都是子进程负责，但是子进程是由主进程fork出来，而大内存会导致fork操作复制PCB阻塞</li>
<li>异步RDB、AOF重写都会fork子进程，此时会采用写时复制机制。若是开启了内存大页，那么写时复制就会拷贝很大的一块内存，影响主进程处理速度。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="13-Redis为什么使用单线程"><a href="#13-Redis为什么使用单线程" class="headerlink" title="13.Redis为什么使用单线程"></a>13.Redis为什么使用单线程</h2><p>理论上，在资源分配合理的情况下，随着服务器线程数的增加，即处理请求操作的资源实体的增加，系统吞吐率也会随之增加。但实际上，一开始线程数增加确实会增加系统吞吐率，但逐渐往后，线程数与吞吐率并不是线性关系，吞吐率的增长会逐渐放缓甚至下降。一个关键原因是实际业务场景存在许多临界资源，他们需要被互斥访问，这就对提出了对临界资源访问控制的要求。一般我们的做法是加各种锁，但这会增加系统设计的复杂度。所以为了避免这些问题，Redis才用了单线程的模式。</p>
<p>另外，单线程的Redis依然具有很快的处理速度。（原因见1）。</p>
<h2 id="14-并发控制"><a href="#14-并发控制" class="headerlink" title="14. 并发控制"></a>14. 并发控制</h2><ol>
<li>串行处理</li>
<li>加锁</li>
<li>原子操作<ol>
<li>原子命令</li>
<li>lua脚本</li>
</ol>
</li>
<li>事务</li>
</ol>
<h2 id="15-事务及ACID属性的支持"><a href="#15-事务及ACID属性的支持" class="headerlink" title="15.事务及ACID属性的支持"></a>15.事务及ACID属性的支持</h2><p>Redis如何实现事务：</p>
<ol>
<li>MULTI显式开启事务</li>
<li>输入命令，缓存在事务队列中，暂不执行</li>
<li>EXEC执行事务队列中的所有命令</li>
<li>DISCARD放弃事务，清空事务队列</li>
</ol>
<p>WATCH机制：在事务执行前，监控一个或多个键的变化情况，当执行EXEC命令时，会校验这些被监控的键有没有被修改，若被修改过，就放弃执行事务。</p>
<p>另外，可以配合使用pipeline，在客户端缓存完整地事务队列，一次性发送给Redis，减少网络I/O，减少产生冲突的可能性。</p>
<p>ACID属性的支持：</p>
<ol>
<li>原子性：事务中的操作要么全做，要么全不做<ol>
<li>命令入队时就报错，保证原子性</li>
<li>命令执行时报错，不保证原子性</li>
<li>EXEC命令执行时实例崩溃，开启了AOF日志，保证原子性</li>
<li>EXEC命令执行时实例崩溃，没有开启AOF日志，不保证原子性</li>
</ol>
</li>
<li>一致性：事务的执行使数据库从一个一致性状态转移到另一个一致性状态<ol>
<li>命令入队时就报错，保证一致性</li>
<li>命令执行时报错，保证一致性</li>
<li>EXEC命令执行时实例崩溃，开启了RDB或AOF日志，保证一致性</li>
<li>EXEC命令执行时实例崩溃，没有开启AOF日志，保证一致性</li>
</ol>
</li>
<li>隔离性：并发执行的事务之间互不影响<ol>
<li>EXEC命令执行前，开启WATCH机制，保证隔离性</li>
<li>EXEC命令执行前，没有开启WATCH机制，不保证隔离性</li>
<li>EXEC命令执行后，保证隔离性</li>
</ol>
</li>
<li>永久性：事务对数据库的修改一旦提交，其影响是永久保留的<ol>
<li>无论采用何种持久化机制，都无法保证永久性</li>
</ol>
</li>
</ol>
<h1 id="数据类型与数据结构"><a href="#数据类型与数据结构" class="headerlink" title="数据类型与数据结构"></a>数据类型与数据结构</h1><h2 id="1-Redis有哪些数据类型及底层数据结构"><a href="#1-Redis有哪些数据类型及底层数据结构" class="headerlink" title="1.Redis有哪些数据类型及底层数据结构"></a>1.Redis有哪些数据类型及底层数据结构</h2><p>我学习、使用过的Redis数据类型分为四大类：</p>
<ol>
<li>基本数据类型<ol>
<li>字符串对象string<ol>
<li>常用命令：GET、SET、INCR、DECR</li>
<li>底层数据结构：sds，有不同编码格式：整数int、浮点数或小字符串embstr、大字符串raw</li>
</ol>
</li>
<li>列表对象list<ol>
<li>常用命令：LPUSH、LPOP、RPUSH、RPOP</li>
<li>底层数据结构：元素个数少或元素总长元素度小时用ziplist、否则用linkedlist</li>
</ol>
</li>
<li>哈希对象hash<ol>
<li>常用命令：HSET、HGET、HDEL、HEXISTS</li>
<li>底层数据结构：元素个数少或元素总长度小时用ziplist、否则用hashtable</li>
</ol>
</li>
<li>集合对象set<ol>
<li>常用命令：SADD、SPOP</li>
<li>底层数据结构：元素个数少或元素总长度小时用intset、否则用hashtable</li>
</ol>
</li>
<li>有序集合对象zset<ol>
<li>常用命令：ZADD、ZREM、ZRANGE</li>
<li>底层数据结构：元素个数少或元素总长度小时用ziplist、否则用skiplist</li>
<li>score相同，使用字典序，升序排列</li>
</ol>
</li>
</ol>
</li>
<li>Redis 拓展数据类型<ol>
<li>位图BitMap，底层用SDS字符串实现，利用其二进制安全的特性，使用每一个比特位存储二值状态数据。常见命令有：SETBIT、GETBIT、BITCOUNT（利用SWAR算法快速计算）、BITOP（AND、OR、NOT、XOR）</li>
<li>布隆过滤器BloomFilter：利用位图和多个hash函数，辅助判断元素是否已经存在。存在误判率。当布隆过滤器判断存在时，可能由于其他元素将当前元素的所有位都置为了1，所以会误判。但是判断不存在不会出现误判。</li>
<li>HyperLogLog：利用HyperLogLog算法进行基数统计。常见命令有：PFADD、PFCOUNT</li>
<li>GEO：主要用于存储地理位置信息。<ul>
<li>GEOHash编码：由于经纬度范围[-180, 180]，所以可以利用二分查找，将经纬度信息转换为二分查找的搜索路径的二进制编码，再将经纬度各自的二进制编码进行整合（经度编码全部放在偶数位，纬度编码全部放在奇数位），就将其映射成了一维空间上的连续编码，方便我们利用zset查询相邻地理位置。</li>
</ul>
</li>
<li>Streams：消息队列，实现基本的消息保存与消费，阻塞读取，生成消息唯一ID供幂等消费，保障消息可靠性</li>
</ol>
</li>
<li>自定义数据类型及数据结构</li>
</ol>
<p>Redis 底层数据类型有：</p>
<ol>
<li>简单动态字符串SDS，其特点有：<ol>
<li>记录了字符串未使用长度和已使用长度，可以在O(1)时间内得到字符串的这些长度值</li>
<li>随着字符串内容长度的变化，动态进行空间的重新分配，保证不会出现字符串内容溢出。具体策略是：<ol>
<li>字符串增长时<ul>
<li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li>
<li>当修改后的SDS长度小于1MB时，申请空间大小为当前空间的两倍，否则申请空间大小为当前空间大小再加1MB</li>
</ul>
</li>
<li>字符串减短时<ul>
<li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li>
</ul>
</li>
</ol>
</li>
<li>二进制安全</li>
<li>依然以’\0’结尾，可以直接使用C语言的字符串代码库</li>
</ol>
</li>
<li>老版本的双向链表LinkedList，目前已经被快速链表QuickList代替</li>
<li>字典HashTable<ol>
<li>其插入数据的过程是：<ol>
<li>利用hash函数获取key对应的hash值，对其进行二进制取模 &amp;(size-1)获取桶下标</li>
<li>将键值对对象添加进桶对应的链表内（头插法），即Redis用拉链法解决hash冲突</li>
</ol>
</li>
<li>当桶负载因子过大或者过小时，会进行rehash操作：<ol>
<li>为备用桶分配内存空间：扩大时分配第一个大于等于已使用空间*2的2^n，缩小时分配第一个大于等于已使用空间的2^n</li>
<li>伴随每次客户请求，除了正常处理请求外，还会将当前迁移下标链表内的所有键值对全部迁移到备用桶上面去，完成后迁移下标+1。迁移过程中，新插入的数据都会直接在备用桶完成，查询操作会先查当前桶，再查备用桶 </li>
<li>所有数据全部迁移完成后，将备用桶升级为当前桶，删除并释放当前桶的内存空间</li>
</ol>
</li>
</ol>
</li>
<li>跳表SkipList： 是一个多层级的单链表结构，其元素按照score从小到大的顺序，从前往后顺序排列，每个元素都会从第0层开始，有一定概率被连续分配到多个层级，层级越往上被分配的概率越小。如此一来，我们可以将高层链表看作低层链表的索引，从高往低快速检索数据。插入元素流程：<ol>
<li>利用随机函数，获取当前元素的层高（Redis每层概率0.25）</li>
<li>从元素的最高层开始（没有链表就新建一个），利用大小关系检索score，并将元素插入到本层的适当位置</li>
<li>上一层插入完成后转入下一层，一次完成插入，直到第0层完成</li>
</ol>
</li>
<li>整数集合IntSet。存储整数元素的数组，特点是：<ol>
<li>灵活：支持不同类型的整数</li>
<li>节约内存：定义了多种编码，并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li>
<li>一旦编码升级，就不会降级了</li>
</ol>
</li>
<li>压缩列表ZipList。已经被ListPack替代。<ol>
<li>优点<ul>
<li>节省空间</li>
</ul>
</li>
<li>缺点<ul>
<li>因为需要遍历访问，不适合保存过多元素</li>
<li>由于每个元素需要保存前一个节点的长度，根据前一个元素的长度大小，可能会占用1B或5B不定。当元素更新时，因为可能会引发连锁更新，所以不适合保存过大元素</li>
</ul>
</li>
</ol>
</li>
<li>快速链表QuickList。简单说，快速链表=双向链表+压缩列表，即双向链表的每个节点是一个压缩列表。这么做的目的是在获得压缩列表节约空间的好处同时，解决压缩列表无法存储过多元素的问题，并且控制了连锁更新的范围。</li>
<li>紧凑链表ListPack。本质上说，quickList并没有从根本上解决zipList连锁更新的问题，他只是将连锁更新的范围控制在一个节点内。并且，链表指针也会消耗内存空间，这不符合压缩列表的初衷。因此，紧凑链表ListPack重新设计了编码规范，元素不再存储前一个节点的大小，从根本上解决了连锁更新的问题。</li>
</ol>
<h1 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h1><h2 id="1-Redis-I-O网络模型"><a href="#1-Redis-I-O网络模型" class="headerlink" title="1.Redis I/O网络模型"></a>1.Redis I/O网络模型</h2><p>一般，我们处理一个请求会有以下几个阶段：</p>
<ol>
<li>监听客户端请求 listen</li>
<li>和客户端建立连接 accept</li>
<li>接收并客户端请求 recv</li>
<li>解析客户端请求 parse</li>
<li>处理客户端请求 process</li>
<li>客户端返回结果，即向socket写回数据 send</li>
</ol>
<p>Redis正是基于事件的回调机制，可以针对不同事件的发生，调用相应的处理函数，监听了多个套接字。</p>
<p>首先我们要知道，Redis服务器主进程就是一个事件循环处理函数，依次处理文件事件与时间事件，而文件事件指的就是接收客户端的命令请求，以及向客户端发送命令回复。Redis的文件事件处理器由四部分组成：套接字、I/O多路复用程序、文件事件分派器、文件事件处理器：</p>
<ul>
<li>套接字<ul>
<li>文件事件是对套接字操作的抽象。每当一个套接字准备好执行链接应答、写入、读取、关闭等操作时，就会产生一个文件事件。</li>
</ul>
</li>
<li>I/O多路复用程序<ul>
<li>基于操作系统提供的select/epoll机制，同时监听多个套接字，既实现了高性能的网络通信模型，又可以很好地与Redis服务器中同样以单线程运行的模块对接。</li>
<li>尽管由于服务器连接的多个套接字会并发地产生文件事件，但I/O多路复用程序总是会将所有产生事件的套接字，按照先后顺序、同步、每次一个的方案依次加入队列中，然后将套接字传送给文件事件分派器。只有当上一个套接字产生的事件被处理完毕后，I/O多路复用程序才会向文件事件分派器传送下一个套接字。</li>
</ul>
</li>
<li>文件事件分派器<ul>
<li>接收I/O多路复用程序传送来的套接字，根据套接字产生的事件的类型，为其关联不同的事件处理器进行处理。</li>
<li>文件事件类型：<ul>
<li>AE_READABLE：当套接字变得可读时（客户端对套接字执行connect、write、close操作），套接字产生AE_READABLE事件</li>
<li>AE_WRITABLE：当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件</li>
<li>当一个套接字同时产生AE_READABLE、AE_WRITABLE两类事件时，服务器会先处理AE_READABLE事件，再处理AE_WRITABLE事件。</li>
</ul>
</li>
</ul>
</li>
<li>文件事件处理器<ul>
<li>执行实际的处理动作。</li>
<li>分类：<ul>
<li>连接应答处理器：当服务器初始化的时候，会降<strong>服务器监听套接字的AE_READABLE事件</strong>与连接应答处理器关联起来。当有客户端连接服务器监听套接字时，套接字就会产生AE_READABLE事件，从而引发连接应答处理器的执行，并执行相应的套接字应答操作。</li>
<li>命令请求处理器：当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将<strong>客户端套接字的AE_READABLE事件</strong>和命令请求处理器关联起来。当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，从而引发命令请求处理器的执行，并执行相应的套接字读取操作。</li>
<li>命令回复处理器：当服务器有命令回复需要传输给客户端的时候，服务器会将<strong>客户端套接字的AE_WRITABLE事件</strong>和命令响应处理器关联起来。当客户端准备好接收服务器的命令回复的时候，套接字就会产生AE_WRITABLE事件，从而引发命令回复处理器的执行，并执行相应的套接字写入操作。</li>
<li>其他</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们讲一次完整的客户端与服务器的交互过程：</p>
<ol>
<li>假设Redis服务器已经启动完成，那么此时服务器监听套接字的AE_READABLE事件会与连接应答处理器关联起来，并处于监听状态。</li>
<li>客户端向服务器发起建立 socket 连接的请求，监听套接字会产生AE_READABLE事件，触发连接应答处理器执行。连接应答处理器会对客户端的连接请求进行应答，创建客户端套接字及客户端状态，并将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，并处于监听状态。</li>
<li>客户端建立连接后，向服务器发送命令，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行。命令请求处理器读取客户端命令，然后传递给相关程序去执行。</li>
<li>执行命令获得相应的命令回复后，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器执行。命令回复处理器将命令回复全部写入到套接字中后，就会解除客户端套接字的 AE_WRITEABLE 事件与命令回复处理器的关联。</li>
<li>命令回复会由套接字负责传输给客户端。</li>
</ol>
<h2 id="2-Redis6-0版本引入的多线程模型"><a href="#2-Redis6-0版本引入的多线程模型" class="headerlink" title="2.Redis6.0版本引入的多线程模型"></a>2.Redis6.0版本引入的多线程模型</h2><h1 id="持久化和内存"><a href="#持久化和内存" class="headerlink" title="持久化和内存"></a>持久化和内存</h1><h2 id="1-持久化机制都有哪些？各自的优缺点？如何使用？"><a href="#1-持久化机制都有哪些？各自的优缺点？如何使用？" class="headerlink" title="1.持久化机制都有哪些？各自的优缺点？如何使用？"></a>1.持久化机制都有哪些？各自的优缺点？如何使用？</h2><p>由于Redis是内存数据库，所以一旦服务器宕机，那么内存中的数据将会全部丢失。因此，Redis实现了RDB快照和AOF日志两类数据持久化机制：</p>
<ul>
<li><p>RDB快照</p>
<ul>
<li>作用是将服务器某个时刻的完整状态保存到磁盘中。save命令由主线程执行持久化，会阻塞主线程处理命令，此时数据不会被修改，可以正常进行快照持久化。bgsave命令会fork出子进程，主进程继续处理命令，子进程负责持久化。由于写时复制的原因，主进程在处理写命令时，会复制一份数据修改，不会影响子进程的快照持久化。我们可以配置多个save选项（服务器在x秒之内，对数据库至少进行了y次修改），服务器会定期检查，其中有一个选项被满足，就会触发RDB持久化。</li>
<li>优点<ul>
<li>保证了数据可靠性</li>
<li>数据恢复速度快</li>
<li>bgsave命令可以创建子进程执行持久化</li>
<li>RDB文件的内容为二进制的数据，占用内存更小，更紧凑，可以更快的传输到远程服务器进行服务恢复，更适合做为备份文件。压缩后更是如此。</li>
</ul>
</li>
<li>缺点<ul>
<li>因为RDB文件只能保存某个时间间隔的数据，如果中途服务被意外终止了，则会丢失一段时间内的数据</li>
<li>save命令由主线程执行持久化，会阻塞主线程处理命令</li>
<li>bgsave命令的子进程是由主进程fork出来，而大内存会导致fork操作复制PCB阻塞</li>
</ul>
</li>
</ul>
</li>
<li><p>AOF日志</p>
<ul>
<li><p>AOF日志就是命令执行记录，类似于Mysql的binlog。但不同于Mysql的WAL写前日志模式，AOF是写后日志模式，即写命令先执行，再追加到AOF文件末尾。之所以如此，一是因为可以保证记录到AOF文件内的命令都是正确的，在数据恢复时不会出错。二是为了加快主线程执行命令的速度，在命令执行完成再将AOF写入缓冲区，等待合适的时机落到磁盘。AOF持久化有三个步骤：命令追加到内存缓冲区、将缓冲区命令同步到内存AOF文件末尾、将内存AOF文件同步到磁盘。</p>
</li>
<li><p>AOF有三种写回策略</p>
<ul>
<li>always：由主进程立即将aofBuf缓冲区内的所有数据写入内存AOF文件，并同步到磁盘AOF文件。</li>
<li>everysec：将aofBuf缓冲区内的所有数据写入内存AOF文件，如果上次文件同步距今时间已超过一秒，那么由子线程负责将内存AOF文件同步到磁盘AOF文件中。</li>
<li>no：将aofBuf缓冲区内的所有数据写入内存AOF文件，何时将内存AOF文件同步到磁盘AOF文件中，以及具体操作，均由操作系统决定并执行，Redis服务器什么也不做。</li>
</ul>
</li>
<li><p>AOF重写：随着服务器不断执行接收到的一条条写命令，AOF文件的内容会越来越多，还包含了大量的冗余指令。AOF重写的原理就是，通过特定指令读取数据库当前状态，以替换原有的AOF文件，达到最小化AOF文件的效果。为了不让AOF这类日志操作影响正常的命令处理，Redis将AOF重写功能交由子进程执行，这样做的好处是：</p>
<ul>
<li>子进程处理AOF重写期间，主进程还可以继续响应命令</li>
<li>由于fork会写时复制父进程的当前数据，所以避免了父子进程的数据访问冲突，即在不加锁的情况下保证了数据安全</li>
</ul>
<p>如果父进程在AOF期间修改了数据，那么对子进程是不可见的，即产生了数据的不一致性。解决方案是，在AOF重写时，会在主进程设置一个AOF重写缓冲区，专门记录子进程运行期间产生的不可见的数据更改。此时服务器会将命令写入AOF缓冲区和AOF重写缓冲区。当子进程处理完重写操作，生成好了新的AOF文件时，会发送一个信号给父进程，父进程在接收到这个信号后，会阻塞命令处理，并将AOF重写缓冲区内的命令追加到新AOF文件末尾，最后替代现有AOF文件，就完成了整个AOF 会重写操作。</p>
</li>
<li><p>AOF缓冲区和AOF重写缓冲区的区别：</p>
<ul>
<li>目的不同。AOF缓冲区的目的是伴随着命令的处理，不断地追加AOF文件的。AOF重写缓冲区的目的是解决子进程AOF重写期间造成的数据不一致。</li>
<li>使用方式不同。前文说过，AOF缓冲区会根据具体策略，选择不同时机写入磁盘。AOF重写缓冲区是在子进程处理完成后，一次性追加到新的AOF文件末尾的。</li>
<li>“内容不一致”。AOF缓冲区会根据策略选择不同时机写入磁盘，意味着有可能出现缓冲区内容不断变化。AOF重写缓冲区，他的职责是记录所有子进程处理期间的命令，不会发生上述情况。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>保证了数据可靠性</li>
<li>每次持久化的数据量不大</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无论何种写回策略，都有一定的命令丢失风险</li>
<li>always策略也会阻塞主进程</li>
<li>如果AOF重写不合理，那么会导致AOF文件过大，数据恢复速度慢</li>
<li>AOF重写子进程是由主进程fork出来，而大内存会导致fork操作复制PCB阻塞</li>
<li>由于父子进程写时复制的原因，在AOF重写期间，主进程处理bigkey需要重新申请内存空间，存在阻塞风险</li>
<li>完全使用AOF日志，一条一条命令地恢复数据，会比较慢</li>
</ul>
</li>
<li><p>Redis4.0提供了混合使用RDB和AOF的功能，即使用RDB快照做全量备份，使用AOF日志做增量备份</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-过期机制"><a href="#2-过期机制" class="headerlink" title="2.过期机制"></a>2.过期机制</h2><p>删除策略有以下三种：</p>
<ul>
<li>定时删除（Redis未采用）<ul>
<li>在设置键的过期时间的同时，同时设置一个定时器，到了指定时间时间时，定时器会立即执行对键的删除操作。</li>
</ul>
</li>
<li>惰性删除<ul>
<li>放任过期键不理会，但是每当服务器处理键的查询命令时，都会先判断该键是否已经过期。如果已经过期，则删除该键，返回空或报错；如果没有过期，则执行正常查询命令。</li>
<li>极端情况下，可能出现无用数据占用大量内存的情况。</li>
<li>最节省CPU，只有在过期键真正需要被删除的时候才会执行删除操作。</li>
</ul>
</li>
<li>定期删除<ul>
<li>每隔一段时间，就检查数据库，删除其中过期的数据。至于要隔多久检查、每次检查多少数据，都可以配置。</li>
<li>相对节省内存</li>
<li>可以通过控制执行周期间隔和每次执行的规模来决定对于内存和CPU的影响</li>
</ul>
</li>
</ul>
<p>RDB对于过期键的处理：</p>
<ul>
<li><p>生成RDB文件时，不会保存已经过期了的键到RDB文件</p>
</li>
<li><p>载入RDB文件时：</p>
<ul>
<li><p>对于主服务器，程序会对RDB文件中的键进行检查，已经过期的键不会载入到数据库中。</p>
</li>
<li><p>对于从服务器，RDB文件保存的所有数据，不论是否已经过期，都会载入到数据库中。旧版本从库对于过期数据直接返回，不会惰性删除。旧版本从库对于过期数据返回空值，也不会惰性删除</p>
</li>
</ul>
</li>
</ul>
<p>AOF对于过期键的处理：</p>
<ul>
<li><p>写入AOF文件时，如果某个键已经过期，但是它还没有被删除，那么依然会像处理未过期的键一样，将其写入到AOF文件中。随后当这个键被服务器删除时，会追加一条针对这个键的删除操作到AOF文件。之所以这样。是因为可以在不会影响AOF文件所表达出的数据库状态的情况下，保持AOF写入原则，忠实地记录写命令的执行情况。</p>
</li>
<li><p>AOF重写时，程序会对服务器的键进行检查，已经过期的键不会保存到重写后的AOF文件中。对于AOF重写，它所想要的效果是用最少的命令表达当前数据库的状态，很显然就不需要写入过期键到AOF重写文件内了。</p>
</li>
</ul>
<h2 id="3-内存淘汰策略"><a href="#3-内存淘汰策略" class="headerlink" title="3.内存淘汰策略"></a>3.内存淘汰策略</h2><p><strong>淘汰策略分类</strong>：</p>
<ul>
<li>不进行数据淘汰：一旦缓存被写满，再有写请求进来时，不再提供服务，直接返回错误</li>
<li>进行数据淘汰<ul>
<li>只对设置了过期时间的数据进行淘汰<ul>
<li>valatile-ttl：根据设置的过期时间，越早过期的数据先被删除</li>
<li>valatile-random：随机选择</li>
<li>valatile-lru</li>
<li>valatile-lfu</li>
</ul>
</li>
<li>对所有数据进行淘汰<ul>
<li>allkeys-random</li>
<li>allkeys-lru</li>
<li>allkeys-lfu</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>简单介绍LRU算法</strong>：</p>
<p>最近最少使用，即将内存中最近未被使用的数据删除。由于传统LRU算法需要维护链表，会带来额外的空间开销，所以Redis简化了LRU算法的实现。Redis会维护每个键的lru时间，即最近一次访问时间。第一次决定要淘汰数据时，会随机挑选出N个数据，利用他们的lru字段做lru算法，将lru最小的数据淘汰出去。当需要再次决定淘汰数据时，会挑选小于集合中最小lru的数据进入集合，然后再将lru最小的数据淘汰出去。</p>
<p><strong>简单介绍LFU算法</strong>：</p>
<p>由于LRU算法只考虑数据最近一次访问时间，当有大量数据作扫描式单词查询操作时，由于这些数据刚刚被访问过，所以他们的lru时间戳都很大，但是他们之后肯定不会被再次访问，就造成了缓存污染。为了应对此类问题，引入了LFU算法。</p>
<p>Redis实现的LFU基于LRU，利用键lru字段后8位记录访问次数，在淘汰数据时，先将访问次数小的淘汰出去，如果访问次数相同，再将最后一次访问时间早的淘汰出去。为了避免8位的访问次数很快被记满，一是采用非线性递增的方式增加访问次数，二是未被访问的数据，其访问次数会根据时间进行衰减。</p>
<p><strong>如何选择淘汰策略</strong>：</p>
<ol>
<li>根据是否有始终会被频繁访问（置顶数据）决定淘汰数据的数据集</li>
<li>优先建议使用lru</li>
<li>如果业务数据的访问频率区别不大，没有明显的冷热数据之分，建议选择random</li>
</ol>
<h2 id="4-内存碎片"><a href="#4-内存碎片" class="headerlink" title="4.内存碎片"></a>4.内存碎片</h2><p>内存碎片指的是操作系统内存中存在一些不连续的、大小不一的、无法被有效利用的空闲空间。</p>
<p>Redis形成内存碎片的原因有：</p>
<ul>
<li>内因：操作系统自身的内存管理策略</li>
<li>外因：Redis自身的负载特征<ul>
<li>键值对本身大小不一</li>
<li>键值对会被修改或删除</li>
</ul>
</li>
</ul>
<p>解决方案就是内存自动清理机制，可以根据内存碎片大小或比例自动开启清理，并设置清理占用的CPU比例自动停止清理，以避免长时间阻塞主进程</p>
<h2 id="5-缓冲区"><a href="#5-缓冲区" class="headerlink" title="5.缓冲区"></a>5.缓冲区</h2><p>Redis缓冲区类型：</p>
<ul>
<li>客户端与服务端<ul>
<li>输入缓冲区</li>
<li>输出缓冲区</li>
</ul>
</li>
<li>主从库<ul>
<li>复制缓冲区（等同于客户端的输出缓冲区）</li>
<li>复制积压缓冲区</li>
</ul>
</li>
<li>持久化<ul>
<li>AOF缓冲区</li>
<li>AOF重写缓冲区</li>
</ul>
</li>
</ul>
<p>缓冲区溢出原因及解决方案：</p>
<ul>
<li>命令发送过快过大<ul>
<li>普通客户端<ul>
<li>避免bigkey</li>
</ul>
</li>
<li>复制缓冲区<ul>
<li>避免主库过大，产生过大的RDB文件</li>
</ul>
</li>
</ul>
</li>
<li>命令处理过慢<ul>
<li>减少阻塞主进程的操作</li>
</ul>
</li>
<li>缓冲区空间过小<ul>
<li>配置合理缓冲区大小</li>
</ul>
</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="1-主从模型"><a href="#1-主从模型" class="headerlink" title="1.主从模型"></a>1.主从模型</h2><p>Redis通过读写分离的主从模式，增加了数据的冗余副本，保证了服务可靠性。一个主库会有多个从库。读命令主、从库都可以处理，写命令只能主库处理，处理完成后再将其同步给各个从库。</p>
<p>主从复制功能的实现，分为三个阶段：</p>
<ul>
<li><p>建立连接，协商同步</p>
</li>
<li><p>同步：用于将从库状态更新至主库当前状态</p>
<ul>
<li>全量同步<ul>
<li>过程：主库通过BGSAVE命令，使用子进程生成RDB文件，并在此过程中使用复制缓冲区记录从现在开始执行的所有写命令。之后将这个RDB文件传输给从库，从库接收到文件后，先清理自己的所有服务器状态，然后载入RDB文件，将自己的状态更新至主库的RDB文件状态。从库载入完RDB文件后，主库进入阻塞，将自己复制缓冲区内的所有写命令传输给从库，从库应用这些命令后，主从库的状态就完全一致了。</li>
<li>使用场景：从库初次复制主库、从库改变复制的主库</li>
</ul>
</li>
<li>增量同步<ul>
<li>过程：主库进行命令传播期间，不仅会将写命令发送给所有从库，还会将其保存在一个先进先出的环形的复制积压缓冲区内。从库断线重连主库后，会发送自己之前的复制偏移量给主库，主库判断该偏移量是否存在于复制积压缓冲区内，若存在，则将该偏移量之后的写命令同步给从库，否则进行全量同步</li>
<li>使用场景：主从库因为网络问题断线一段时间，恢复连接后，继续复制主库</li>
</ul>
</li>
</ul>
</li>
<li><p>命令传播</p>
<ul>
<li>目的：当主库状态被修改，导致主从库状态不一致时，让主从库的状态重新回到一致状态。</li>
<li>过程：主库接收到写命令后，不仅执行命令响应客户端，还会将命令发送给从库，从库应用这条命令使主从库状态恢复一致</li>
</ul>
</li>
</ul>
<h2 id="2-为什么采用读写分离的方式"><a href="#2-为什么采用读写分离的方式" class="headerlink" title="2.为什么采用读写分离的方式"></a>2.为什么采用读写分离的方式</h2><p>如果各从库都能处理写命令，那么由于数据同步的延迟性，会导致针对同一数据各库之间的状态不一致。如果非要保持多个库数据的一致性，要么放弃一部分数据，以某一个版本为准，要么在各实例间加锁，增加复杂性和性能开销。而只有主库负责写命令就没有这些问题。</p>
<h2 id="3-全量同步的缺点"><a href="#3-全量同步的缺点" class="headerlink" title="3.全量同步的缺点"></a>3.全量同步的缺点</h2><ol>
<li>BGSAVE的fork操作可能会阻塞主进程</li>
<li>BGSAVE会耗费大量CPU、内存、磁盘I/O</li>
<li>主库将RDB文件传输给从库，会耗费大量网络资源</li>
<li>从库接收并载入RDB文件期间无法处理请求</li>
</ol>
<p>解决方法：主-从-从模式，减少单一主库的复制压力，将其分散到多个从库上面去。</p>
<h2 id="4-如何避免增量复制退化为全量复制"><a href="#4-如何避免增量复制退化为全量复制" class="headerlink" title="4.如何避免增量复制退化为全量复制"></a>4.如何避免增量复制退化为全量复制</h2><ol>
<li>设置合理的复制积压缓冲区大小，其与主库的写命令速度、大小，主从库之间的网络传输速度有关</li>
<li>使用切片集群分担单一主库的写操作压力</li>
</ol>
<h2 id="5-复制时检测命令丢失"><a href="#5-复制时检测命令丢失" class="headerlink" title="5.复制时检测命令丢失"></a>5.复制时检测命令丢失</h2><p>主库根据从库返回的命令偏移量，判断是否有命令丢失，并将这些命令重新传播给从库。其过程与增量同步一致，但区别在于此时没有发生从库的断线重连。</p>
<h2 id="6-为什么不使用AOF文件进行复制"><a href="#6-为什么不使用AOF文件进行复制" class="headerlink" title="6.为什么不使用AOF文件进行复制"></a>6.为什么不使用AOF文件进行复制</h2><ol>
<li>RDB文件是经过压缩的二进制文件，而AOF文件是写命令的文本文件，所以RDB文件的恢复速度比AOF文件快<ol>
<li>传输效率</li>
<li>从库的解析加载效率</li>
</ol>
</li>
<li>假设使用AOF做全量同步，需要打开AOF功能，若策略不当会增加刷盘的可能性。而RDB文件只有在定时备份或全量同步时才会生成RDB文件。所以在对丢失数据不敏感的场景，不需要开启AOF功能，也就更不必为了数据复制开启了。</li>
</ol>
<h2 id="7-复制缓冲区和复制积压缓冲区的区别"><a href="#7-复制缓冲区和复制积压缓冲区的区别" class="headerlink" title="7.复制缓冲区和复制积压缓冲区的区别"></a>7.复制缓冲区和复制积压缓冲区的区别</h2><p>作用不同。</p>
<p>复制缓冲区replication buffer其实就是命令发送的写缓冲区，所有客户端发送命令时都会有这个缓冲区，只不过此时是专门用于命令传播的，所以起了这个名字。</p>
<p>复制积压缓冲区是为了解决命令丢失或做增量同步的。</p>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><h2 id="1-哨兵机制"><a href="#1-哨兵机制" class="headerlink" title="1.哨兵机制"></a>1.哨兵机制</h2><p>由于Redis采用主从库的读写分离模式，所以一旦主库挂掉，那么集群将无法对外提供写服务，并且从库也无法进行数据同步，这是无法接受的。因此有了哨兵机制，用于监控任意数量的主库，以及其下的所有从库，实现主从库自动切换机制。其功能有：</p>
<ol>
<li>监控：判断主库是否下线</li>
<li>选主：选择从库称为新主库</li>
<li>通知：把新主库通知给旧主库、其他从库和客户端</li>
</ol>
<h2 id="2-哨兵集群的组建方式"><a href="#2-哨兵集群的组建方式" class="headerlink" title="2.哨兵集群的组建方式"></a>2.哨兵集群的组建方式</h2><p>哨兵实例之间通过发布/订阅机制，可以自动互相发现，从而组成哨兵集群。具体说就是所有哨兵实例都会订阅主库的哨兵频道，就可以获得其他哨兵发布的消息。并且，哨兵在和主库建立连接后，就会在该频道上发布自己的位置信息，供其他哨兵实例知晓。</p>
<p>哨兵通过向主库发送INFO命令，获取从库列表，从而建立起和所有从库的连接。</p>
<p>哨兵本质上是一个特殊的Redis进程，也对外提供发布/订阅机制。所以，客户端可以通过哨兵配置文件，和哨兵实例建立连接，从而订阅相关频道，获取主从切换的关键事件通知。</p>
<h2 id="3-监控"><a href="#3-监控" class="headerlink" title="3.监控"></a>3.监控</h2><ol>
<li>主观下线：哨兵进程会通过PING命令来监控他自己和主、从库的网络连接情况，若PING命令超时，则将该实例标记为主观下线。如果是从库主观下线，直接标记就行。如果是主库主观下线，哨兵还不能进行选主，因为他自己和主库的网络问题不能说明主库在整个网络中的健康情况。</li>
<li>客观下线：某个哨兵实例判断主库主观下线后，会向其他哨兵实例发送命令，用于获取其他实例对主库的下线判断情况，当前哨兵统计其他实例的响应情况，判断下线数量是否大于等于阈值，若大于，则将主库标记为客观下线。阈值的一般原则是集群的大多数。</li>
</ol>
<h2 id="4-选举哨兵代理人"><a href="#4-选举哨兵代理人" class="headerlink" title="4.选举哨兵代理人"></a>4.选举哨兵代理人</h2><p>选举原则：</p>
<ul>
<li>当某个哨兵实例将主库标记为客观下线后，会向其他实例发送选举命令，请求为自己投票。若当前实例在本纪元没有为其他实例投过票，则会为自己投上一票</li>
<li>每轮新发起的投票，不论选举是否成功，都会将纪元+1</li>
<li>每个实例在每个纪元只能给一个实例投票</li>
<li>实例接收到投票响应后，会判断纪元是否一致，一致才会采用投票结果</li>
<li>获得半数以上赞成票，并且大于等于阈值的实例，称为哨兵首领，由他主持接下来的主从切换任务</li>
<li>若当前纪元没有实例成为首领，则每个实例都会等待随机时间后发起新一轮的选举</li>
</ul>
<h2 id="4-选主"><a href="#4-选主" class="headerlink" title="4.选主"></a>4.选主</h2><p>遍历首领哨兵实例的从库列表：</p>
<ol>
<li><p>筛选：把不符合条件的从库去掉</p>
<ol>
<li>正常在线：处于下线或断线状态的从库</li>
<li>通信状态良好：最近5秒内没有回复过首领哨兵INFO命令的从库</li>
<li>数据较新：与已下线主库连接断开超过 判断主观下线时间*10 的从库</li>
</ol>
</li>
<li><p>打分：选择得分最高的从库作为新主库</p>
<ol>
<li>配置的优先级最高</li>
<li>复制偏移量最大</li>
<li>id最小</li>
</ol>
</li>
</ol>
<h2 id="5-通知"><a href="#5-通知" class="headerlink" title="5.通知"></a>5.通知</h2><ul>
<li>向新主库发SLAVEOF命令，修改其为主库</li>
<li>向已下线主库的所有从库发送SLAVEOF命令，修改其主库为新选择的主库</li>
<li>监控旧主库，当旧主库重新上线时，向其发送SLAVEOF命令，成为新主库的从库</li>
</ul>
<h2 id="6-主从切换过程中，集群可以提供服务吗"><a href="#6-主从切换过程中，集群可以提供服务吗" class="headerlink" title="6.主从切换过程中，集群可以提供服务吗"></a>6.主从切换过程中，集群可以提供服务吗</h2><p>从切换过程中，集群能正常处理读请求，但是不能处理写请求。对于写延迟不敏感的业务，为了不让业务感受到异常，可以在客户端或者中间件缓存写请求，等新库上线后再将写请求发送过去。</p>
<h2 id="7-客户端应该如何获取主库地址"><a href="#7-客户端应该如何获取主库地址" class="headerlink" title="7.客户端应该如何获取主库地址"></a>7.客户端应该如何获取主库地址</h2><ol>
<li>不要写死主库地址</li>
<li>推：通过订阅哨兵的频道，被动等待通知</li>
<li>拉：主动从哨兵处获取当前主库的地址</li>
</ol>
<h2 id="8-哨兵实例是不是越多越好"><a href="#8-哨兵实例是不是越多越好" class="headerlink" title="8.哨兵实例是不是越多越好"></a>8.哨兵实例是不是越多越好</h2><p>不是。哨兵实例越多，误判率越低。但是哨兵在判断客观下线和选举时，都需要与其他哨兵通信并协商，若哨兵实例越多，则这些过程所需通信越多，达成一致的时间可能越久。从而主从切换的时间会变长，客户端容易请求缓冲溢出，造成请求丢失。另外，若客户端对命令响应时间有要求，会造成超时报错。</p>
<h1 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h1><h2 id="为什么要使用分片集群"><a href="#为什么要使用分片集群" class="headerlink" title="为什么要使用分片集群"></a>为什么要使用分片集群</h2><p>为了应对大数据存储导致的性能问题，可以采用两种拓展方法：</p>
<ul>
<li>纵向拓展：升级单实例配置<ul>
<li>优点<ul>
<li>简单直接</li>
</ul>
</li>
<li>缺点<ul>
<li>单实例内存过大时，数据持久化过程中的fork操作会阻塞较长时间</li>
<li>受到硬件和成本限制</li>
</ul>
</li>
</ul>
</li>
<li>横向拓展<ul>
<li>优点<ul>
<li>拓展性好</li>
<li>成本低</li>
</ul>
</li>
<li>缺点<ul>
<li>集群管理复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h2><p>Redis Cluster定义了16384个哈希槽，并将集群的每一个数据映射到其中的某一个槽上，即持有该槽的实例保存该槽对应的所有数据。</p>
<p>在创建集群时，可以根据各实例的实际资源情况，通过ADDSLOTS命令，分配一个或多个槽给某个实例。</p>
<h2 id="处理客户端请求"><a href="#处理客户端请求" class="headerlink" title="处理客户端请求"></a>处理客户端请求</h2><ul>
<li>集群建立时，每个实例只知道自己负责的槽信息。但是，集群实例之间会建立连接，互相同步信息，最终所有实例都知道自己和其他实例负责的槽信息</li>
<li>客户端与集群建立连接后，集群实例会将所有槽的分配信息发送给客户端，客户端缓存</li>
<li>根据键值对，可以直接计算出其对应的槽下标，然后根据客户端缓存的槽分配信息，发送命令到对应实例</li>
<li>若槽就是当前实例负责，则直接处理请求</li>
<li>若槽已经被重新分配到其他实例，由于集群实例之间会同步到最新的槽分配信息，所以当前实例知道该槽现在位于哪个实例，于是向客户端返回重定向错误命令MOVED，指示客户端向新实例请求对应数据，并且客户端会更新自己的槽分配信息缓存，下次该槽直接请求新实例</li>
<li>若槽数据正在被迁移到新实例，有两种情况：<ul>
<li>客户端请求的数据还在当前实例，则当前实例直接处理命令</li>
<li>客户端请求的数据已经被迁移到新实例，向客户端返回临时重定向错误命令ASK，指示客户端向新实例请求对应数据。客户端会先向新实例发送ASKING命令，代表新实例将允许客户端发送的下一条命令（其他情况将不允许），然后客户端再将请求发送到新实例，由新实例处理并返回响应。与MOVED命令不用，此时客户端不会更新自己的槽分配信息缓存，下次该槽依然当前实例</li>
</ul>
</li>
</ul>
<h2 id="为什么是16384个槽"><a href="#为什么是16384个槽" class="headerlink" title="为什么是16384个槽"></a>为什么是16384个槽</h2><p>Redis Cluster采用CRC16算法转换字符串键为16位整数，即包含2^16=65535个整数，Redis作者给出的原因是：</p>
<ol>
<li>16384个槽分配信息大约2kb，而65535个槽分配信息大约有8kb。由于每秒实例与实例之间、实例与客户端之间要交换槽分配信息，所以8kb太大了，会占用大量网络资源，而2kb可以接受</li>
<li>集群主库的数量不可能超过1000个，所以没必要有那么槽</li>
<li>实例是通过bitmap保存所有实例的槽分配情况的，bitmap在传输过程中会压缩，N个节点的bitmap填充率为 slots/N，当slots很大时，压缩率就会降低</li>
</ol>
<p>综上所述，最终作者决定决定使用16384个槽</p>
<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>由Redis集群管理软件redis-trib负责执行重新分片，迁移单个槽的过程如下：</p>
<ol>
<li>让目标实例准备好从源实例导入属于槽的数据</li>
<li>让源实例准备好向目标实例导出属于槽的数据</li>
<li>获得指定数量个属于槽的数据键</li>
<li>对于步骤3中获取到的每个数据键，依次将每个键值对从源实例发送至目标实例</li>
<li>重复步骤3、4，直至所有属于槽的数据都被迁移完</li>
<li>向集群中任一实例发送消息，告知槽已经由目标实例维护，最终这一信息会被集群中所有实例获知</li>
</ol>
<h2 id="为什么采用哈希槽而不是直接记录数据与实例的关系"><a href="#为什么采用哈希槽而不是直接记录数据与实例的关系" class="headerlink" title="为什么采用哈希槽而不是直接记录数据与实例的关系"></a>为什么采用哈希槽而不是直接记录数据与实例的关系</h2><p>直接记录数据与实例的关系，意味着必须维护一张关系表：</p>
<ol>
<li>一旦对应关系发生变化，就要修改表。如果是单线程执行，则性能慢。如果是多线程，就涉及并发控制，增加系统复杂度，而Redis本身是单线程的，没有设计这些功能。</li>
<li>当数据量非常大时，映射表会非常庞大，无论是客户端还是集群实例，都会被占用很大一块内存空间。而采用哈希槽，相当于在数据与实例之间增加了中间层，只需要维护固定数量的映射关系即可，并且使用特定算法实现数据与槽的映射关系，相当于用时间换空间</li>
<li>由于Redis Cluster采用无中心化的架构，所以每个实例、客户端都需要维护槽与实例的映射关系，并且相互之间需要同步最新信息，那么要是采用数据与实例的映射表，必然占用大量网络资源</li>
<li>当集群在扩容、缩容、数据均衡时，都会进行数据迁移。以槽为单位进行迁移，会降低这个过程的复杂度，易于维护管理</li>
</ol>
<h2 id="分片集群高可用"><a href="#分片集群高可用" class="headerlink" title="分片集群高可用"></a>分片集群高可用</h2><p>分片集群的每个实例都可以设置主从复制模式，即设置多个从库。这些从库会复制主库的数据，以及槽分配信息。实例与其从库的关系，最终也会被集群中的所有实例知道并记录。</p>
<ol>
<li>监控<ol>
<li>疑似下线：集群中的各实例之间会向彼此发送PING命令进行在线检测，若超时未回复，则会被当前实例标记为疑似下线状态</li>
<li>已下线：集群实例之间会彼此同步信息，这里面就包含了对其他实例的下线状态判断信息，收到同步信息的实例会将其保存下来。若某实例A发现，超过半数的实例都对实例B判断为疑似下线，那么实例A就会将实例B标记为已下线状态，并且会广播整个集群，所有收到这条广播消息的实例也会将实例B标记为已下线状态</li>
</ol>
</li>
<li>选举<ol>
<li>当某个从库收到他自己主库的已下线广播消息时，会向其他主库发送选举命令，请求为自己投票</li>
<li>每轮新发起的投票，不论选举是否成功，都会将纪元+1</li>
<li>每个有投票权的主库（负责处理槽）在每个纪元只能给一个从库投票</li>
<li>从库接收到投票响应后，会判断纪元是否一致，一致才会采用投票结果</li>
<li>获得半数以上（有投票权的主库）赞成票的从库，成为新主库</li>
<li>若当前纪元没有从库成为新主库，则每个参与选举的从库都会等待随机时间后发起新一轮的选举</li>
</ol>
</li>
<li>故障转移<ol>
<li>被选举中的从库，执行SLAVEOF no one命令，成为新主库</li>
<li>新主库会下线所有对老主库的槽分配信息，转而分配给自己</li>
<li>向集群广播消息，通知自己接替了老主库负责的所有槽，成为新主库</li>
<li>开始接收读写命令，故障转移完成</li>
</ol>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/">
                        <span class="hidden-mobile">基数统计算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"64e7a0af76ea907275e7","clientSecret":"58fc6a6232d3179936704144df3ddeef170c2fdd","repo":"bolg-comment","owner":"Xzzz583722585","admin":["Xzzz583722585"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '860a96f557c5779b8860281b758cf5a9'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
