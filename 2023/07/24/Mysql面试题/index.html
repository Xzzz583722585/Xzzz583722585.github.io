

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Jon Xzzz">
  <meta name="keywords" content="">
  
  <title>Mysql面试题 - Jon Xzzz</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.jonxzzz.xyz","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"SAmnq0afTzl9DvACTmD2ys0H-gzGzoHsz","app_key":"yxbky5wsCPQcibrgyi8HmBtm","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Jon Xzzz</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Mysql面试题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-07-24 21:50" pubdate>
        2023年7月24日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        浏览 <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Mysql面试题</h1>
            
            <div class="markdown-body">
              <h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/architecture.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/process.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><ol>
<li><p>客户端</p>
<ol>
<li>数据库连接池：维护一定的连接数，方便系统获取连接，节省了不断创建与销毁连接的开销</li>
</ol>
</li>
<li><p>连接器</p>
<ol>
<li>建立连接、维持和管理连接<ol>
<li>连接类型：<ol>
<li>长连接：节省创建连接的消耗，但是服务器资源会被长时间占用，有可能导致OOM<ol>
<li>定期断开长连接</li>
<li>重新初始化连接资源</li>
</ol>
</li>
<li>短连接：频繁创建连接的消耗巨大</li>
</ol>
</li>
<li>I/O多路复模型</li>
<li>使用线程池为每个客户端连接分配一个线程，客户端的任何请求都由该线程完成</li>
</ol>
</li>
<li>身份认证</li>
</ol>
</li>
<li><p>客户端发送请求到服务器</p>
</li>
<li><p>缓存</p>
<ol>
<li>缺点<ol>
<li>要求sql完全一致才能使用到缓存</li>
<li>相关数据一旦被更新，缓存也会失效</li>
</ol>
</li>
<li>Mysql8.0后被删除</li>
</ol>
</li>
<li><p>解析器</p>
<ol>
<li>词法解析</li>
<li>语法解析</li>
</ol>
</li>
<li><p>优化器</p>
<ol>
<li>权限认证</li>
<li>生成执行计划<ol>
<li>基于成本估算选择最优执行计划<ol>
<li>I/O成本</li>
<li>CPU成本</li>
</ol>
</li>
<li>索引选择</li>
<li>关联选择</li>
</ol>
</li>
</ol>
</li>
<li><p>执行器</p>
<ol>
<li>根据执行计划调用存储引擎API完成SQL执行<ol>
<li>对于没有索引的表：依次查询每行数据</li>
<li>对于有索引的表：依次查询每行满足条件的数据</li>
</ol>
</li>
</ol>
</li>
<li><p>存储引擎：负责数据的存储和读取</p>
<ol>
<li><p>Innodb</p>
<ul>
<li><p>加载到缓冲池：MySQL 的数据最终是存储在磁盘中的，如果没有缓冲池，那么我们每次的数据库请求都会磁盘中查找，这样必然会存在磁盘I/O，肯定是无法接受的。缓冲池的作用就是我们第一次在查询的这块数据时候会将查询的结果存到缓冲池中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到缓冲池中</p>
</li>
<li><p>记录undo log：数据被加载到缓冲池后，会记录初始的undo log，内容是初始记录值。undo log的作用，就是查找数据的历史版本，以及事务失败时回滚。详情可以看之后的MVCC</p>
</li>
<li><p>在内存缓冲池中执行更新操作</p>
</li>
<li><p>更新后的数据记录到redo log buffer：数据的物理修改记录</p>
</li>
<li><p>redo log buffer刷盘，此时redolog处于prepare状态：若redo log刷盘成功，则此时Mysql奔溃，依然可以根据redo log恢复数据到缓冲池，即redo log具有crash-safe能了</p>
<ul>
<li>redolog 刷盘策略：<ul>
<li>不刷入磁盘</li>
<li>立即刷入磁盘</li>
<li>先刷到os cache</li>
</ul>
</li>
</ul>
</li>
<li><p>将binlog写入磁盘</p>
<ul>
<li><p>binlog刷盘策略：</p>
<ul>
<li>立即刷入磁盘</li>
<li>先刷到os cache</li>
</ul>
</li>
<li><p>binlog刷盘模式</p>
<ul>
<li>STATMENT：基于 SQL 语句的复制</li>
</ul>
</li>
</ul>
</li>
<li><p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p>
<ul>
<li>【缺点】：在某些情况下会导致主从数据不一致。比如带有limit的查询，可能由于使用到的索引不同，导致查询结果不一致。或者执行now()等</li>
</ul>
</li>
</ul>
<p>​    </p>
</li>
</ol>
<ul>
<li><p>ROW：基于数据行的复制</p>
<pre><code> - 【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题
</code></pre>
<ul>
<li><p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p>
<ul>
<li>MIXED：基于 STATMENT 和 ROW 两种模式的混合复制，一般的复制使用 STATEMENT 模式，对于 STATEMENT 模式无法复制的操作使用 ROW 模式</li>
</ul>
</li>
<li><p>【注意】：now()函数，mixed仍然会记录为SQL语句，即statement格式，因为它会在这句SQL前修改系统时间戳。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中</li>
<li>最后在redo log中写入 commit 标记，这样就表示本次事务被成功提交了。</li>
<li>另外，缓冲池中的数据，会有有后台线程在合适的时机，利用undolog将最终数据进行刷盘</li>
</ul>
</li>
<li><p>服务器返回数据给客户端</p>
<ol>
<li>将结果集返回给客户端是一个增量、逐步返回的过程。一旦服务器开始生成第一条结果时，服务器就可以开始向客户端返回结果集了</li>
<li>服务器需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以客户端缓存结果集通常可以减少服务器压力，让查询早点结束，早点释放相应资源</li>
<li>如果要返回一个很大的结果集，客户端需要花更多的时间和内存来存储所有的结果集。所以如果能够尽早开始处理这些结果集，就能大大减少内存的消耗。但这样做的缺点是，对于服务器而言，需要查询完成后才能释放资源</li>
</ol>
</li>
</ol>
<h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>写前日志，即更新操作，先写redolog到磁盘，并更新内存缓冲池的数据行。后续会有有后台线程在合适的时机进行刷盘。</p>
<h2 id="redolog与binlog的区别"><a href="#redolog与binlog的区别" class="headerlink" title="redolog与binlog的区别"></a>redolog与binlog的区别</h2><table>
<thead>
<tr>
<th>性质</th>
<th>redo Log</th>
<th>bin Log</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>物理性质记录</td>
<td>逻辑性质记录</td>
</tr>
<tr>
<td>文件大小</td>
<td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td>
<td>bin log 可通过配置参数max_bin log_size设置每个bin log文件的大小（但是一般不建议修改）。</td>
</tr>
<tr>
<td>实现方式</td>
<td>redo log是InnoDB引擎层实现的（也就是说是 Innodb 存储引擎独有的）</td>
<td>bin log是 MySQL 层实现的，所有引擎都可以使用 bin log日志</td>
</tr>
<tr>
<td>记录方式</td>
<td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。写满时会进行数据行刷磁盘。</td>
<td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td>
</tr>
<tr>
<td>使用场景</td>
<td>redo log适用于崩溃恢复(crash-safe)</td>
<td>bin log 适用于主从复制和数据恢复</td>
</tr>
</tbody></table>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul>
<li>Innodb<ul>
<li>支持事务</li>
<li>二级索引叶子节点保存的是主键值</li>
<li>支持表级锁、行级锁</li>
</ul>
</li>
<li>MyISAM<ul>
<li>不支持事务</li>
<li>没有一二级索引的区别，B+树叶子节点保存的都是数据行指针</li>
<li>只支持表级锁</li>
<li>有压缩表技术</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>整型<ul>
<li>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，INT占32位</li>
<li>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的</li>
</ul>
</li>
<li>浮点型<ul>
<li>FLOAT、DOUBLE</li>
<li>DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分</li>
</ul>
</li>
<li>字符串<ul>
<li>CHAR：定长</li>
<li>VARCHAR：变长，只存储必要的内容</li>
</ul>
</li>
<li>时间<ul>
<li>DATETIME</li>
<li>TIMESTAMP：比 DATETIME 空间效率更高</li>
</ul>
</li>
</ul>
<h2 id="选择数据类型"><a href="#选择数据类型" class="headerlink" title="选择数据类型"></a>选择数据类型</h2><ul>
<li>更小：占用更少的磁盘、内存和CPU</li>
<li>简单</li>
<li>尽量避免NULL：对MySQL来说更难优化，使得索引、索引统计和值比较都更复杂</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>存储引擎用于快速找到记录的一种数据结构。Mysql索引是在存储引擎层，而不是服务层实现的。使用索引的优点是：</p>
<ul>
<li>减少了服务器需要扫描的数据量</li>
<li>帮助服务器避免排序和临时表<ul>
<li>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQl才能用索引来对结果排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一张表时，才能用索引做排序。ORDER BY子句也需要满足索引的最左前缀匹配</li>
</ul>
</li>
<li>可以将随机I/O变成顺序I/O</li>
<li>减少加锁行数<ul>
<li>InnoDB只有在访问行的时候才会对其加锁，而索引能减少nnoDB访问的行数，从而减少锁的数量</li>
</ul>
</li>
</ul>
<h2 id="索引选择性"><a href="#索引选择性" class="headerlink" title="索引选择性"></a>索引选择性</h2><p>索引选择性指的是不重复的索引值和数据表的记录总数的比值。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul>
<li>一级索引（主键索引）<ul>
<li>属于聚簇索引：索引的每个叶子结点都包含了主键值与数据页<ul>
<li>优点<ul>
<li>数据访问更快</li>
<li>把相关数据保存在一起，利用空间局部性原理，减少磁盘I/O</li>
<li>有利于I/O密集型应用</li>
</ul>
</li>
<li>缺点<ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据到InnoDB表中最快的方式</li>
<li>更新聚簇索引代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>对于计算密集型应用，数据都存放在内存中，聚簇索引优势不再</li>
</ul>
</li>
</ul>
</li>
<li>类型<ul>
<li>B+树索引</li>
</ul>
</li>
</ul>
</li>
<li>二级索引<ul>
<li>二级索引叶子结点保存的不是数据页，而是主键值。通过二级索引查找行，存储引擎需要找到二级索引的叶子结点获得对应的主键值，再根据这个值去一级索引中查找对应的数据行</li>
<li>类型<ul>
<li>B+树索引</li>
<li>哈希索引：存储引擎会对所有的索引列计算一个哈希码，只有精确匹配索引所有列的查询才生效<ul>
<li>优点<ul>
<li>索引自身只需存储对应的哈希码，结构紧凑，速度快</li>
</ul>
</li>
<li>缺点<ul>
<li>不支持范围查找</li>
<li>不支持排序</li>
<li>不支持部分索引列匹配查找</li>
<li>不支持覆盖索引，只包含哈希值和主键，不存储字段值</li>
</ul>
</li>
<li>自适应哈希<ul>
<li>如果某些索引值被使用的非常频繁，InnoDB会在内存中自动基于B-Tree索引之上再创建一个哈希索引</li>
</ul>
</li>
</ul>
</li>
<li>空间索引</li>
<li>全文索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值"><a href="#为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值" class="headerlink" title="为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值"></a>为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值</h2><p>虽然使用主键值当做指针会让二级索引占用更多空间，但好处是，InnoDB在移动行时无需更新二级索引的这个指针。</p>
<h2 id="B-树索引的最左匹配原则"><a href="#B-树索引的最左匹配原则" class="headerlink" title="B+树索引的最左匹配原则"></a>B+树索引的最左匹配原则</h2><ul>
<li>按从左往右的顺序依次匹配</li>
<li>可以匹配列值得开头部分、范围值</li>
<li>匹配完范围值后，后续右边所有索引列无法再匹配。如果列的范围值数量有限，可以通过使用多个等于条件代替范围值</li>
</ul>
<h2 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h2><p>MySQL5.0之前，一个表一次查询只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描，然后将结果进行合并处理，然后再进行回表查询。</p>
<p>类型：</p>
<ul>
<li>intersect</li>
<li>union</li>
<li>sort-union：不能使用union的 OR 条件会使用sort-union</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>B+树按照做做匹配原则查询索引，在旧版本的Mysql中，对于剩余不符合最左匹配的索引列，会在回表找到数据后再比较。而新版本的Mysql，可以先在索引的剩余列上比较，筛选完成后再回表找到数据后继续比较，减少回表查询的数据行数，这就是索引下推。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol>
<li>原子性（Atomicity）<ul>
<li>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</li>
<li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</li>
</ul>
</li>
<li>一致性（Consistency）<ul>
<li>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的</li>
</ul>
</li>
<li> 隔离性（Isolation）</li>
</ol>
<ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的</li>
</ul>
<ol start="4">
<li>持久性（Durability）<ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失</li>
</ul>
</li>
</ol>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/acid.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<ul>
<li><p>修改丢失</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/update-lose.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>脏读</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/dirty-read.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>不可重复读</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/cannot-repeat-read.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>幻读</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/phantom-read.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁粒度：任何时候，在给定的资源上，锁定的数据量越少，则系统的并发成都越高，但是锁管理消耗资源的资源也越多。所谓锁策略，就是在锁的开销和数据安全性之间寻求平衡</p>
<ul>
<li><p>全局锁</p>
<ul>
<li>加锁时机和方式<ul>
<li>对于Innodb，使用一致性视图做全局备份。对于其他不支持一致性视图的存储引擎，只能使用全局锁，然后做全局备份</li>
</ul>
</li>
<li>主动加锁语法：Flush tables with read lock</li>
<li>类型：<ul>
<li>读锁：使整个数据库处于只读状态</li>
</ul>
</li>
</ul>
</li>
<li><p>表级锁</p>
<ul>
<li>表锁<ul>
<li>加锁时机和方式<ul>
<li>存储引擎不支持行锁或其他锁，只会加表锁</li>
<li>没有使用到索引，而是全表扫描，会加表锁</li>
</ul>
</li>
<li>主动加锁语法：lock tables … read/write</li>
<li>类型：<ul>
<li>读锁</li>
<li>写锁</li>
</ul>
</li>
</ul>
</li>
<li>意向锁：<ul>
<li>加锁时机和方式<ul>
<li>加行锁时，会加所在表的意向锁</li>
</ul>
</li>
<li>类型<ul>
<li>意向读锁</li>
<li>意向写锁</li>
</ul>
</li>
</ul>
</li>
<li>元数据锁MDL<ul>
<li>加锁时机和方式<ul>
<li>表更改SQL访问表时自动加MDL锁，事务结束时自动解锁</li>
</ul>
</li>
<li>类型：<ul>
<li>读锁：对表做增删改查操作时</li>
<li>写锁：对表做结构变更时</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>行级锁</p>
<ul>
<li>加锁时机和方式<ul>
<li>未提交读<ul>
<li>隐式<ul>
<li>只加RL写锁，不加RL读锁，不加GL</li>
</ul>
</li>
<li>显式<ul>
<li>只加RL</li>
</ul>
</li>
</ul>
</li>
<li>提交读<ul>
<li>隐式<ul>
<li>只加RL写锁，不加RL读锁，不加GL</li>
</ul>
</li>
<li>显式<ul>
<li>一般情况下加锁原理等于“可重复读”，只是去掉了GL</li>
<li>外键场景依然有GL，但是实际使用中没有设置外键，所以暂不讨论</li>
<li>优化：语句执行过程加的RL，会在语句执行完成后把不满足条件的RL释放掉</li>
</ul>
</li>
</ul>
</li>
<li>可重复读<ul>
<li>隐式<ul>
<li>只加RKL写锁</li>
</ul>
</li>
<li>显式<ul>
<li>加锁的基本单位是NKL，是一个前开后闭的区间。例如数据是1，5，10，访问到10，会加NKL (5,10]</li>
<li>查找过程中访问到的索引及对象才会加锁<ul>
<li>意味着覆盖索引不会在主键索引上加锁</li>
</ul>
</li>
<li>索引上的等值查询，给唯一索引加锁的时候，会退化为RL<ul>
<li>范围查询的左边界包含=号，也算等值查询</li>
</ul>
</li>
<li>索引上的等值查询，向右遍历到最后一个值不满足条件的对象时，会退化为GL</li>
<li>特例：唯一索引上的范围查询，不论是否指定右边界，都会加锁到第一个不满足条件的对象</li>
<li>其他需要注意的点<ul>
<li>update、delete、select的加锁逻辑一致</li>
<li>包含limit的语句，在扫描过程中一旦满足了，limit条件，就立即返回，不会再向后查询，即不会继续加锁</li>
<li>虽然加NKL就等于加RL和GL，但需要注意，本质上还是两个锁，会先加GL，再加RL</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可串行化<ul>
<li>系统自动加RKL</li>
</ul>
</li>
</ul>
</li>
<li>主动加锁语法<ul>
<li>select … lock in share mode</li>
<li>select … for update</li>
</ul>
</li>
<li>类型：<ul>
<li>读锁</li>
<li>写锁</li>
</ul>
</li>
</ul>
</li>
<li><p>Next-key lock = Record Lock + Gap Lock</p>
<ul>
<li><p>可重复读模式查询默认是不加锁的，要使用RKL，需要主动加锁</p>
</li>
<li><p>Record Lock：锁定一个记录上的索引，而不是记录本身</p>
</li>
<li><p>间隙锁 Gap Lock：锁定索引之间的间隙，但是不包含索引本身</p>
<ul>
<li>间隙锁的作用是防止幻读，所以间隙锁与间隙锁之间不会互斥，间隙锁阻止的是往间隙内新插入数据</li>
</ul>
</li>
<li><p>在不考虑退化的场景下，加NKL就等于加RL和GL，但需要注意，本质上还是两个锁，会先加GL，再加RL</p>
</li>
</ul>
</li>
</ul>
<h2 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h2><p>Mysql的事务遵循两段锁加锁协议，它是保证可串行化调度的充分条件。可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>对于一个事务而言，会在事务开始后的任何需要加锁的位置加锁，但都会等到提交或回滚事务前的统一时刻，一起释放锁。</p>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>死锁指的是并发环境下，多个线程循环依赖彼此占有的资源，导致每个线程所需的资源都永远没法被满足，从而无限期等待下去的现象。</p>
<p>对于Mysql而言，解决死锁的方法有：</p>
<ul>
<li>设置锁超时时间<ul>
<li>默认时间50s。等待时间太长业务无法接受。等待时间太多会发生很多误伤。</li>
</ul>
</li>
<li>发起死锁监测，发现死锁后，主动回滚死锁循环中的某一个事务<ul>
<li>极端情况下，所有事务都针对某一行加锁，那么死锁检测总花费是O(n^2)行，会消耗大量CPU资源。<ul>
<li>限制并发度<ul>
<li>修改Mysql源码，针对同一行的加锁需要排队</li>
<li>业务上限制针对同一个key的访问并发度</li>
</ul>
</li>
<li>将业务的一行数据改为逻辑上的多行数据，从而分担压力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ol>
<li>未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。<ol>
<li>解决问题：无</li>
<li>实现方式：不会隐式加读锁，会加写锁，直接返回最新值</li>
</ol>
</li>
<li>提交读（READ COMMITTED）：一个事务提交后，他所做的变更才会被其他事务看到<ol>
<li>解决问题：修改丢失、脏读</li>
<li>实现方式：隐式写锁+MVCC</li>
</ol>
</li>
<li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。<ol>
<li>解决问题：修改丢失、脏读、不可重复读</li>
<li>实现方式：隐式写锁+MVCC+RKL（主动加锁）</li>
</ol>
</li>
<li>可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。<ol>
<li>解决问题：修改丢失、脏读、不可重复读、幻读</li>
<li>实现方式：隐式读写锁</li>
</ol>
</li>
</ol>
<p>上述隔离级别都不影响显式加锁。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC作用于提交读和可重复读两个级别。</p>
<p>所谓MVCC，就是多版本并发控制。Mysql会维护一个全局版本号，每开启一个新事务都会将当前全局版本号赋值给这个事务，作为事务版本号，并且全局版本号递增。所谓多版本，就是每条记录更新时，都会记录一条undo log。我们可以通过记录最新值与undo log将记录回滚至任意版本。当没有任何事务需要这条undo log时，他就会被删除。在读取数据时，就会从当前版本开始往前依次查找最新一个可见版本并读取它。称之为一致性读视图。</p>
<p>读取数据时，根据读视图read view判断数据版本可见性：</p>
<ul>
<li>事务开启时，将当前正在活跃（已开启但还未提交）的版本记录下来，称为read view</li>
<li>获取read view中最小事务id和最大事务id</li>
<li>判断一个版本是否可见：<ul>
<li>若当前版本小于read view最小事务id，说明这个版本是所有未提交版本开始前就已经提交的，可以看见</li>
<li>若当前版本打于read view最大事务id，说明这个版本是所有未提交版本开始后就已经提交的，不可以看见</li>
<li>若当前版本大于等于read view最小事务id 并且 小于等于read view最大事务id：<ul>
<li>提交读：当前版本在read view中就不可见（因为还没提交），不在就可见</li>
<li>可重复读：不可见</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结，在生成read view时确定可见性：</p>
<ul>
<li>版本未提交，不可见</li>
<li>版本已提交，但是在read view创建后提交，不可见</li>
<li>版本已提交，但是在read view创建前提交，可见</li>
</ul>
<p>另外，读写操作的情况也不一样：</p>
<ul>
<li>读操作：快照读<ul>
<li>提交读：视图在每个SQL执行时创建</li>
<li>可重复读：视图在事务启动时创建</li>
</ul>
</li>
<li>显式加锁的读操作、写操作：当前读<ul>
<li>总是读取已提交的最新版本</li>
</ul>
</li>
</ul>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>MVCC不能解决幻读问题：快照读不会产生幻读，但当前读会产生幻读</p>
<p>解决方案：</p>
<ul>
<li>提升隔离级别为可串行化</li>
<li>当前读 + RKL（主动加锁）</li>
</ul>
<h2 id="Autocommit"><a href="#Autocommit" class="headerlink" title="Autocommit"></a>Autocommit</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<p>如果关闭自动提交，那么隐式地开启事务，并不会自动提交，可能会造成长事务。</p>
<h2 id="如何提高事务并发度"><a href="#如何提高事务并发度" class="headerlink" title="如何提高事务并发度"></a>如何提高事务并发度</h2><ol>
<li>减小锁范围<ol>
<li>行锁 &lt; 表锁 &lt; 全局锁</li>
<li>MVCC相当于数据行版本锁</li>
<li>读写分离锁</li>
</ol>
</li>
<li>减少锁数量<ol>
<li>减少扫描的数据行数</li>
<li>修改隔离级别，RKL -&gt; RL</li>
<li>只在必要时加锁：快照读与当前读</li>
</ol>
</li>
</ol>
<h2 id="为什么不要使用长事务"><a href="#为什么不要使用长事务" class="headerlink" title="为什么不要使用长事务"></a>为什么不要使用长事务</h2><ol>
<li> 长时间占有锁</li>
<li>长时间占有连接和线程</li>
<li>长事务意味着服务器会存储很老的事务视图，他可能用到的回滚记录undolog都必须保留，不利于undolog释放，占用大量内存空间</li>
<li>同步到从库以后，从库也要执行很长时间，主从不一致时间变长</li>
</ol>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="1-通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL"><a href="#1-通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL" class="headerlink" title="1.通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL"></a>1.通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL</h2><h2 id="2-使用Explain分析SQL"><a href="#2-使用Explain分析SQL" class="headerlink" title="2.使用Explain分析SQL"></a>2.使用Explain分析SQL</h2><p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h2 id="3-通用优化"><a href="#3-通用优化" class="headerlink" title="3.通用优化"></a>3.通用优化</h2><ol>
<li>避免长事务</li>
</ol>
<h2 id="4-优化数据访问量"><a href="#4-优化数据访问量" class="headerlink" title="4.优化数据访问量"></a>4.优化数据访问量</h2><ol>
<li>返回的数据过多<ol>
<li>返回必要的行：limit</li>
<li>返回必要的列：不要使用select *</li>
<li>拆分大查询</li>
</ol>
</li>
<li>检索的数据过多<ol>
<li>首先考虑在存储引擎层，使用索引过滤数据</li>
<li>然后考虑在服务层，使用覆盖索引返回记录，无需回表查询</li>
<li>最后才是在服务层，从数据表中过滤数据</li>
</ol>
</li>
</ol>
<h2 id="5-索引优化"><a href="#5-索引优化" class="headerlink" title="5.索引优化"></a>5.索引优化</h2><ol>
<li>主键索引设置<ol>
<li>推荐像雪花算法这样的自增ID生成器，这样局部性原理失效可以保证数据行按顺序写入，将随机I/O变为顺序I/O，又可以避免被猜到核心数据id。缺点是高并发工作负载时，InnoDB中按主键顺序插入可能会造成明显的争用</li>
<li>使用UUID作为聚簇索引会很糟糕，它使得聚簇索引的插入变得完全随机，使数据没有任何聚集特性<ol>
<li>局部性原理失效，造成大量磁盘I/O</li>
<li>不得不频繁地做页分裂操作，以便为新的行分配空间，这会导致移动大量的数据</li>
<li>由于频繁地页分裂，页也会变得稀疏，并被不规则填充，所以最终数据会有碎片</li>
</ol>
</li>
<li>整数类型通常是最佳选择，因为它们很快并且可以使用自增列。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢</li>
</ol>
</li>
<li>二级索引设置<ol>
<li>为哪些列建立索引：为频繁出现在WHERE、ORDER BY、GROUP BY等子句的列设置索引</li>
<li>如何建立索引<ol>
<li>有排序需求：按排序需求创建索引列</li>
<li>无排序需求：选择性大的条件放在前面</li>
<li>可以通过调整索引顺序，少维护一些索引</li>
<li>尽可能将范围查找的列放在索引的后面</li>
<li>若索引列是字符串类型，考虑前缀索引<ol>
<li>选择索引开始的部分字符，使其选择性接近于索引整个列，可以大大节约索引空间，提高索引效率</li>
<li>无法使用前缀索引做ORDER BY、GROUP BY、覆盖扫描</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>使用索引<ol>
<li>只有独立列才能使用索引，不能是表达式的一部分，也不能是函数中的参数</li>
<li>若范围查询是可枚举的，可以使用IN代替范围查找</li>
<li>覆盖索引：索引包含所有需要查询的字段的值，优化器会在执行查询前判断是否有一个索引能进行覆盖<ul>
<li>优点<ul>
<li>避免二级索引对主键索引的回表查询</li>
<li>索引条目通常远小于数据行大小，减少了数据访问量</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="6-优化关联查询"><a href="#6-优化关联查询" class="headerlink" title="6.优化关联查询"></a>6.优化关联查询</h2><ol>
<li>尽量在应用层做关联</li>
<li>拆分复杂关联查询<ol>
<li>利于使用索引</li>
<li>减少锁竞争</li>
<li>利于数据库拆分</li>
</ol>
</li>
</ol>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制：最终一致性"><a href="#主从复制：最终一致性" class="headerlink" title="主从复制：最终一致性"></a>主从复制：最终一致性</h2><ul>
<li><p>M-S架构</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/m-s.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>如何提供服务？</p>
<p>主库提供读写服务，备库是只读状态，只提供读服务。备库设置为只读，可以防止误操作、数据不一致，还可以用来判断主备角色。</p>
</li>
<li><p>如何同步数据？</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/master2slave.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>备库上执行change master命令，设置其主库地址、binlog起始请求位置等信息</li>
<li>主库执行更新命令（流程之前有），会写binlog</li>
<li>备库上执行start slave命令，开启同步，首先会和主库建立连接。连接建立后，主库开始按照备库传过来的起始地址，从本地读取binlog，发送给备库</li>
<li>备库拿到主库发送过来的binlog后，首先会写入到中转日志relay log，相当于缓存</li>
<li>会有专门的线程从relay log中读取日志，解析出里面的命令后执行</li>
</ul>
</li>
</ul>
</li>
<li><p>M-M架构</p>
<p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/m-m.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>如何提供服务？</p>
<p>互为主备，都可以提供读写服务，但为了避免数据不一致，只有一个节点对外提供服务，备节点只做数据备份。主备切换时不需要修改主备关系，更加快速。</p>
</li>
<li><p>如何同步数据？</p>
<p>和M-S架构一样</p>
</li>
<li><p>循环复制问题</p>
<p>每个节点都有自己的唯一serverid。主库生成binlog时，会携带serverid。备库执行完主库传播过来的binlog后，再生成自己的binlog，会使用主库的serverid。主库接收备库的binlog时，发现里面的serverid等于自己的serverid，就不处理这条binlog</p>
</li>
</ul>
</li>
</ul>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul>
<li>恢复某行数据<ul>
<li>利用Flashback工具闪回数据<ul>
<li>原理是修改binlog拿回原库重放<ul>
<li>适合row格式</li>
<li>不适合statement、mixed格式，都会因为SQL语句及回放的位置导致数据不一致</li>
</ul>
</li>
<li>不建议直接在主库上闪回，而是先恢复出一个备份数据，或者是在从库上恢复数据，然后再拿着恢复好的数据，恢复主库</li>
</ul>
</li>
</ul>
</li>
<li>恢复表/库<ul>
<li>全量备份 + 实时备份binlog</li>
<li>延迟复制备库：一种特殊的备库，可以设置其备份主库的延迟时间，如1小时，那么在这1小时内发生的数据问题，都可以通过这个备库快速恢复。</li>
</ul>
</li>
</ul>
<h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><ul>
<li><p>如何判断主备延迟</p>
<p>每条binlog都会记录其在主库上的写入时间，备库执行binlog时，会计算当前时间与写入时间的差值，这就是主备延迟时间。需要注意，主备库机器时间不同不会影响主备延迟时间的计算，因为备库连接到主库时，会记录其与主库的系统时间差值，之后计算主备延迟时间时会自动扣减这个差值</p>
</li>
<li><p>主备延迟原因</p>
<ul>
<li>备库机器性能比主库差<ul>
<li>现在基本上都做对称部署</li>
</ul>
</li>
<li>备库压力大<ul>
<li>一主多从，分散压力</li>
<li>通过binlog输出到外部系统，坐统计类分析查询</li>
</ul>
</li>
<li>大事务<ul>
<li>分批执行大事务</li>
</ul>
</li>
<li>大表DDL</li>
<li>并行复制策略不合理</li>
</ul>
</li>
</ul>
<h2 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h2><ul>
<li>可靠性优先策略（建议）<ol>
<li>判断备库延迟时间，小于阈值时进行下一步</li>
<li>下线主库，readonly=true</li>
<li>等待备库延迟时间降为0，即同步完所有主库binlog</li>
<li>将备库升级为主库，即改为可读写状态</li>
<li>将业务请求切到新主库</li>
</ol>
</li>
<li>可用性优先策略<ol>
<li>下线主库，readonly=true</li>
<li>将备库升级为主库，即改为可读写状态</li>
<li>将业务请求切到新主库</li>
<li>binlog采用row模式，发现不一致时手动修复</li>
</ol>
</li>
</ul>
<h2 id="并行复制策略"><a href="#并行复制策略" class="headerlink" title="并行复制策略"></a>并行复制策略</h2><p>将relay log按照一定规则分发给多个线程并行执行数据同步工作</p>
<p>基本原则：</p>
<ul>
<li>更新同一行的事务必须被分发到同一个worker</li>
<li>同一事务的多条sql必须被分发到同一个worker</li>
</ul>
<p>分发策略：</p>
<ul>
<li>DATABASE 按库分发：将涉及相同库的SQL分发到同一worker上</li>
<li>COMMIT_ORDER<ul>
<li>binlog状态同时处于prepare的多个事务可以并行执行</li>
<li>binlog状态处于prepare可以与处于commit状态的事务并行执行</li>
</ul>
</li>
<li>WRITESET<ul>
<li>对于事务涉及更新的每一行，计算出hash值，组成writeset。如果两个事务的writeset没有交集，也就是说他们没有操作相同行，可以并行执行</li>
<li>hash是通过库名+表名+索引名+索引值计算出来的</li>
<li>要是同一行涉及多个唯一索引，那么就会生成多个hash值</li>
</ul>
</li>
<li>WRITESET_SESSION：WRITESET基础上，保证同一个线程上先后执行的事务，在备库执行时也保持这个顺序</li>
</ul>
<h2 id="一主多从情况下的主备切换"><a href="#一主多从情况下的主备切换" class="headerlink" title="一主多从情况下的主备切换"></a>一主多从情况下的主备切换</h2><p>由于多个从库都会同步主库数据，并且他们的同步进度并不一样。所以在切换新主库后，可能发生新主库与从库数据冲突的情况，解决方案是：</p>
<ul>
<li>切换过程中忽略指定报错</li>
<li>全局事务ID<ul>
<li>不同于事务id是在事务开始时分配的，全局事务id是在事务提交时分配的</li>
<li>组成：serverId+递增的唯一值</li>
</ul>
</li>
<li>使用<ul>
<li>每个Mysql实例都会维护一个GTID集合，表示该实例执行过的所有事务</li>
<li>备库指定新主库，并与新主库建立连接</li>
<li>备库将自己的GTID集合发给新主库</li>
<li>新主库计算自己的GTID集合与备库GTID集合的差集<ul>
<li>若新主库包含这个差集的所有binlog，则将第一个不在备库GTID集合中的binlog发给备库去执行，之后备库就从这个位置开始向后顺序读取新主库的binlog</li>
<li>若新主库没有包含这个差集的所有binlog，直接返回错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="统计行数"><a href="#统计行数" class="headerlink" title="统计行数"></a>统计行数</h2><ul>
<li>count(*)<ul>
<li>MyISAM<ul>
<li>将表行数存储起来，没有查询条件时可以直接返回</li>
</ul>
</li>
<li>InnoDB<ul>
<li>由于MVCC的存在，无法准确估计此次查询能看到的行的数量，所以没法将表行数存储起来</li>
<li>优化<ul>
<li>优先采用最小的索引树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>show tables status.TABLE_ROWS<ul>
<li>估算</li>
</ul>
</li>
<li>利用缓存系统保存行数<ul>
<li>缓存一致性问题</li>
</ul>
</li>
<li>数据库保存行数</li>
</ul>
<h2 id="count-vs-count-1-vs-count-主键-vs-count-字段"><a href="#count-vs-count-1-vs-count-主键-vs-count-字段" class="headerlink" title="count(*) vs count(1) vs count(主键) vs count(字段)"></a>count(*) vs count(1) vs count(主键) vs count(字段)</h2><ul>
<li>count(字段)<ul>
<li>满足条件的字段不为NULL的行数</li>
<li>搜索引擎按条件查询数据，将每一行的字段取出来交给服务层，服务层判断不为NULL后累计</li>
</ul>
</li>
<li>count(主键)<ul>
<li>满足条件的总行数</li>
<li>搜索引擎按条件查询数据，将每一行的id取出来交给服务层，服务层累计</li>
<li>相比于count(字段)，主键不可能为NULL</li>
</ul>
</li>
<li>count(1) <ul>
<li>满足条件的总行数</li>
<li>搜索引擎按条件查询数据，将每一行赋值为1交给服务层，服务层（不可能为NULL）累计</li>
<li>相比于count(主键)，减少了解析数据行取主键和将主键传输给服务层的过程</li>
</ul>
</li>
<li>count(*)<ul>
<li>满足条件的总行数</li>
<li>搜索引擎按条件查询数据，对于每一行不取值，直接交给服务层累计</li>
<li>MySQL支队count(*)做了这个优化，没有对count(主键)做优化</li>
</ul>
</li>
</ul>
<p>结论：</p>
<p>count(*) = count(1) &gt; count(主键) &gt; count(字段)，建议尽量使用count(*)</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/30/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <span class="hidden-mobile">面试题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"64e7a0af76ea907275e7","clientSecret":"58fc6a6232d3179936704144df3ddeef170c2fdd","repo":"bolg-comment","owner":"Xzzz583722585","admin":["Xzzz583722585"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '925e96d5c63703a8aabe716f2bed3afe'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
