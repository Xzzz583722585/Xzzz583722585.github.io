<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SAC-002-MVC</title>
    <link href="/2021/08/26/SAC-002-MVC/"/>
    <url>/2021/08/26/SAC-002-MVC/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本科在校期间（不确定现在是否也是这样，更不确定是否所有学校都是如此），虽然学生通过操作系统、计算机网络等等科目接触到了许许多多的软件架构，例如期末考试一定会去背的7层 OSI 网络协议，结果老师一开始就告诉你事实协议是4层的 TCP/IP 协议，最后学的是5层协议。这巨大的分层架构摆在眼前，仍然会有很多学生被“架构”二字劝退。</p><p>之所以以 MVC 架构开头，是因为当时出去面试，很多面试官都会问一句：“什么是 MVC？”（怀念面试还没有那么内卷的时代）。大多数人是怎么回答的呢？或者说，甚至连面试官都是怎么看待 MVC 架构的呢？下面是摘抄自<a href="https://www.ruanyifeng.com/blog/2007/11/mvc.html">阮一峰</a>老师微博的内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。<br><br><span class="hljs-bullet">*</span> 最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。<br><br><span class="hljs-bullet">*</span> 中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。<br></code></pre></td></tr></table></figure><p>这是正确的吗？下面是维基百科关于 MVC 架构的介绍：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。<br><span class="hljs-bullet">*</span> 模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。“Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比如：观察者模式）<br><span class="hljs-bullet">*</span> 视图（View）能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。<br><span class="hljs-bullet">*</span> 控制器（Controller）起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。<br></code></pre></td></tr></table></figure><p>好像看起来这两个定义不是那么相同。那么，我想问的是，为什么会有这些差异？究竟什么是业务？维基百科所提到的刷新机制是什么？凡此种种，让我尝试给出 MVC 的严谨定义，再着眼于繁杂的工程领域实现。</p><h2 id="THING-MODEL-VIEW-EDITOR"><a href="#THING-MODEL-VIEW-EDITOR" class="headerlink" title="THING-MODEL-VIEW-EDITOR"></a>THING-MODEL-VIEW-EDITOR</h2><p>我们从 wiki 公认的最早提出 MVC 概念的文章《THING-MODEL-VIEW-EDITOR》，以及同一时期的书籍《Smalltalk-80: The Interactive Programming Environment》出发。</p><p>在 Smalltalk-80 系统早期版本的用户界面往往由四种元素组成：文本、文本列表（菜单）、按钮和图形（位图或像素图）。这些元素具有三种基本的用户交互方式：浏览、查看和编辑。故由 Smalltalk-80 系统提出的 MVC ，其核心目标就是定义可共享的用户界面组件。换句话说，MVC 架构就是一种系统模块化，它具有模块化的好处：将功能模块相互隔离，使其应用程序设计人员更容易了解和修改每个特定模块，而无需了解其他模块的一切。</p><p>MVC 将系统分解为三部分：</p><ul><li><p>model</p><p>model 是对现实世界中的事物以数据形式在计算机系统中的抽象表示，包括数据集合以及处理这些数据所需的方法，不包含信息在屏幕上显示的信息。model 是系统中实际完成工作的那些组件（什么工作？）。model 提供一种机制，使 view/controller 可以注册其中，当此 model 的状态发生变化时，可以根据注册信息广播消息（观察者模式）。</p></li><li><p>view</p><p>view 是 model 的视觉展示，它突出 model 的某些属性并抑制其他属性。view 通过请求从 model 中获取展示所需的数据，或者更新 model 中的数据。所有这些请求都包含在 model 所表示的抽象含义中，因此 view 必须知道它所代表的 model 的属性语义（这里虽然表明 model 具有业务含义，但一是 MVC 并没有将业务与技术区分开，二是 MVC 并没有从业务上做过模块划分，它只按照技术领域去做模块划分）。 </p></li><li><p>editor/controller</p><p>controller 是用户和系统之间的链接。它为用户提供<strong>输入入口</strong>，包含其关联 model 和 view 与输入设备（键盘、鼠标、时间等）之间的接口，controller 的工作就是处理 model 的控制或操作（编辑）功能。<strong>注意，controller 不是 view 的补充，view 永远不知道用户输入，例如鼠标操作</strong>。可以通过 controller 将消息发送到 view，用来再现用户命令序列。 controller 还处理与其他 controller 的调度交互。</p><p>editor 是一种特殊的 controller，它允许用户修改视图显示的信息。</p></li></ul><p>view 与 controller 一一对应，每个 controller 只对应一个 model，但一个 model 可能与许多 view/controller 对应。view 和 controller 需要明确地了解它们对应的 model，但 model 不应该知道他们的 view 和 controller。其实从技术的角度讲，model、view、controller 在划分清晰的前提下，是具有可插拔特性的。但是，这里之所以要强调 model 与 view/controller 之间的这种对应关系，是因为 model 承载着业务上的逻辑。</p><p><img src="/images/SAC/MVC/flow-chart.png"></p><p>MVC 有以下几种交互场景：</p><ul><li><p>显示数据：view 直接向 model 查询最新数据，经过过滤后以适当的形式向用户展示。</p></li><li><p>用户输入：用户采取一些输入动作，通过 controller 通知 model 执行相应的操作，这有可能会改变 model 的状态。当 model 状态改变时，会向在该 model 中注册的 view/controller 广播它已经改变状态的通知。 然后，收到通知的 view 可以查询 model 有关其新状态的数据，并向用户显示。 </p></li></ul><p>这产生了几个重要问题：</p><ul><li><p>消息广播</p><p>一个 model 绑定了多组 view/controller，但是每次用户的输入动作，都只可能通过一个 controller 传递到 model，所以，当 model 的状态改变时，所涉及的所有 view/controller 都需要感知到这些变化，以及时应对。</p></li><li><p>读写分离</p><p>很显然，MVC 天生就带着读写分离的味道。我们不要去想着具体的交互行为，例如到底是点击按钮还是列表展示。参考 CQRS，view 直接访问 model 获取最新数据，以用来显示，并且，view 是永远不关心用户具体输入行为的。controller 负责用户输入行为，即增加、删除、修改等操作，在某些场景下，用户的输入在到达了 controller 后，不需要更新 model，就会直接返回给 view 用于展示。</p></li></ul><p>可以看出，MVC 是一种解决用户控制复杂大型数据集问题的通用方案，让用户可以从多个角度控制他们的数据。MVC 有利于数据封装和代码复用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://folk.universitetetioslo.no/trygver/2007/MVC_Originals.pdf">Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.388.2266&rep=rep1&type=pdf">Adele Goldberg.Smalltalk-80: The Interactive Programming Environment, 1984.</a></p><p><a href="http://heaveneverywhere.com/stp/PostScript/mvc.pdf">Glenn E. Krasner.A Description of the Model-View-Controller User Interface Paradigm in the Smalltalk-80 System, 1988.</a></p><p><a href="https://www.researchgate.net/profile/Arne-Guellich/publication/235959534_MVC-induced_short-term_potentiation_of_explosiv_force/links/00b7d5313ebda127ae000000/MVC-induced-short-term-potentiation-of-explosiv-force.pdf">Arne Güllich.MVC-induced short-term potentiation of explosive force, 1996.</a></p><p><a href="https://pdf.sciencedirectassets.com/278653/1-s2.0-S1877705814X00020/1-s2.0-S187770581400352X/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEH4aCXVzLWVhc3QtMSJGMEQCIHc8mQO8Xz3tRDpHYqSrP/Ry9jGIQ34lFez/rSuVfoseAiBlCNu+KUYZoXw0S1GL3pSQnxV02UzwETl0RXq/0nv1ASqDBAi2//////////8BEAQaDDA1OTAwMzU0Njg2NSIMDxrH7laEvfWEj51EKtcD1pVPGdkhPhPfFhxJxrIUDkQCkABfA1k97pShjs5vjQ1Mxzxjc+ikAAgzcw+17pF1HkVVrQcqWR7+Rl8WL0HDuLp8NfyQUmpxyD2gZsa8KkU/QovaQUGuMRAJCWlODemCspy7CHyhJXSxsbfRqO1Gnk6VklR1DwEP1lEOn3Oq1CRhI+PlJj2T/efZCJO+SwADMhtU9REQ5z8len68ckwKwdVSaMSVnH8cJ1lwpH5o8UKTZB9h9a7YZyZaxI24vrrCQQ1fhcjz58sx5Z8KDRIOYyLRoqlqk+vRx7H+cnndWI3vN63iK1qFrTXnFzJlvJF0TKULP63iFPZ6bgu3IXyzPqzZ83q646Xxw3IJMKEjgX8oFbqVu7w5THXnbtjxlVjxmyNWuAO/+9YUAgLOlNzP84+b1ZWUmj3d06cb2gUUEKnIF5kLpt/8zeFk+aYRZJgZzy4MYlHynbdMa4u9n93ETAi+jaxXvBzRMss1Z46t4tiSCQGx59rP6reT54SMaCkEiUdfqETLhq52abZ66GKwpoR5ci9aaW57wGRNq/NhTRl2J3xCprbQ8BOjMi9qbZVFpfZwMfXdwmf4WCnZP5OEQB3TCt13VkyL6gG6QoCnqVWRy1t3l9x5MLLVsYkGOqYBj36DquA2msyX9hmkNp9YdnEGxl9C3yVVNU+8qbgjxDBaQsPrG/0fiMupNzlNUvXFjcsuvFHyokR96xItOweKYbGOcc14H+KVp9U1wvkr9dAQ5IeNMgLosyS9JfQVy3VdWRF9G1AdWGtonkumFnrDhPnnGlhlrQcnIUXTZNUyXRTsdlG9zLdMGaRtDGqhOk1CYYeW1E1F4OF+TYLtvV5EpmAI7ZsUwA==&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210830T061856Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWWRCNY73/20210830/us-east-1/s3/aws4_request&X-Amz-Signature=a14fbae4f5014af539585b0a560486fb97c5630a5ab72987b254ab5fb18ac730&hash=5902936a72d87db3275f4fe2aaa2a34bfa8a5f0a15cb91f81f8b039318205651&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S187770581400352X&tid=spdf-9afc5b5d-6a90-40cc-a1e0-743a3a825bb8&sid=9315aae8544ba24f036a61d42bd1116b0a42gxrqa&type=client">Dragos-Paul Pop.Designing an MVC Model for Rapid Web Application Development, 2013.</a></p><p>[2]Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</p><p>[2]Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</p><p>[2]Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</p><p>[2]Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SAC-001-概述</title>
    <link href="/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<style>    .cd-timeline.svelte-1t2uafz .svelte-1t2uafz,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::after,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::before{-webkit-box-sizing:border-box;box-sizing:border-box}.cd-timeline.svelte-1t2uafz{font-size:1.6rem;font-family:"Droid Serif", serif;color:#7f8c97;background-color:#e9f0f5}.cd-timeline.svelte-1t2uafz a{color:#acb7c0;text-decoration:none}.cd-timeline.svelte-1t2uafz img{max-width:100%}.cd-timeline.svelte-1t2uafz h1,h2{font-family:"Open Sans", sans-serif;font-weight:bold}.cd-timeline.svelte-1t2uafz{overflow:hidden;margin:2em auto}.cd-timeline__container.svelte-1t2uafz{position:relative;width:90%;max-width:1170px;margin:0 auto;padding:2em 0}.cd-timeline__container.svelte-1t2uafz::before{content:'';position:absolute;top:0;left:18px;height:100%;width:4px;background:#d7e4ed}@media only screen and (min-width: 1170px){.cd-timeline.svelte-1t2uafz{margin-top:3em;margin-bottom:3em}.cd-timeline__container.svelte-1t2uafz::before{left:50%;margin-left:-2px}}.cd-timeline__block.svelte-1t2uafz{position:relative;margin:2em 0}.cd-timeline__block.svelte-1t2uafz:after{content:"";display:table;clear:both}.cd-timeline__block.svelte-1t2uafz:first-child{margin-top:0}.cd-timeline__block.svelte-1t2uafz:last-child{margin-bottom:0}@media only screen and (min-width: 1170px){.cd-timeline__block.svelte-1t2uafz{margin:4em 0}}.cd-timeline__img.svelte-1t2uafz{position:absolute;top:0;left:0;width:40px;height:40px;border-radius:50%;-webkit-box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05);box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05)}.cd-timeline__img.svelte-1t2uafz{background:#75ce66}@media only screen and (min-width: 1170px){.cd-timeline__img.svelte-1t2uafz{width:60px;height:60px;left:50%;margin-left:-30px;-webkit-transform:translateZ(0);transform:translateZ(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}.cd-timeline__content.svelte-1t2uafz{position:relative;margin-left:60px;background:white;border-radius:0.25em;padding:1em;-webkit-box-shadow:0 3px 0 #d7e4ed;box-shadow:0 3px 0 #d7e4ed}.cd-timeline__content.svelte-1t2uafz:after{content:"";display:table;clear:both}.cd-timeline__content.svelte-1t2uafz::before{content:'';position:absolute;top:16px;right:100%;height:0;width:0;border:7px solid transparent;border-right:7px solid white}.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{color:#303e49}.cd-timeline__content.svelte-1t2uafz p,.cd-timeline__date.svelte-1t2uafz{font-size:1.3rem}.cd-timeline__content.svelte-1t2uafz p{margin:1em 0;line-height:1.6}.cd-timeline__date.svelte-1t2uafz{display:inline-block}.cd-timeline__date.svelte-1t2uafz{float:left;padding:.8em 0;opacity:.7}@media only screen and (min-width: 768px){.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{font-size:2rem}.cd-timeline__content.svelte-1t2uafz p{font-size:1.6rem}.cd-timeline__date.svelte-1t2uafz{font-size:1.4rem}}@media only screen and (min-width: 1170px){.cd-timeline__content.svelte-1t2uafz{margin-left:0;padding:1.6em;width:45%;-webkit-transform:translateZ(0);transform:translateZ(0)}.cd-timeline__content.svelte-1t2uafz::before{top:24px;left:100%;border-color:transparent;border-left-color:white}.cd-timeline__date.svelte-1t2uafz{position:absolute;width:100%;left:122%;top:6px;font-size:1.6rem}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz{float:right}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz::before{top:24px;left:auto;right:100%;border-color:transparent;border-right-color:white}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__date.svelte-1t2uafz{left:auto;right:122%;text-align:right}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}    </style><section class="cd-timeline js-cd-timeline svelte-1t2uafz">    <div class="cd-timeline__container svelte-1t2uafz">        <div class="cd-timeline__block js-cd-block svelte-1t2uafz">            <div class="cd-timeline__img cd-timeline__img--movie js-cd-img svelte-1t2uafz">            </div>            <div class="cd-timeline__content js-cd-content svelte-1t2uafz">                <h2 class="svelte-1t2uafz">ECMAScript 1</h2>                <p>First edition.</p>                <span class="cd-timeline__date svelte-1t2uafz">1997-06</span>            </div>        </div><div class="cd-timeline__block js-cd-block svelte-1t2uafz">            <div class="cd-timeline__img cd-timeline__img--movie js-cd-img svelte-1t2uafz">            </div>            <div class="cd-timeline__content js-cd-content svelte-1t2uafz">                <h2 class="svelte-1t2uafz">ECMAScript 2</h2>                <p>Editorial changes to keep the specification fully aligned with ISO/IEC 16262 international standard.</p>                <span class="cd-timeline__date svelte-1t2uafz">1998-06</span>            </div>        </div><div class="cd-timeline__block js-cd-block svelte-1t2uafz">            <div class="cd-timeline__img cd-timeline__img--movie js-cd-img svelte-1t2uafz">            </div>            <div class="cd-timeline__content js-cd-content svelte-1t2uafz">                <h2 class="svelte-1t2uafz">ECMAScript 3</h2>                <p>Added regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output and other enhancements.</p>                <span class="cd-timeline__date svelte-1t2uafz">1999-12</span>            </div>        </div><div class="cd-timeline__block js-cd-block svelte-1t2uafz">            <div class="cd-timeline__img cd-timeline__img--movie js-cd-img svelte-1t2uafz">            </div>            <div class="cd-timeline__content js-cd-content svelte-1t2uafz">                <h2 class="svelte-1t2uafz">Abandoned ECMAScript 4</h2>                <p>Fourth Edition was abandoned, due to political differences concerning language complexity. Many features proposed for the Fourth Edition have been completely dropped; some were incorporated into the sixth edition.</p>                <span class="cd-timeline__date svelte-1t2uafz">2000-01 - 2007-10-23</span>            </div>        </div>    </div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DDD-001-对一个未完成项目的总结</title>
    <link href="/2021/08/19/DDD-001-%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/19/DDD-001-%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容为ZXJY公司内部系统架构、代码、文章、讨论的归纳总结，以及本人对各问题的思考。因保密相关，涉及到敏感内容，会以网络普遍讨论的模型为例。</p><h2 id="ZXJY公司系统架构所面临的问题"><a href="#ZXJY公司系统架构所面临的问题" class="headerlink" title="ZXJY公司系统架构所面临的问题"></a>ZXJY公司系统架构所面临的问题</h2><p><strong>核心问题：微服务数量过多。</strong></p><p>ZXJY从2015年开始全面使用微服务架构后，服务的数量就开始飞涨。某些研发组甚至发展到了，一个业务功能一个微服务的程度（往往是按照数据库表来划分的，这里要埋一个坑，即微服务如何划分的实践问题）。在一开始感受到微服务带来的分工和模块化的优点之后，团队很快就碰到如何管理数量庞大的微服务的棘手问题–<strong>系统复杂程度指数级上升</strong>。</p><ul><li><p>理解困难。</p><ul><li>新人对业务逻辑与代码逻辑的映射、系统架构、代码细节、技术实现理解困难。</li></ul></li><li><p>开发困难。</p><ul><li>难以判断新功能放在哪个微服务更合适（或者说都可以）。</li><li>抽象泄漏。微服务作为SOA的一种类型，其初衷就是希望能够通过对外部提供一个合理抽象的接口，从而屏蔽内部的实现。只要接口定义不变，内部可以独立迭代，从而实现开发流程的扩展性。然而我们很难保证服务拆分和接口设计是合理的，尤其在业务快速迭代的过程中，整个系统的各种基础假设都会被持续迭代。然而一旦某个逻辑被暴露为微服务接口，其抽象就泄露到了整个系统，后续要修改或者下线这个接口的成本是极高的。这就导致了后续即使业务逻辑发生变化，我们也只能捏着鼻子在沿着错误的抽象来修修补补。</li></ul></li><li><p>部署困难。</p><ul><li>一个功能的上线可能涉及到多个微服务，那么怎么打包、上线顺序等等都是问题，当团队开发节奏加快后，频繁的部署使研发、运维人员苦不堪言，很多简单的修改都需要同时更新多个微服务，不但使得工作量大大增加，也使得部署的依赖更加复杂。</li><li>DevOps、敏捷等技术的运用遭受挑战。</li></ul></li><li><p>测试困难。</p><ul><li>本地代码调试困难。</li><li>Bug溯源、定位、追踪复杂。</li></ul></li><li><p>维护困难。</p><ul><li>网络波动对服务性能影响巨大。</li><li>对基础设施迭代不友好。数量庞大的微服务大大拖慢了基础设施迭代和推广的速度，又进一步使得微服务无法得到有效支撑。一个惨痛的现实就是，每次有紧急的基础设施升级，都必须手动升级数量庞大的微服务，带来了巨大的人力浪费。</li></ul></li></ul><h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h2><p>在讨论解决方案之前，应先定义清楚衡量系统架构的指标都有哪些（此处不由得联想到《演进式架构》，或者更广义的说，在讨论任何科学问题时，先行定义清楚问题域边界是至关重要的）。</p><p>在介绍最终衡量指标前，先对陶文的博客<a href="https://github.com/taowen/modularization-examples">《代码防腐》</a>做简要陈述。代码腐败也叫软件熵，是指软件性能随着时间而逐渐恶化或反应性的递减，导致软件出错、不稳定。这并不是一个物理现象，因为软件实际上并不会衰变，而是缺乏敏捷反应、未能随环境变化而修改。显然，正如《没有银弹》一文所说，由于<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">软件本质性</a>所引发出的 complexity、invisibility、conformity、changeability，再加上许多人为因素：软件开发者本人所处时空限制、能力限制导致其并不能做出现在看来“完美”的设计；商业软件本身需要去衡量各种成本，包括资金、人力、时间等等；缺乏完善的测试等。以上因素，导致开发者不得不在本就困难的问题基础上，缺乏思考、设计的情况下赶工开发，致使问题影响范围扩大，又由于没有严格的测试拦截，导致问题得不到有效的反映和遏制，再加之缺乏复盘性的总结学习，导致问题越来越难以解决，即腐败的味道愈加浓重。</p><p>什么样的系统是我们所希望的，我们又要如何去发现代码腐败。</p><p>首先陶文指出了系统应该具备的三点特性，现做出总结。</p><ul><li><p>Autonomy 独立性。</p><p>开发团队担心出现这样的症状：</p><ul><li>沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。</li><li>需求下线困难：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。</li></ul><p>独立性的愿景就是尽量减轻上述的症状，让拆分出来的代码更独立。用以下指标衡量系统的独立性：</p><ul><li>会议时间。</li><li>接口改动次数 / 接口实现改动次数 比率：我们期望大部分时候就可以只改接口实现，而不改接口本身。</li></ul></li><li><p>Consistency 一致性。</p><p>一致性是对可复用 git 仓库的要求，是为了防御常见的设计错误。用以下指标衡量系统的一致性：</p><ul><li>必要参数总量 / 参数总量 比率：把可复用 git 仓库对外提供的函数的参数分为两类，必要参数和非必要参数。非必要参数是指只有 10% 的调用方传递了的参数。</li><li>咨询量：可复用的 git 仓库，应该努力降低使用者的成本。 使用者的最大成本来自于沟通问询。如果文档不清楚，接入方式是手工的，必然会体现在咨询量上。</li><li>接入次数：使用次数只有1次或者2次，就不应该被抽取成可复用的 git 仓库。至少要被使用3次。</li><li>接入率：如果要抽出可复用的代码，出发点应该是一致性，是在团队关键成员达成了一致之后的有意识行为。</li><li>阻断率：阻断率指所有可接入的地方，有多少处上了强制检查，确保了违规行为会被阻断。</li></ul></li><li><p>Feedback 反馈性。</p><p>业务逻辑无论如何做拆分，最终仍然是要集成到一起跑起来的。 无论是编辑时拆分成文件、文件夹、git 仓库，还是运行时拆分成进程，拆分无可避免地引入了“降低反馈速度”的副作用。 一旦产生了分工，就会有你不了解的部分。这也是分工的本意所在，控制知识边界，让普通人也可以参与劳动。 但是软件是要整体集成到一起才能发挥其全部价值。这种“整体”与“部分”的矛盾，造成了反馈性问题。</p><p>开发团队担心出现这样的症状：</p><ul><li>故障定位慢。</li><li>获得真实反馈慢：代码写完了要等审核发版，错过了这个版本又要等一个月公司才会发下个版本。</li><li>本地测试难：稍微有点价值的测试都不是本地可以用 JUnit 写出来的。</li><li>与用户脱轨。</li></ul><p>反馈性的愿景是尽量减少获得反馈的摩檫力。业务逻辑拆分为什么会影响到反馈性呢？这仍然是要归结为人的沟通效率问题（《人月神话》）。能用标准化的方式解决的，就可以减少沟通。能尽量减少信息传递次数的，就可以有效减少传递过程中的信息衰减。用以下指标衡量系统的反馈性：</p><ul><li>工单流转时长。</li><li>故障定位时长。</li><li>代码集成时长。</li></ul></li></ul><p>其次陶文给出了应对代码腐败的策略。</p><ul><li><p>信息隐藏：封装、抽象、依赖倒置。</p><p>在依赖倒置的前提下，需要显式地提炼出最小化接口， 从而让更多的需求改动封闭在更上层的依赖关系里，更多去改实现代码，而不是改接口代码。</p><p>还有一个问题是，如何做到独立性？这里不能依赖人力的 code review，而应该依赖代码结构，限制改动范围。如此一来，模块的 git 仓库是不会造成全局影响。我们就可以放心的把新人分配去写一个独立的模块，而不用担心其设计选择造成大面积的代码腐化。code review 仅需要集中关照主板。并且评价“高内聚低耦合”的标准也可以用主板的代码改动行数进行量化（在完成需求的前提下，主板的代码改动行数越少越好）。</p></li><li><p>分层</p></li><li><p>持续改进</p><p>只对自己写的代码负责要体现在发布变更，告警定位这两个环节里。做好了这两点，就有了持续改进系统的基础保障。</p><ul><li><p>发布变更。单体应用最大的原罪就是变更的粒度太大了。而大粒度变更是稳定性的最大敌人。 切分变更有三种主要的做法：</p><ul><li><p>多进程：把单体进程切分成多进程，控制的是代码的变更。一次只变更其中的一个。因为大部分线上故障都是由变更引起的，所以 SRE 会非常强调部署流程的小心谨慎。 一旦发现有问题，就会被要求立即回滚。这也就导致了搭车上线是非常讨厌的事情，谁知道你搭车进来的改动会不会翻车。 所以拆分成多进程，各上各的就会变成非常强烈的需求。</p><p>但是用拆分进程的方式来解决上线慢的问题也会有一些缺点：</p><ul><li>反馈不集中：小流量的时候，引起的小规模的故障可能观察不出来。</li></ul></li><li><p>灰度数有限：集群规模比较小的时候，总共就几个进程，灰度的刻度就会很大。</p><ul><li>回滚慢：进程替换需要时间。</li></ul></li><li><p>灰度时间有限：上线观察一天已经很夸张了，要更长时间的观察是不好用上线的方式来实现的。</p><ul><li>上线顺序：进程之间经常有数据依赖，并不能总是保持向后兼容。</li></ul></li><li><p>多租户：把所有的业务数据分成租户，控制的是数据的变更。一次只升级一个租户的数据和代码。</p></li><li><p>多变种：分租户还是粒度太粗了，比如说挂掉一个城市也是不可接受的。那么可以在线上同时运行多个版本的代码，然后逐步的切流量，这其实控制的是配置的变更。在不改变进程的情况下，通过配置等方式更灵活地进行装配组合。这样发布和上线就可以解开为两个操作了。上线就是上线，改变进程里的可执行代码。 上线可以不把 feature flag 打开，而是保持原有的行为。 然后再慢慢地打开 feature flag 的流量开关。</p></li></ul><p>当然更极致的做法是同时分租户，也在租户升级的时候切流量。</p></li><li><p>告警定位</p><p>要减轻分工带来的负面影响，最重要的是做好“隔离”。虽然我们把所有的部件都集成到了一起了，但是我们仍然要在“运行时”通过各种手段人为制造出边界，把责任隔离出来。 把责任隔离出来，就是把运行时的行为，与背后负责的团队与个人对应起来。</p><ul><li><p>进程边界</p><p>把不同的 git 仓库跑在不同的进程里。这样只要看是哪个进程出的问题，就可以知道问题是由哪个 git 仓库引起的了。</p><p>进程边界的优点如下：</p><ul><li>完善的跨进程调用监控：相比进程内调用，跨进程调用的监控基础设施要完善得多。</li></ul></li><li><p>操作系统强制的配额和安全性：基础设施更好。</p><ul><li>隔离的内存状态：进程之间不会共享内存，从而产生监控逃逸的影响。</li></ul><p>进程边界的缺点如下：</p><ul><li>适用场景：在前端里启动独立的进程不是常规的做法。</li></ul></li><li><p>性能优化会漏掉依赖：经常我们会把配置等数据读取一次之后就缓存在进程内。这部分依赖就很容易逃逸出监控的范围。</p><ul><li>远离用户：拆分出来的进程往往是越来越靠后台，离用户越远，就越难以倾听到用户的声音。</li></ul><p>我们的目标是在出问题之后，能从运行时的现象找到对应的 git 仓库。</p></li><li><p>函数边界</p><p>无论是编程语言原生支持的同步调用栈，还是需要自研的异步调用栈，其目的都是隔离，从而给 caller/callee 关系建索引。</p></li><li><p>模块边界</p><p>如果有强制的模块规范，那甚至可以做到“内存状态”的隔离，用编译检查等手段禁止全局变量，禁止偷偷地访问另外一个模块的内部状态。 一个进程要读取一份配置，只有第一次RPC的时候我们才能监控到，后续缓存在内存里的访问就是不可见的了。 而模块则不用担心跨模块调用的开销，我们可以把配置缓存在另外一个模块里，这样每次读取配置都是跨模块的调用，从而可以被监控到。</p><p>模块和进程的核心区别就是模块可以适用于更多的运行时（比如iOS，微信小程序），可以用于拆分运行时调用关系更频繁更紧密的界面和流程。 进程边界的优势来自于社区共识，提前提供了大量开源的优秀基础设施。 但是并不意味着，除了进程边界，我们不能在进程内再为每个 git 仓库划出边界来，只是要付出一些自研代价罢了。 社区共识是不够的，在函数边界（特别是同步调用栈之外的其他调用关系），以及模块边界上都没有足够强的规范。 只要能在公司或者部门级别建立好共识，函数边界和模块边界完全可以满足问题定位的需求，甚至比进程边界做得更好。</p></li></ul></li></ul></li></ul><p><strong>现给出ZXJY公司对于系统的衡量指标。</strong></p><ul><li>rpc 接口总数量。</li><li>接口改动次数 / 接口实现改动次数 比率。</li><li>微服务调用链上依赖关系的数量。</li><li>一次需求平均所需修改的 git 仓库数量</li><li>一个需求上线所需的时间。</li><li>没有循环依赖。依赖和耦合的最大区别在于，当我们说“A和B耦合”时，在字面含义中，A和B二者平等。然而，正确的模块关系根本不应该平等，而应该是单向依赖才对。所以我们应该说“A依赖B”，这样含义要清楚得多。A依赖B意味着，A模块可以调用B模块暴露的API，但B模块绝不允许调用A模块的API。单向依赖是红线，好的设计一定不会违反这条红线。</li><li>正交性：指一个模块提供的API中，多个方法之间是否有重复的功能。</li><li>紧凑性：指一个模块提供的API中，公有方法总数必须很少，每个方法的参数也必须很少。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>核心思路：降低微服务数量。</strong></p><p>为了更好的管理系统的复杂度，减缓系统的腐化，我们的架构目标主要是：</p><ul><li><p>服务接口的合理与简单高于具体功能实现的优雅。系统复杂度主要来自于服务对外的接口，因此我们的架构重点关注接口设计，而内部实现可以相对灵活。</p></li><li><p>易于迭代高于强大的预先设计。当前业务灵活多变而团队经验较为欠缺，很难做好太多预先设计，但系统必须具备快速迭代的能力。</p></li><li><p>团队和系统的自治高于功能复用。功能复用很容易带来沟通成本上升、抽象泄露、以及功能分化的风险。</p></li><li><p>风格的简单一致高于追求技术完美。</p></li><li><p>工具和自动化高于灵活与精确。我们希望尽可能的利用工具和自动化来阻断不合理的设计，降低对人的依赖。</p></li></ul><p><strong>核心方案：区分“项目”和“服务”。一个项目对应一个代码仓库（git repo），规模可以适当大一些，应当包含一个领域内的大部分逻辑。一个服务对应一个进程，可以是项目中的一个 module 或者是一个单独的 entrypoint。基础架构的部署系统提供了便于部署项目的能力，即项目中的代码修改之后，可以自动部署所有关联的服务。</strong></p><p>微服务架构最大的好处是给出了非常清晰的模块边界。以前我们会让一个微服务来对应一个功能模块，导致粒度非常细。问题在于随着业务的变化，边界也是会随之变化的，如果我们过早通过微服务来实现边界，后续修改的成本是极高的。因此我们不应该再轻易独立出微服务，而是尽量在服务内部划分清晰的功能边界。</p><p>目前我们的服务架构都是遵照三层架构，基本分为展示层、逻辑层、存储层，每一层内没有更多划分模块的规范。因为我们把系统功能拆分成为多个微服务，而且之前实践中往往把微服务拆的过小，因此一般逻辑都比较简单，每一层内不隔离问题也不大。不过之后每个微服务要处理相对完整的业务逻辑，粒度会变大，单个服务的复杂度会上升。因此简单的按层次来划分已经不够，此时的最佳实践应当是根据功能来划分。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面剖析电商项目。</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/images/DDD/001/logic_view.png"></p><p><img src="/images/DDD/001/code_struct.png"></p><p>项目整体结构参考六边形架构，将业务逻辑隐藏在 backend 模块内，即六边形的内部。</p><p><img src="/images/DDD/001/code_struct_admin.png"></p><p><img src="/images/DDD/001/code_struct_consumer.png"></p><p><img src="/images/DDD/001/code_struct_job.png"></p><p><img src="/images/DDD/001/code_struct_rpc.png"></p><p><img src="/images/DDD/001/code_struct_web.png"></p><p>admin、consumer、job、rpc、web 都属于接口，分别对应了web（B端与C端）、mq、定时任务、rpc这些系统可能的调用方，满足其需求。可以看出，接口相互之间互不影响，当需要满足新的调用方式时，只需要添加对应的模块，处理对应的请求即可，真正的业务逻辑永远保持在领域内。</p><p><img src="/images/DDD/001/code_struct_client.png"></p><p><img src="/images/DDD/001/code_struct_common.png"></p><p>由于使用 thrift 作为 rpc 协议，故在 common 模块内定义 thrift schema，在 client 封装对于 thrift 借口的调用，方便调用方使用。而 rpc 请求真正的处理者，是前文所讲的 rpc 模块内的 rpc handler。</p><p><img src="/images/DDD/001/code_struct_backend.png"></p><ul><li><p>application</p><p>application 层是对对外所暴露接口的实现，属于主适配器，有编排多个领域以及防腐层的职责。</p><p>usecase 实现了上层所有接口，通过编排各个领域中 service 所提供的基本能力，实现业务动作。如创建订单，我们需要查询商品、修改库存、使用优惠券、创建订单实体等一系列复杂行为，但是他们按照我们之前的领域划分，很有可能分属于不同领域，那么这时候就可以通过 usecase 将他们融合在一起。</p><p>commond/query CQRS模式中的 command 和 query。简单介绍，CQRS是一种读写分离模式，command 代表了对数据产生变化的操作，一般是新增、删除、更新，query 代表了不对数据产生变化的操作，一般是查询。在没有 CQRS 的系统中，不论是何种类型的请求分别经过 controller、service、storage 查询到数据库，再分别经过 storage、service、controller 返回给前端显示。但是从数据层面我们就知道，不同系统对于读写两类请求的需求与支持是不同的。故在 CQRS 模式中，读/写两类请求分别走不同的接口与路径，甚至可以实现为读/写访问不同的数据存储。</p><p>dto 是防腐层数据接口，将外部数据类型与领域内实体解耦。举例来说，thrift 接口使用的数据类型是在 thrift 文件中定义的 struct 通过 thrift 命令行命令生成的，rpc 接口的调用方和提供方都使用此数据结构，但是，领域中肯定使用 entity 实体与 model 值对象作为数据结构，这就需要 dto 作为中间层的数据结构，首先解耦了两边数据结构的直接关联，其次在整个 application 层都可以使用 dto 代表编排聚合后的数据结构。</p></li><li><p>component</p><p>严格来说，component 是真正的领域层，component 包下的每个子包，即对应了 DDD 中的一个子域（对于该项目，仍然是一个限界上下文对于一个子域）。其中 trade 属于核心域，负责交易相关内容，如查询订单、创建订单、预支付（创建支付订单与第三方支付单）、退款订单等。product 负责查询商品、查询优惠券、发送优惠券、使用优惠券、查询礼包等。</p><p>entity 实体是拥有 id（可能是多主键） 的对象。深入的说，抛开具体存储的技术不谈（不管是什么类型的数据库，还是文件等等），实体是可以被它的 id 唯一标识的，除了 id 以外的所有属性，都只是为了描述该实体，不能通过这些属性去判断两个实体是否相等。</p><p>model 值对象是没有 id 的对象。同理，一个值对象就是根据其属性所决定的，但是这里并没有说所有属性，具体判断两个值对象是否相等，由具体业务决定。</p><p>举个例子：社会上有很多人都叫王浩，但是他们的身份证 id 不同，从社会角度来说，他们就是两个完全独立的人。但是，市场上有很多同样品牌、同样款式、同样颜色、同样大小的衣服，在很多场景下，我们在 A 地看见这件衣服，当我们在 B 地再次看见时，就可以说是同一件衣服，我们没有给衣服编号的必要性，我们只是觉得根据这些属性去判断就足够了。当然，再次强调，这只是例子，如果你在开发的是某纺织工厂的系统，就是要为每一批产品，甚至每一件衣服编号，那这就是你的业务所需要的，衣服或许就应该是一个实体。</p><p>除此以外，entity 实体在内存中是可以变化的，可是 model 值对象不可以变化，即 model 值对象查询到以后，其所有属性值都是不可变的，没有 setter 方法。</p><p>port/repository 都属于从适配器，定义了领域所需要的底层逻辑接口。区别是，在此项目中，repository 所定义的接口都属于对某个 entity 实体的 CRUD。port 则没有此限制，仅代表了接口的含义。需要注意的是，现如今有很多 ORM 框架都只需要定义 java interface，由框架本身实现具体的增删改查逻辑，如 Mybatis、Hibernate 等。但是，把这些框架放在六边形架构中，就产生了一个问题，即领域内所定义的 repository 接口，是和具体实现（具体 ORM 框架）所绑定的，这是绝对不允许的，即领域内只关心业务问题，只要牵扯到了底层技术实现问题，那就是错的。所以，在使用这些框架时，我们依然把 repository 接口当作普通的抽象定义，在实现层，用这些框架的写法去定义框架所需要的 interface，来作为对 repository 的实现。</p><p>service 实现了领域内的业务逻辑。如创建订单、创建退款单等，注意，这里的每个动作，都是单一领域内的完整动作，即只是创建了一个“订单”而已（粗暴的理解，只是在订单表插入了一条记录，但这只是为了理解，切记，领域内不关心具体实现，具体实现可能要复杂很多），至于我们平常所认知的创建订单–商品、优惠券、活动等等相关概念的处理，他们都不属于此领域，故 service 中不牵扯这些概念。</p></li><li><p>infrastructure</p><p>六边形架构中的从适配器，用于对接数据、业务逻辑的底层实现，并且承担了防腐层的职责。以电商项目为例，商品、订单等功能对接电商中台，故查看商品详情、创建订单、退款订单等动作，底层数据、甚至逻辑就存储在“电商中台”。优惠券、代币等属于业务部门的功能，底层数据选择使用 mysql 存储。回想之前的主适配器，可以看出在整个六边形架构中，整个架构的依赖方向是向内的，即指向领域中心。用来约定外层行为的方式就是抽象，彻底与外层解耦。</p><p>对于领域内部而言，这些细节是不重要的，领域内不需要清楚具体的实现细节，对它而言，它只是根据约定，即 port/repository 所定义接口中声明的方法与数据结构，来实现领域的业务动作。</p></li></ul><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>微服务数量变少之后，可以很大程度上改善抽象泄露的问题，一个领域内的逻辑可以尽量保持在一个项目内部，不需要对外暴露内部接口。</p></li><li><p>在我们的基础设施足够强悍之前，微服务的数量变少总是可以大大的方便各种基础库的迭代。</p></li><li><p>项目内部的调用不需要过 rpc，可以充分利用 IDE 的自动化重构能力，在运行效率和开发效率上都会有明显提升。</p></li><li><p>项目足够自治，对外部依赖较少，更加便于自动化测试。</p></li><li><p>只有确实跨领域的逻辑才需要对外暴露接口，对于这些接口也可以进行更严格的 code review。如果微服务数量和拆分相对合理，应当期望微服务对外接口的变动是相对少的。这样我们可以强制要求所有涉及到接口变动的修改应当有更加严格的 code review 流程，从而保证系统设计的合理性。而微服务内部的变动可以相对灵活，因为重构和测试的成本都是较小的。</p></li><li><p>更易于消除循环依赖。</p></li><li><p>服务这一层抽象不是为了解决功能的划分，但是提供了两个益处：</p><ul><li>不同服务对应独立进程，提供了一定的运行时隔离，也便于单独扩容</li><li>一些展示层的代码可以放在上层模块中，使得模块之间容易避免循环依赖</li></ul><p>虽然不同服务对应了不同的进程，但是因为底层逻辑和存储都是共享的，因此只是提供了非常有限的隔离性。新建和删除服务的成本相对较低。但是每个服务都需要单独的部署，因此服务拆分也不宜太细。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>仓库规模更大，打包、编译、自动化测试等步骤可能更加耗时，一次部署涉及的服务数量会更多。虽然对于单个仓库的操作效率会降低，但是减少了一次需要所涉及的仓库数量，所以整体效率还是提升的。</li><li>多人开发同一仓库的情况变的更加严重，修改冲突的机会变大。大部分的修改应该是局限在一个 module 内部，甚至 module 内的一个 package 内部，通过限制修改范围，可以很大程度上避免冲突。</li><li>因为迭代是以项目为单位，中间的某些稳定模块也会因为其他模块的更改而多次部署。理论上基础架构的改进应当使得部署本身更加轻松和稳定，不会影响到整个系统的稳定。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Domain Driven Design</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GO!GO!GO!</title>
    <link href="/2021/08/19/GO-GO-GO/"/>
    <url>/2021/08/19/GO-GO-GO/</url>
    
    <content type="html"><![CDATA[<p>本文是我个人博客的起点，故多说点废话。</p><p>首先说点最近的个人经历吧，有关于我对目前想要探讨的问题在时间上有个脉络。</p><ul><li>我是在研究生一年级入学前开始学习大数据相关知识，如基本思潮、hdoop、spark等，当时在没有实践基础的情况下，主要的学习内容是相关工具/框架的搭建、编码使用以及技术细节。</li><li>在研究生一年级学习中，又系统地学习了大数据相关更多的知识，如Hive、Hbas、Spark &amp; Spark Streaming、Zookeeper等等，所学内容与之前无异。</li><li>与此同时，由于本人导师的原因，又接触到了许多工程/软件工程/敏捷相关的思想课程，如《精益创业》、看板、Scrum、极限编程等（有愧的是一直没有深入系统的去看过DevOps相关书籍，只是泛泛地看过大佬们的博客，就不当作学习吧）。</li><li>再之后，即2019年上半年在上海的某家公司实习时，由于所处项目正在微服务化改造，故又去系统学习了微服务，主要书籍有《微服务架构设计模式》、《微服务设计》、《Spring 微服务实战》、Martin Flower等大佬们的各种博客，有了微服务，就总有一个绕不过去的坎–如何拆分为服务？之前的这些文章中，都或多或少的讲解过这个问题，也或明或暗的牵扯到了DDD、六边形架构、整洁架构等概念。</li><li>我实习所处的产品组，做的事简单说就是「AI模型部署」，这个过程中涉及到的知识有云计算相关（k8s、网关、灰度/蓝绿/金丝雀部署、集群监控、集群报警）、DevOps相关。</li><li>后续回到学校，又去研究了分布式相关的概念和知识，这里要重重的推荐一本书–《数据密集型应用系统设计》。</li><li>研究生毕业后，我去某国企参加了他们电商项目的微服务化改造项目，与之前的实习相比，这次我去的早，真正的从0到1体验到了到了这个过程。</li><li>工作一年不到，因为一些个人原因，跳槽到了一家互联网企业。在这里，除了日常的业务工作，我们开始了对之前微服务项目的整合（这个后续会细说，又是一个电商迁移项目，但整个公司所面对的问题简单说就是微服务一开始拆的太细了），项目结构是面向DDD的，整个开发过程中的设计策略也是DDD的那一套，我们按下不表。</li></ul><p>说了这么多细枝末节，连云计算和大数据都扯出来了，我这是要干嘛？其实我一直有一种糊涂的感觉，就是我觉得我刚才所说的这些知识，它们是有深刻联系的，在思想上、在技术上都有，我想要理清这个脉络，所以我需要按照一些方式去梳理他。所以我开启了我的博客行，旨在解决个人问题……^_^</p><p>什么联系？</p><p>细节不说，我所学习的大数据知识告诉我最重要的思想是「分而治之」，除此以外，我在学习大数据相关框架/工具的技术细节时，与之后学习分布式相关的知识不谋而合，或者说，大数据相关工具就是对这些分布式理论知识的实践（所以学习分布式时接受的也特别快～）。在微服务的整个学习过程中，分布式的影子无处不。，在思想层面，「分而治之」依旧影响着一切。至于底层的实现细节，微服务与分布式所面对的问题，也有了联系上。还是那个问题，如何拆分微服务？又引出了DDD、六边形架构等等，那么去看这些概念，「分而治之」再一次在另一个维度闪耀。</p><p>这或许就是我目前所能写出的联系吧，但我觉得不止于此处，故现在开始我的学习之旅，在未来的一段时间，我想要探究以下问题。</p><ul><li>微服务、DDD、六边形等架构、DevOps、分布式之间的关系</li><li>这些技术的历史发展</li><li>这些技术的细节探究</li><li>相关架构的研讨</li></ul><p>内容很多，路也很长，我一步一步走，就今年而言，重点放在以下两个系列。</p><ul><li>DDD 理论/实践总结</li><li>以时间轴为视角，总结各架构核心理念（灵感来源）</li></ul><p>那，就开始吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
