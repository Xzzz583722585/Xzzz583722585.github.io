<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>工作笔记</title>
    <link href="/2023/08/19/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/19/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="订单消息中心"><a href="#订单消息中心" class="headerlink" title="订单消息中心"></a>订单消息中心</h2><ol><li>本地消息表：落订单数据表的时候，会利用Mysql的事务机制，保证同时成功落本地消息表，代表之后要发送的通知消息。消息表主要包含订单id、消息状态、消息初始内容、消息最终内容、创建时间、最后发送消息的时间</li><li>重试：调用带有 callback 的 send 方法，可以确认消息是否发送成功。</li><li>幂等性生产者：本地消息表的唯一键保证</li></ol><h2 id="设计模式在订单系统的应用"><a href="#设计模式在订单系统的应用" class="headerlink" title="设计模式在订单系统的应用"></a>设计模式在订单系统的应用</h2><ol><li><p>核心逻辑</p><ul><li>生成器模式<ul><li>分步骤创建复杂对象。</li><li>使用实例<ul><li>创建订单前需要先生成一个复杂的上下文对象，包含订单核心参数、算价结果、用户、用户地址、流程控制信息等，采用生成器模式逐步构建</li></ul></li></ul></li><li>责任链模式<ul><li>沿着处理链的各个节点依次处理请求</li><li>使用实例<ul><li>订单正向流程（创建结算单、创建订单、提交订单）的各类校验，有入参校验、商品信息校验、业务校验等。</li><li>算价会定义一系列又先后计算关系的价格类型，依次进行计算，并生成相应价格 ，最终完成所有价格的计算并输出</li></ul></li></ul></li><li>策略模式<ul><li>相同算法，不同策略会产生不同的结果</li><li>使用实例<ul><li>算价时，每种促销源，会设置其支持的价格类型。根据当前要计算的价格类型，获取不同的促销数据，进而计算价格。</li><li>创建订单时，依次需要准备上下文、校验、锁定资源、落库、落库失败时释放资源、发送通知、打点步骤，其中锁定资源、落库失败时释放资源阶段，根据设置策略不同，会操作不同资源。提交订单情况类似。</li></ul></li></ul></li><li>工厂模式<ul><li>在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</li><li>使用实例<ul><li>分布式锁工厂，底层有RedisLockFactory和EtcdLockFactory两种实现，用于生产锁工具，然后利用锁工具加锁</li></ul></li></ul></li><li>其他<ul><li>使用实例<ul><li>我们并没有实现空对象，但要说的是，我们系统内部使用Money对象封装所有与钱相关的数据，即所有Http、rpc接口接收到的钱必须转为Money对象，所有DB查询到的钱必须转为Money对象，所有落DB的钱的值都由Money对象生成<ul><li>优点<ul><li>保证全局对钱的校验、控制逻辑一致，单位一致</li><li>针对各种价钱的定义也都收敛到此处，方便理解业务</li></ul></li><li>缺点<ul><li>代码复杂，可读性查，加减乘除逻辑丑陋</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>代码迁移</p><ul><li>原型模式<ul><li>复制已有对象</li><li>使用实例<ul><li>逻辑迁移的过程中，有时候会进行AB对比，为了防止长处理链路对入参修改（理论上最好是情况是不要对入参做任何修改，但是有债务问题），从而使新老逻辑互相影响，所以规范对入参做copy，然后传入新老逻辑中。</li><li>clone实现有<ul><li>利用getter、setter写方法实现<ul><li>优点<ul><li>不会出现json序列化的问题，出问题也方便定位排查</li></ul></li><li>缺点<ul><li>代码量大，但是有现成的代码生成器，生成的代码需要check，例如list、map这些集合类型需要包装下</li><li>深拷贝成本高</li></ul></li></ul></li><li>json序列化与反序列化两种（一些新实现的代码规定入参不可修改）<ul><li>优点<ul><li>简单快捷</li></ul></li><li>缺点<ul><li>不完全可靠，会出现一些奇怪的json序列化的问题，很难定位排查</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>适配器模式<ul><li>能使接口不兼容的对象能够相互合作</li><li>使用实例<ul><li>逻辑迁移的过程中，新逻辑定义了一套新接口，为了兼容老逻辑与老接口，采用适配器模式</li></ul></li></ul></li><li>代理模式<ul><li>代理控制着对于原对象的访问</li><li>使用实例<ul><li>系统拆分后，老系统里遗留了老逻辑，不能立即下掉。这时候一是采用代理模式，将请求路由至新系统处理，二是采用适配器模式将新系统提供的新接口适配到老接口</li></ul></li></ul></li></ul></li><li><p>公共的</p><ul><li><p>单例模式</p><ul><li>保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</li><li>使用实例<ul><li>Spring Bean</li></ul></li></ul></li><li><p>迭代器模式</p><ul><li>在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素<ul><li>使用实例<ul><li>java for循环、stream</li></ul></li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring面试题</title>
    <link href="/2023/08/12/spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/08/12/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="什么是-IoC-和-DI"><a href="#什么是-IoC-和-DI" class="headerlink" title="什么是 IoC 和 DI"></a>什么是 IoC 和 DI</h2><p>IoC 控制反转，不是一种具体技术，而是一种设计思想，能指导我们如何设计出松耦合的程序。指的是将我们需要使用的对象交给 IOC 容器进行管理控制，由容器进行注入依赖对象。而不是传统的在类内部主动创建依赖对象并进行组合、管理。</p><p>DI 依赖注入，指的是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度的描述。通俗来说就是 IoC是设计思想，DI是实现方式。</p><h2 id="IoC-bean-的配置方式"><a href="#IoC-bean-的配置方式" class="headerlink" title="IoC bean 的配置方式"></a>IoC bean 的配置方式</h2><ul><li>xml</li><li>@Configuration</li><li>注解<ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul></li></ul><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><ul><li><p>setter 方式</p><ul><li>需要默认构造器</li><li>需要 setter 方法</li></ul></li><li><p>构造器方式（推荐）</p><ul><li>需要对应的构造器</li><li>优点<ul><li>依赖不可变：final关键字</li><li>依赖不为空</li><li>完全初始化的状态：向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步，所以返回来的都是初始化之后的状态。</li><li>没有循环依赖问题：启动时会报错</li></ul></li></ul></li><li><p>注解方式</p><ul><li><p>实现</p><ul><li><p>@Autowired</p><ul><li>Spring 自带的注解</li><li>可以作用在构造函数、方法、方法参数、字段、枚举的常量、注解上</li><li>默认根据类型（byType ）进行自动装配的，如果需要按名称进行装配，则需要配合 @Qualifier</li></ul></li><li><p>@Resource</p><ul><li>在 javax.annotation 包下</li><li>可以作用在接口、类、枚举、注解、方法、字段、枚举的常量上</li><li>默认根据属性名称进行自动装配的，只有当找不到与名称匹配的bean才会按照类型来装配注入</li></ul></li><li><p>@Inject</p><ul><li>在 javax.inject.Inject 包下</li></ul><p>2、可以作用在构造函数、方法、字段、枚举的常量上</p><p>3、默认根据类型（byType ）进行自动装配的，如果需要按名称进行装配，则需要配合 @Named</p></li></ul></li><li><p>缺点</p><ul><li>循环依赖问题</li></ul></li></ul></li></ul><h2 id="IoC初始化流程"><a href="#IoC初始化流程" class="headerlink" title="IoC初始化流程"></a>IoC初始化流程</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-ioc/init.png"></p><ol><li>设置资源解析器和环境</li><li>设置配置路径</li><li>IoC容器对Bean定义资源的载入是从 refresh() 函数开始的：<ol><li>初始化 BeanFactory：在创建 BeanFactory 容器前，如果已经有 BeanFactory 存在，则需要把已有的 BeanFactory 销毁和关闭，以保证在 refresh 之后使用的是新建的 BeanFactory 容器。</li><li>读取 Bean 定义资源</li><li>加载 Bean 定义资源</li><li>解析 Bean 定义资源生成 BeanDefinition</li><li>在IoC容器中注册解析后的 BeanDefinition，本质就是一个 ConcurrentHashMap。至此，配置中的 Bean 已经注册到 IoC 容器中，被容器管理起来了。现在 IoC 容器中已经拥有了所有 Bean 的配置信息。这些配置信息是 IoC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</li></ol></li></ol><h2 id="如何解决循环依赖问题"><a href="#如何解决循环依赖问题" class="headerlink" title="如何解决循环依赖问题"></a>如何解决循环依赖问题</h2><ul><li>单例模式下的属性依赖<ul><li>获取单例对象的流程（三级缓存）<ul><li>首先从一级缓存 singletonObjects 中获取，里面存储的是已经实例化并且完成属性赋值的成熟对象；</li><li>如果一级缓存获取不到，并且对象正在创建中，就再从二级缓存 earlySingletonObjects 中获取，里面存储的是已经实例化但尚未完成属性赋值的半成品对象。创建中指的就是半成品对象。</li><li>如果二级缓存获取不到，且允许从三级缓存中获取半成品对象，就从三级缓存 singletonFactory 中获取。若是三级缓存获取到了，则将单例对象从三级缓存提高到二级缓存中。</li><li>三级缓存中的对象，是在单例对象被实例化后，初始化完成前，被塞入到三级缓存内的。原理就是（A对象属性依赖B对象，B对象属性依赖A对象）：<ul><li>A 首先完成了实例化，而且将自身提早曝光到三级缓存中</li><li>此时 A 进行初始化的第二步，发现本身依赖对象 B，此时就尝试去get(B)，发现 B 还没有被创建，因此去走流程创建 B</li><li>B 在初始化时发现自身依赖对象 A，因而尝试get(A)。尝试一级缓存没有，因为 A 还没初始化完成。尝试二级缓存也没有。尝试三级缓存，由于 A 已经实例化后将自身提早曝光了，因此B可以通过三级缓存拿到A对象的半成品。</li><li>B 拿到A对象后顺利完成初始化，将自身放入到一级缓存中。</li><li>此时返回继续初始化 A，A 此时通过一级缓存能拿到 B 对象，顺利初始化，最终A也完成了初始化，将自身放入到一级缓存中。</li></ul></li></ul></li></ul></li><li>其他情况<ul><li>多实例<ul><li>多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。</li><li>把bean改成单例解决</li></ul></li><li>构造器依赖<ul><li>beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。Spring解决循环依赖主要是依赖三级缓存，但是的在调用构造方法之前还未将其放入三级缓存之中，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。</li><li>使用@Lazy注解解决</li></ul></li></ul></li></ul><h2 id="Bean-作用域"><a href="#Bean-作用域" class="headerlink" title="Bean 作用域"></a>Bean 作用域</h2><ul><li>singleton<ul><li>默认</li><li> IoC容器仅存在一个Bean实例，并一直保存引用</li></ul></li><li>prototype<ul><li>每次从容器中调用Bean时，都会返回一个新的实例</li><li>范围是每次获取Bean直至调用者自行销毁，容器创建好交给使用者之后则不会再管理后续的生命周期。</li></ul></li><li>request<ul><li>每次HTTP请求都会创建一个新的Bean</li><li>范围是每次发起http请求直至请求结束</li></ul></li><li>session<ul><li>首次http请求创建一个实例</li><li>范围是首次发起http请求直至session失效</li></ul></li><li>globalsession</li></ul><h2 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-ioc/bean-life.png"></p><ol><li>一些拓展接口的方法，如 BeanFactoryPostProcessor、InstantiationAwareBeanPostProcessor</li><li>根据配置情况调用 Bean 构造方法实例化 Bean</li><li>利用依赖注入完成 Bean 中所有属性值的配置注入</li><li>一些拓展接口的方法</li><li>调用xxxAware接口 (上图只是给了几个例子) <ul><li>第一类Aware接口：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>第二类Aware接口：EnvironmentAware、EmbeddedValueResolverAware、ApplicationContextAware</li><li>其他</li></ul></li><li>一些拓展接口的方法，如 BeanPostProcessor （与 AOP 有关）</li><li>执行 @PostConstruct 注解的方法</li><li>执行配置的 init-method 初始化方法</li><li>一些拓展接口的方法</li><li>单例 bean 则将该 Bean 放入 IoC 的缓存池中，触发 Spring 对该 Bean 的生命周期管理。多例 bean 则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</li><li>执行 @PreDestro注解的方法</li><li>执行配置的 destory-method 销毁方法</li></ol><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h2><h3 id="什么是连接点-JoinPoint"><a href="#什么是连接点-JoinPoint" class="headerlink" title="什么是连接点 JoinPoint"></a>什么是连接点 JoinPoint</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle1.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle2.png"></p><p>单线程JVM运行java程序，就是从main方法开始，一个方法挨着一个方法，一个方法套着多个方法的调用下去。每个线程都会有自己的私有方法栈，每调用一个方法，就是往这个栈内push一个栈桢，栈桢内保存了方法的基本信息和现场信息。那么，如果我们把同一个栈内的栈桢按先后顺序连接起来，其实就是一个方法的顺序执行流。其中每个方法调用就是一个 连接点 JoinPoint。</p><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle3.png"></p><p>即针对上述的方法执行流，可以横向切割出若干切面 Aspect（就是连接点 JoinPoint），我们面向这些切面进行编程，从而增强功能。AOP 目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中，其本质是为了解耦。</p><h3 id="什么是切入点-PointCut"><a href="#什么是切入点-PointCut" class="headerlink" title="什么是切入点 PointCut"></a>什么是切入点 PointCut</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle5.png"></p><p>我们不会针对每个方法进行增强，所以我们可以挑选感兴趣的连接点进行增强，这些被选择的连接点就是切入点 PointCut。</p><h3 id="AOP如何捕获针对切入点的方法调用"><a href="#AOP如何捕获针对切入点的方法调用" class="headerlink" title="AOP如何捕获针对切入点的方法调用"></a>AOP如何捕获针对切入点的方法调用</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle4.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle6.png"></p><p>既然我们选择了切入点，想对其进行增强，那我们如何感知到切入点被调用了呢？这就是代理模式。</p><p>当我们调用一个实例对象的方法时，都会先经过这个实例对象相应的代理对象， 即执行的控制权先交给代理对象。代理对象内部肯定是要调用实力对象的真实方法的，那就可以在真实方法执行前、执行后、异常时都加入额外的逻辑，这就是AOP的实现原理。</p><h3 id="如何自定义增强逻辑"><a href="#如何自定义增强逻辑" class="headerlink" title="如何自定义增强逻辑"></a>如何自定义增强逻辑</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle7.png"></p><p>我们肯定想要针对不同场景指定不同的增强逻辑，那我们就可以将自定义的增强逻辑包装成针对各个位置的建议 Advice，然后在生成代理对象时将它们织入进去。</p><h3 id="如何实现代理"><a href="#如何实现代理" class="headerlink" title="如何实现代理"></a>如何实现代理</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle8.png"></p><ul><li><p>静态代理</p><ul><li>在编译期间，由工具类甚至是我们自己手动实现代理对象，并替换原实例对象的调用位置，显然非常低效，可拓展性也很差。</li></ul></li><li><p>动态代理</p><p>之前了解过，Spring 容器里的 bean 都是通过 BeanFactory 工厂类创建出来的。那么如果我们指定的是 ProxyFactoryBean 即生成代理类的工厂，那我们便实现了瞒天过海，将所有原本的实例对象替换成了代理对象，并且这些对象都交由 Spring 容器管理，容器可以获知这些代理对象的一切信息与行为。</p><p>最后只剩一个问题，如何动态地生成这些代理对象。</p><ul><li><p>基于JDK面向接口的动态代理JdkDynamicAopProxy生成代理对象</p><p>利用反射Proxy、InvocationHandler动态织入建议，生成代理对象</p></li><li><p>基于Cglib子类继承方式的动态代理CglibAopProxy生成代理对象</p><p>获取原始对象的字节码文件，改写织入建议后，动态加载代理类，并生成代理对象</p></li></ul></li></ul><h2 id="建议类型"><a href="#建议类型" class="headerlink" title="建议类型"></a>建议类型</h2><ul><li>前置通知：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</li><li>后置通知：在某连接点正常完成后执行的通知。</li><li>异常通知：在方法抛出异常退出时执行的通知。</li><li>最终通知：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知：包围一个连接点的通知，如方法调用。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</li></ul><h2 id="多种增强建议的顺序？"><a href="#多种增强建议的顺序？" class="headerlink" title="多种增强建议的顺序？"></a>多种增强建议的顺序？</h2><p>当定义在不同的切面里的两个通知都需要在一个相同的连接点中运行， 那么除非指定优先级，否则执行的顺序是未知的。在进入连接点的情况下，最高优先级的通知会先执行。 在退出连接点的情况下，最高优先级的通知会最后执行。通过 @Order 注解指定优先级，注解值越低优先级越高。</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><ul><li>Model（模型）：处理应用程序数据逻辑的部分</li><li>View（视图）：处理数据显示的部分</li><li>Controller（控制器）：处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><h2 id="请求处理流程（包含-Servlet）"><a href="#请求处理流程（包含-Servlet）" class="headerlink" title="请求处理流程（包含 Servlet）"></a>请求处理流程（包含 Servlet）</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-mvc/servlet.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-mvc/request.png"></p><ol><li><p>客户端（或浏览器）发送请求至主机（201.187.10.21）的端口 8080，被在该端口上监听的 Connector 所接收。</p></li><li><p>Connector 将该请求交给它所在 Service 的 Engine 处理。</p></li><li><p>Engine 获得请求之后，从报文头中提取主机名称（201.187.10.21），在所有虚拟主机 Host 当中寻找匹配。在未匹配到同名虚拟主机的情况下，Engine 将该请求交给名为 localhost 的默认虚拟主机 Host 处理。</p></li><li><p>Host 获得请求之后，根据 URI 匹配 Context，并将请求交给其处理。</p></li><li><p>Context 构建 HttpServletRequest、HttpServletResponse 对象，将其作为参数传给 Servlet 应用，由应用完成业务逻辑执行、结果数据存储等过程。</p><p>下面讲的 DispatcherServlet 就是上述的 Servlet 实例：</p><ol><li>客户端请求 -&gt; DispatcherServlet：DispatcherServlet 作为统一访问点，进行全局的流程控制，收到请求后自己不进行处理，而是委托给具体的处理器进行处理。</li><li>DispatcherServlet -&gt; HandlerMapping：HandlerMapping 根据 HTTP 请求的 URI 映射到 HandlerExecutionChain 对象，包含一 个Handler 处理器对象、多个 HandlerInterceptor 拦截器对象。</li><li>DispatcherServlet -&gt; HandlerAdapter：HandlerAdapter 是底层多种类型的处理器的适配器，屏蔽掉底层差异。</li><li>HandlerAdapter -&gt; 具体处理器 Handler（如 Controller）：HandlerAdapter 将会根据适配的结果调用真正的处理器方法处理请求，并返回一个 ModelAndView 对象。在调用处理器 Handler 之前其拦截器的方法 preHandler() 会执行。在调用处理器 Handler 之后其拦截器的方法 postHandler() 会执行。</li><li>Handler -&gt; DispatcherServlet：DispatcherServlet 根据返回的 ModelAndView 选择适合的视图解析器 ViewResolver。</li><li>DispatcherServlet -&gt; ViewResolver：ViewResolver 把逻辑视图名解析为具体的 View。</li><li>View -&gt; 渲染：View 会根据传进来的 Model 模型数据进行渲染。</li><li>DispatcherServlet -&gt; 客户端响应：DispatcherServlet 返回渲染后的响应给用户，至此请求处理结束。</li></ol></li><li><p>Context 接收到应用返回的 HttpServletResponse 对象之后将其返回给 Host。</p></li><li><p>Host 将 HttpServletResponse 对象返回给 Engine。</p></li><li><p>Engine 将 HttpServletResponse 对象返回 Connector。</p></li><li><p>Connector 将 HttpServletResponse 对象返回给客户端（或浏览器）</p></li></ol><h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><ol><li>实例化 new：服务器第一次被访问时，加载一个Servlet容器，而且只会被加载一次。</li><li>初始化 init：创建完Servlet容器后，会调用仅执行一次的 init() 初始化方法，用于初始化Servlet对象，无论多少台客户端在服务器运行期间访问都不会再执行 init() 方法。</li><li>执行处理 service：HttpServlet 的抽象类提供了doGet()、doPost() 等方法，对应了request请求的发送方法。</li><li>销毁 destroy：在服务器关闭或重启时，Servlet会调用 destroy 方法来销毁，将Servlet容器标记为垃圾文件，让 GC 回收。</li></ol><h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><h2 id="如何实现事务开启、提交、回滚"><a href="#如何实现事务开启、提交、回滚" class="headerlink" title="如何实现事务开启、提交、回滚"></a>如何实现事务开启、提交、回滚</h2><p>一般情况下，Mysql都会设置autocommit=1，即开启事务自动提交。这种情况下，我们单独执行一个sql就会把它包裹在一个事务中，所以我们需要显示的开启一个事务，然后显示提交或回滚事务。</p><ul><li><p>编程式实现事务</p><p>我们通过 transactionManager.getTransaction 方法开启一个事务，并在其中用 try…catch 包裹我们的业务代码，如果所有业务代码顺利执行，那么就执行 transactionManager.commit 提交事务，否则如果业务代码抛出异常，就在 catch 块中执行 transactionManager.rollback 回滚事务。</p></li><li><p>声明式事务管理</p><p>@Transactional 底层就是通过 AOP，将被注解的业务方法，用上述编程式事务实现一遍。@Transactional 注解的使用范围：</p><ul><li>方法<ul><li>推荐</li><li>只能应用到 public 方法上，否则不生效。原因是 AOP 底层有 JDK 和 CGlib 两种实现方式，其中 JDK 基于接口实现，所以都是 public 方法，CGlib 基于继承实现，可以是 public、protected、package 方法。综合起来，@Transactional 只支持 public 方法</li></ul></li><li>类<ul><li>对该类中所有的 public 方法都生效</li></ul></li><li>接口<ul><li>不推荐</li></ul></li></ul></li></ul><h2 id="如何管理事务"><a href="#如何管理事务" class="headerlink" title="如何管理事务"></a>如何管理事务</h2><h2 id="Transactional-属性"><a href="#Transactional-属性" class="headerlink" title="@Transactional 属性"></a>@Transactional 属性</h2><ul><li><p>传播行为</p><p>需要主要，这些传播行为都是依赖异常检测的，所以分析实际问题时，需要考虑上异常的检查情况。</p><ul><li>以事务方式执行<ul><li>REQUIRED<ul><li>如果当前存在事务，就加入这个事务。</li><li>如果当前不存在事务，就新开启事务。</li></ul></li><li>REQUIRES_NEW<ul><li>如果当前存在事务，就把当前事务挂起。</li><li>如果当前不存在事务，就新开启事务。</li></ul></li><li>NESTED<ul><li>如果当前存在事务事务，就开启嵌套事务，即父子事务<ul><li>父事务提交，子事务才能提交，子事务不能单独提交</li><li>父事务回滚，子事务也要回滚，子事务可以单独回滚</li></ul></li><li>如果当前不存在事务，就新开启事务。</li></ul></li><li>MANDATORY<ul><li>如果当前存在事务，就加入这个事务。</li><li>如果当前不存在事务，就抛出异常。</li></ul></li></ul></li><li>以非事务方式执行<ul><li>SUPPORTS</li><li>NOT_SUPPORTED</li><li>NEVER</li></ul></li></ul></li><li><p>隔离级别</p><ul><li>DEFAULT<ul><li>使用底层数据库的默认隔离级别<ul><li>Mysql 默认可重复读</li><li>Oracle 默认提交读</li></ul></li></ul></li><li>未提交读</li><li>提交读</li><li>可重复读</li><li>可串行化</li></ul></li><li><p>超时时间</p><ul><li>默认值为-1（不会超时）</li><li>如果超过该时间限制但事务还没有完成，则自动回滚事务。</li></ul></li><li><p>是否为只读事务</p><ul><li>默认值为 false。</li><li>提供一些优化，例如 sql 合并，多条相关的 sql 只发出一条</li><li>比如在多条读sql情况下，要求他们看到的数据一致，则需要开启事务</li></ul></li><li><p>能够触发事务回滚的异常类型</p><ul><li>默认情况只有 Error 和 RuntimeException 会触发回滚</li></ul></li></ul><h2 id="Spring-事务失效场景"><a href="#Spring-事务失效场景" class="headerlink" title="Spring 事务失效场景"></a>Spring 事务失效场景</h2><ul><li>底层数据库不支持事务</li><li>事务所在类未被 Spring 容器管理</li><li>AOP 自调用问题</li><li>没有加在 public 方法上</li><li>没有正确设置传播行为和回滚异常类型属性</li></ul><h1 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring boot"></a>Spring boot</h1><h2 id="Spring-boot-特点"><a href="#Spring-boot-特点" class="headerlink" title="Spring boot 特点"></a>Spring boot 特点</h2><ul><li>自动装配</li><li>嵌入式 Tomcat Web 服务器，不需要手动配置服务器</li><li>已经打包好的 starter</li></ul><h2 id="Spring-自动装配原理（-SpringBootApplication-原理）"><a href="#Spring-自动装配原理（-SpringBootApplication-原理）" class="headerlink" title="Spring 自动装配原理（@SpringBootApplication 原理）"></a>Spring 自动装配原理（@SpringBootApplication 原理）</h2><p>避免了繁琐的 xml 配置、Java 配置，大大简化了配置工作。</p><ul><li>@EnableAutoConfiguration<ul><li>开启自动装配</li><li>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中的配置信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。我们引入的各类 xxx-starter 包，就是实现了这套规范的 jar 包。</li></ul></li><li>@Configuration<ul><li>允许在上下文中注册额外的 bean 或导入其他配置类</li><li>如果我们加载所有引入包的，那系统未免太臃肿了。所以可以设置 @ConditionalOnXXX 注解，在指定条件满足时才会加载本配置类的内容。</li></ul></li><li>@ComponentScan<ul><li>扫描并加载指定路径下（默认扫描启动类所在包下的所有类），被 @Component、@Controller、@Service、@Repository 注解的类</li><li>可以自定义排除某些类</li></ul></li></ul><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/design-pattern/Singleton.png"></p><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>懒汉式 - 线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉式 - 线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加锁范围过大，影响直接获取，性能问题，不推荐使用</p></li><li><p>懒汉式 - 双重锁校验 - 线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 new Singleton() 会涉及指令重排，导致可能会有线程获取未初始化完成的对象，所以需要加 volatile 关键字，避免指令重排。</p><p>实现复杂，不推荐使用。</p></li><li><p>饿汉式 - 线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>丢失了延迟实例化带来的好处</p></li><li><p>静态内部类实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 Singleton 类被加载时，静态内部类不会被加载进内存。只有当调用静态内部类的方法，从而触发静态内部类被加载，此时才会初始化单例对象，并且 JVM 能确保只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p></li><li><p>枚举实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>  上述方法中只有枚举实现可以防止反射攻击，并且是线程安全的。枚举实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p></li></ul><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java并发</title>
    <link href="/2023/08/09/java%E5%B9%B6%E5%8F%91/"/>
    <url>/2023/08/09/java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm.png"></p><p>Java内存模型规定了所有变量（实例字段，静态字段和构成数组中的元素，不包括线程私有的局部变量和方法参数）都存储在主内存。每条线程都有自己的工作内存，用来保存被该线程使用的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间无法之间访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><h2 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/operate.png"></p><ul><li>lock（锁定)：锁定主内存变量，表示为线程独占状态</li><li>unlock（解锁)：释放主内存变量</li><li>read（读取)：把一个变量的值从主内存传输到线程的工作内存中</li><li>load（载入)：把 read 操作从主内存中得到的变量值放到工作内存中的变量副本中</li><li>use（使用)：执行引擎读取工作内存中的一个变量副本</li><li>assign（赋值)：执行引擎更新工作内存中的一个变量副本</li><li>store（赋值)：把一个变量副本从线程的工作内存传输到主内存中</li><li>write（赋值)：把 store 操作从工作内存中得到的变量值放到主内存中</li></ul><h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><ol><li>原子性<ul><li>内存交互操作具有原子性。对一个 int 类型的变量执行 assign 赋值操作，具备原子性。但对 64 位数据类型（long，double）的操作会划分为两次 32 位的操作来进行，不具备原子性</li><li> synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit</li></ul></li><li>可见性：可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的<ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存</li><li>final</li></ul></li><li>有序性：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序<ul><li>volatile</li><li>synchronized 保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码</li></ul></li></ol><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><ol><li><p>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Single-Thread-rule.png"></p></li><li><p> 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</p></li></ol><p>   <img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Monitor-Lock-Rule.png"></p><ol start="3"><li><p>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Volatile-Variable-Rule.png"></p></li><li><p>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Thread-Start-Rule.png"></p></li><li><p>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Thread-Join-Rule.png"></p></li><li><p>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始</p></li><li><p>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</p></li></ol><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障，是一类同步屏障指令，是CPU或编译器在对内存随机访问的一个同步点，使得此点之前的所有读写操作操作都执行后才可以开始执行此点之后的操作。</p><ul><li>LoadLoad：保证 Load1 的读取操作在 Load2 及其之后的读取操作之前执行</li><li>LoadStore：在 Store2 及其后的写入操作执行之前，保证 Load1 的读取操作已读取结束</li><li>StoreStore：在 Store2 及其后的写入操作执行之前，保证 Store1 的写入操作已刷新到主内存</li><li>StoreLoad：在 Load2 及其后的读取操作执行之前 ，保证Store1 的写入操作已刷新回主内存</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>可见性：volatile保证被修饰的变量的可见性，但不保证是线程安全的，因为操作变量的运算不一定是线程安全的<ul><li>每次使用V前都必须先从主内存刷新最新值，使用LoadLoad、LoadStore实现</li><li>每次修改V后都必须立即同步回主内存，使用StoreLoad、StoreStore实现</li></ul></li><li>禁止指令重排：保证代码执行顺序和程序书写顺序一致</li></ul><h2 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h2><p>线程安全指的是多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><ol><li><p>不可变</p><ul><li><p>类型</p><ul><li><p>final 关键字修饰的基本数据类型</p></li><li><p>String</p></li><li><p>枚举类型</p></li><li><p>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</p></li><li><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p></li></ul></li></ul></li><li><p>阻塞同步（互斥同步）：</p><ul><li>属于悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作</li><li>主要问题是线程阻塞和唤醒所带来的性能问题</li><li>类型<ul><li>synchronized<ul><li>性能和ReentrantLock差不多</li><li>JVM实现</li><li>等待不可中断</li><li>不公平</li><li>不支持同时绑定多个条件</li></ul></li><li>ReentrantLock：同一个线程可以反复进入锁，在释放锁时，也必须释放相同的次数<ul><li>JDK实现</li><li>等待可中断</li><li>默认不公平，也可以公平</li><li>可以同时绑定多个条件</li></ul></li></ul></li></ul></li><li><p>非阻塞同步</p><ul><li>属于基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）</li><li>不需要阻塞线程</li><li>类型<ul><li>CAS：只有当 V 的值等于 A，才将 V 的值更新为 B<ul><li>原子类AtomicInteger：调用了 Unsafe 类的 CAS 操作</li><li>ABA问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。通过增加变量版本来解决。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比带有时间戳（版本）的原子类更高效</li></ul></li></ul></li></ul></li><li><p>无同步方案</p><ul><li><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</p></li><li><p>类型</p><ul><li><p>栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私</p></li><li><p>线程本地存储（Thread Local Storage）</p><ul><li><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。经典 Web 交互模型中的“一个请求对应一个服务器线程”处理方式，使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题</p></li><li><p>java.lang.ThreadLocal：每个线程都维护一个ThreadLocal.ThreadLocalMap对象。当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal -&gt; value 键值对插入到该 Map 中。ThreadLocal 有内存泄漏风险，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/thread-local.png"></p></li></ul></li><li><p>可重入代码（纯代码）：可以在执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p></li></ul></li></ul></li></ol><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><ol><li>自旋锁<ul><li>进入阻塞状态的开销很大。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</li><li>自适应自旋，意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定</li></ul></li><li>锁消除<ul><li>消除不可能存在竞争的共享数据的锁。通过逃逸分析实现，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</li></ul></li><li>锁粗化<ul><li>如果一系列的连续操作都对同一个对象反复加锁和解锁，就会导致性能损耗，可以把加锁的范围扩展到整个操作序列的外部。</li></ul></li><li>轻量级锁<ul><li>锁的四个状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</li><li>虚拟机对象头数据称为 Mark Word，其中记录了该对象作为加锁对象的锁状态。</li><li>加锁：当前线程尝试获取一个锁对象时，如果锁对象是未锁定状态，那么当前线程就会在他的虚拟机栈桢中创建 Lock Record ，用于存放锁对象的 Mark Word 副本。然后，虚拟机会尝试使用 CAS 操作将锁对象的 Mark Word 更新为指向当前线程 Lock Record 的指针。如果 CAS 操作成功了，那么就代表当前线程获取了该对象上的锁，并且该对象处于轻量级锁状态。如果 CAS 操作失败了，虚拟机首先会检查该对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行。否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要尝试加重量级锁，锁对象状态变为重量级锁状态。</li><li>解锁：如果锁对象的 Mark Word 仍然指向线程的 Lock Record，那就尝试用CAS操作将线程的 Lock Record上的 Mark Word 副本拷贝回来。如果CAS成功，那么解锁成功。如果CAS失败，说明有其他线程尝试过获取该锁，那么就要在解锁的同时，唤醒被挂起的线程</li></ul></li><li>偏向锁<ul><li>偏向锁的思想是偏向于让第一个获取锁对象的线程，再次获取该锁时就不再需要进行CAS 操作、同步操作。</li><li>当锁对象第一次被某个线程获取时，进入偏向状态。同时使用 CAS 操作将线程 ID 记录到锁对象的 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何CAS、同步操作。当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向状态，膨胀到到未锁定状态或者轻量级锁状态。</li></ul></li></ol><h2 id="开发时加锁建议"><a href="#开发时加锁建议" class="headerlink" title="开发时加锁建议"></a>开发时加锁建议</h2><p>原理：降低各种意义的锁范围，包括时间、空间、类型，以降低锁冲突概率，提高系统并发能力</p><ol><li>减小锁持有时间</li><li>减小锁粒度</li><li>使用读写分离锁：适用于读多写少的场景，因为写会复制数据</li><li>锁粗化：减少频繁加锁的开销</li></ol><h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="实现线程"><a href="#实现线程" class="headerlink" title="实现线程"></a>实现线程</h2><ul><li><p>实现 Runnable 接口</p><ul><li>run() 没有返回值</li></ul></li><li><p>实现 Callable 接口</p><ul><li>call() 有返回值</li></ul></li><li><p>继承 Thread 类</p><ul><li>缺点<ul><li>run() 方法内部就是调用 Runnable 接口，所以更推荐实现 Runnable 接口，更加合理</li><li>实际只需要指定线程任务，继承整个类开销过大</li><li>Java 只支持单继承</li></ul></li></ul></li></ul><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><ul><li><p>一般线程执行完任务后就会结束</p></li><li><p>stop()</p><ul><li>Thread 方法</li><li>立即结束线程，并释放所持有的锁</li><li>不推荐使用</li></ul></li><li><p>interrupt()  设置中断标志</p><ul><li>Thread 方法</li><li>任务内部通过 interrupted() 判断中断标记，以便合理退出</li></ul></li><li><p>shoutdown()</p><ul><li>ExecutorService 方法</li><li>会等待任务都执行完毕之后再关闭，不会接受新任务</li></ul></li><li><p>shoutdownNow()</p><ul><li>ExecutorService 方法</li><li>尝试停止所有正在执行的任务，停止等待任务的处理，不会接受新任务</li></ul></li></ul><h2 id="基础机制"><a href="#基础机制" class="headerlink" title="基础机制"></a>基础机制</h2><ul><li>sleep()<ul><li>让线程休眠若干时间，如果休眠中被中断，会抛 InterruptedException 异常</li><li>睡眠时不会释放所持有的锁</li></ul></li><li>yield()<ul><li>会使当前线程让出 CPU，但让出后还会进行 CPU 竞争</li><li>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</li></ul></li><li>守护线程 Daemon<ul><li>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</li></ul></li></ul><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><ul><li>join()<ul><li>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</li><li>本质是让当前线程 wait() 目前线程</li></ul></li><li>wait() notify() notifyAll()<ul><li>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</li><li>它们都属于 Object 的一部分，而不属于 Thread。</li><li>只能用在 synchronized 方法或者 synchronized 块中使用，否则会在运行时抛出 IllegalMonitorStateException</li><li>等待时会释放所持有的锁</li></ul></li><li>await() signal() signalAll()<ul><li>JUC 中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</li><li>使用时，要求线程持有可重入锁</li><li>等待时会释放所持有的锁</li></ul></li></ul><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="可重入锁-ReetrantLock"><a href="#可重入锁-ReetrantLock" class="headerlink" title="可重入锁 ReetrantLock"></a>可重入锁 ReetrantLock</h2><p>见上</p><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>广义上说，信号量是对锁的拓展。无论是 synchronized 还是 ReetrantLock，都只允许同时一个线程访问资源，而信号量允许同时多个线程访问资源。</p><ul><li>获取资源 acquire()</li><li>释放资源 release()</li></ul><h2 id="读写分离锁-ReadWriteLock"><a href="#读写分离锁-ReadWriteLock" class="headerlink" title="读写分离锁 ReadWriteLock"></a>读写分离锁 ReadWriteLock</h2><p>略</p><h2 id="倒计时器-CountDownLatch"><a href="#倒计时器-CountDownLatch" class="headerlink" title="倒计时器 CountDownLatch"></a>倒计时器 CountDownLatch</h2><p>用来控制一个或者多个线程等待多个线程。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><h2 id="循环栅栏-CyclicBarrier"><a href="#循环栅栏-CyclicBarrier" class="headerlink" title="循环栅栏 CyclicBarrier"></a>循环栅栏 CyclicBarrier</h2><p>和 CountdownLatch 相似。区别是 CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><h1 id="并行模式"><a href="#并行模式" class="headerlink" title="并行模式"></a>并行模式</h1><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>当我们调用一个方法时，如果这个方法执行很慢，那我们就需要等待。但有时候，我们并不着急获取结果。此时，这个很慢的方法可以先返回一个伪结果，调用方拿到伪结果后先处理其他任务，在真正需要伪结果的数据时再去尝试获取。这样就充分利用了等待慢方法的时间，提高了系统的响应速度。</p><p>java 中的 Future 接口就定义了这个伪结果，通过 get() 可以获取真实数据。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&lt;V&gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><p>可以实现 Callable 接口，获取真实数据，设置进 FutureTask 内。将 FutureTask 通过 ExecutorService.submit() 方法提交给线程池执行。在需要真实数据的时候通过 get() 方法获取真实数据。</p><p>需要注意， FutureTask 实现的是 Runnable，即没有返回值，返回值是通过 get() 方法获取的，注意与 Callable 区分</p><h2 id="CompleteFuture"><a href="#CompleteFuture" class="headerlink" title="CompleteFuture"></a>CompleteFuture</h2><ul><li>实现了 Future 接口</li><li>高效的线程回调机制</li><li>线程编排</li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>线程复用：降低资源消耗、提高获取线程的速度</li><li>控制线程数量</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/juc/executor.png"></p><ul><li>Executor<ul><li>execute() 方法接收一个实现 Runnable 接口的对象，没有返回值</li></ul></li><li>ExecutorService<ul><li>submit() 方法接受一个实现 Callable 接口的对象，返回 Future 对象</li><li>添加了管理任务的生命周期方法</li></ul></li><li>ScheduleExecutorService<ul><li>schedule() 方法接受一个实现 Runnable 接口的对象，并设置延时时间或定期间隔，返回 SchduleFuture 对象</li><li>支持延时、定期执行任务</li></ul></li><li>Executors<ul><li>创建各类线程池的工厂类</li></ul></li></ul><h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><ul><li>Fixed<ul><li>固定数量：核心线程数 = 最大线程数 = n</li><li>无界队列：LinkedBlockingQueue</li></ul></li><li>Single<ul><li>固定数量1：核心线程数 = 最大线程数 = 1</li><li>无界队列：LinkedBlockingQueue</li></ul></li><li>Cached<ul><li>根据实际需要创建新线程：核心线程数 = 0，最大线程数 = Integer.MAX_VALUE</li><li>直接提交队列</li></ul></li><li>Scheduled<ul><li>固定数量：核心线程数 = n，最大线程数 = Integer.MAX_VALUE</li><li>支持延时、定期任务</li></ul></li><li>SingleScheduled<ul><li>固定数量1：核心线程数 = 1，最大线程数 = Integer.MAX_VALUE</li><li>支持延时、定期任务</li></ul></li></ul><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><ul><li>核心线程数</li><li>最大线程数</li><li>超过核心线程数的多余线程的存活时间</li><li>存活时间单位</li><li>任务队列<ul><li>直接提交队列 SynchronousQueue：没有容量，直接提交给线程处理。如果没有空闲线程，则尝试创建新线程执行任务。如果线程数达到最大线程数，则执行拒绝策略。</li><li>有界队列 ArrayBlockingQueue<ul><li>如果当前线程数小于核心线程数，则创建新线程执行任务</li><li>如果当前线程数大于核心线程数，则任务加入队列</li><li>如果任务队列已满，并且当前线程数小于最大线程数，则创建新线程执行任务</li><li>如果任务队列已满，并且当前线程数大于最大线程数，则执行拒绝策略</li></ul></li><li>无界队列 LinkedBlockingQueue<ul><li>如果当前线程数小于核心线程数，则创建新线程执行任务</li><li>如果当前线程数大于核心线程数，则任务加入队列</li><li>任务队列不会满，直到耗尽系统内存</li></ul></li><li>优先任务队列 PriorityBlockingQueue<ul><li>特殊的无界队列</li><li>无论是游街队列还是无界队列，都按先进先出规则处理任务，优先任务队列可以设置优先级</li></ul></li></ul></li><li>线程工厂</li><li>拒绝策略<ul><li>直接抛异常</li><li>在调用者线程中运行当前被丢弃的任务</li><li>丢弃最老的任务，并尝试再次提交当前任务</li><li>直接丢弃</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java面试题</title>
    <link href="/2023/08/01/java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/08/01/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="java-容器"><a href="#java-容器" class="headerlink" title="java 容器"></a>java 容器</h2><ul><li>Collection<ul><li>List<ul><li>ArrayList<ul><li>动态数组实现</li><li>优点：读速度快，随机搜索</li><li>缺点：写速度慢，涉及移动大量数组元素</li></ul></li><li>Vector<ul><li>synchronized实现的ArrayList的线程安全版本</li></ul></li><li>CopyOnWriteArrayList<ul><li>synchronized实现的线程安全列表</li><li>为了增加并发度，读写分离，写数据时会copy一份新数组，在新数组上修改，修改完后用新数组代替原数组。读数据总在原数组执行</li></ul></li><li>LinkedList<ul><li>双向链表实现，但实际使用中与ArrayList性能区别不大</li><li>优点：写速度快，O(1)</li><li> 缺点：读速度慢，只能顺序搜索</li></ul></li></ul></li><li>Queue<ul><li>LinkedList</li><li>PriorityQueue：堆</li><li>BlockingQueue：阻塞队列，用于线程池。当线程处理完队列中的任务时，会进行等待，当有新任务加入队列时，队列会将线程唤醒</li></ul></li><li>Set<ul><li>TreeSet：TreeMap</li><li>HashSet：HashMap</li><li>LinkedHashSet：LinkedHashMap</li></ul></li></ul></li><li>Map<ul><li>TreeMap：红黑树，有序</li><li>HashMap<ul><li>插入：hash()取模获得桶下标，利用拉链法解决hash冲突</li><li>查询：hash()取模获得桶下标，遍历下标对应的链表或红黑树，利用equals()找到目标元素</li><li>链表长度为8转红黑树，红黑树长度为6时转链表<ul><li>目的是优化查询速率，但又避免维护复杂数据结构</li><li>6与8是为了避免在临界值频繁转换数据结构</li></ul></li><li>桶大小为 2^n<ul><li>方便二进制取模 x &amp; (size-1)</li><li>方便扩容时快速计算新下标，例如现桶大小为2^5，扩容为2^6，那么判断元素第5位为1，新下标就是现下标*2，为0就等于现下标</li></ul></li><li>版本改进<ul><li>JDK 1.7<ul><li>链表</li><li>头插法：并发环境会造成环</li></ul></li><li>JDK 1.8<ul><li>链表 + 红黑树</li><li>尾插法：但是并发环境依然建议使用 ConcurrentHashMap</li></ul></li></ul></li></ul></li><li>LinkedHashMap<ul><li>利用双向链表维护了元素顺序<ul><li>FIFO</li><li>LRU</li></ul></li></ul></li><li>HashTable<ul><li>synchronized实现的HashMap的线程安全版本</li><li>对整个集合上锁</li></ul></li><li>ConcurrentHashMap<ul><li>1.8前<ul><li>先分组segment，每组有独立的桶</li><li>每个segment都是ReetrantLock的实现，对整个桶上锁</li></ul></li><li>1.8后<ul><li>类似于HashMap，但是添加元素时，若下标为null，则利用CAS加锁，若下标后面有链表或红黑树，则利用synchronized对头节点加锁</li><li>实际上也是分了组</li></ul></li></ul></li><li>WeakHashMap<ul><li>弱引用实现的HashMap，里面的元素可能在下次gc时被回收</li><li>应用：tomcat的ConcurrentCache缓存<ul><li>分代存储<ul><li>新生代数据利用WeakHashMap维护，可能会被回收</li><li>老年代数据利用ConcurrentHashMap维护，不会被回收</li><li>新加入的数据放进新生代，被读取后放入老年代</li><li>老年代空间不足都会被放回新生代，然后会回收</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="fail-fast-与-fail-safe"><a href="#fail-fast-与-fail-safe" class="headerlink" title="fail-fast 与 fail-safe"></a>fail-fast 与 fail-safe</h2><ul><li>fail-fast：遍历集合时，若同时修改集合，则会立即抛异常</li><li>fail-safe：修改集合会复制一份数据进行修改，不会影响查询</li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><p>I/O操作步骤：</p><ol><li>将数据从I/O设备读取到内核缓冲区</li><li>将数据从内核缓冲区拷贝到用户态应用程序缓冲区</li><li>应用程序从用户态应用程序缓冲区中直接使用数据</li></ol><h2 id="普通-BIO"><a href="#普通-BIO" class="headerlink" title="普通 BIO"></a>普通 BIO</h2><ul><li>第一步、第二步阻塞</li><li>面向流</li><li>优点<ul><li>程序简单</li></ul></li><li>缺点<ul><li>吞吐量低</li></ul></li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><ul><li>第一步非阻塞，第二步阻塞</li><li>面向块</li><li> I/O 多路复用</li><li>优点<ul><li>第一步非阻塞，吞吐量高较好</li><li> I/O 多路复用可以同时处理多个I/O设备请求</li><li> 使用到零拷贝</li></ul></li><li>缺点<ul><li>面向块编程，程序复杂 </li><li>I/O 多路复用轮询消耗CPU资源</li><li>第二步依然阻塞</li></ul></li></ul><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><ul><li><p>第一步、第二步非阻塞</p></li><li><p>优点</p><ul><li>吞吐量高</li></ul></li><li><p>缺点</p><ul><li>程序复杂 </li><li>1.7后才开始支持，底层操作系统支持也不普及</li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="为什么byte、short、boolean、char都使用int来存储"><a href="#为什么byte、short、boolean、char都使用int来存储" class="headerlink" title="为什么byte、short、boolean、char都使用int来存储"></a>为什么byte、short、boolean、char都使用int来存储</h2><p>由于java虚拟机的操作码只有一字节长，所以如果每种与数据类型相关的指令都需要支持所有运行时数据类型的话，会远远超出一字节所能表示的数量范围。因此，编译器会在编译期或运行期将byte、short、boolean、char类型数据都拓展为int类型数据存储，从而直接使用int类型的字节码指令。</p><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><ul><li>C#实现的泛型基于类型膨胀，是真实泛型：List&lt;Integer&gt;和List&lt;String&gt;就是两个类型，在系统运行期间，有自己的虚方法表和类型数据</li><li>Java实现的泛型基于类型擦除，是伪泛型：List&lt;Integer&gt;和List&lt;String&gt;都是List&lt;Object&gt;类型，在系统运行期间，在相应的使用位置加上强制转型</li></ul><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>转化为对应的包装与还原方法</p><h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><p>还原为迭代器实现</p><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>数据类型参数</p><h2 id="java-排序算法"><a href="#java-排序算法" class="headerlink" title="java 排序算法"></a>java 排序算法</h2><p>优化方向：</p><ul><li>稳定性考虑<ul><li>基本类型不考虑稳定性，使用快速排序</li><li>引用类型因为不清楚具体业务场景，考虑稳定性，使用归并排序</li></ul></li><li>利用 O(logN) 和 O(n^2) 各自的优势<ul><li>O(logN) 适合大数据量</li><li>O(n^2) 适合大数据量</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM面试题</title>
    <link href="/2023/07/30/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/07/30/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><h2 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h2><p>当前线程所执行字节码的行号指示器</p><h2 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h2><p>为Java方法服务。每个方法在执行时都会往栈中push一条栈桢：局部变量表、操作数栈、动态链接、方法出口等。若线程请求深度大于虚拟机所允许的深度，会产生StackOverslowError。</p><h2 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h2><p>和虚拟机栈类似，为Native方法服务。</p><h2 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h2><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。若方法区无法满足内存分配要求，则会抛出OutOfMemoryError。</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区的一部分。编译器生成的字面量和符号引用会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h2 id="堆（线程共享）"><a href="#堆（线程共享）" class="headerlink" title="堆（线程共享）"></a>堆（线程共享）</h2><p>用于存放对象实例。若堆无法满足内存分配要求，并且无法拓展堆大小，则会抛出OutOfMemoryError。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><ol><li>引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</li><li>可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。GC Roots 一般包含以下内容<ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul></li></ol><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型：</p><ul><li>强引用<ul><li>被强引用关联的对象不会被回收</li><li>使用 new 一个新对象的方式来创建强引用</li></ul></li><li>软引用<ul><li>被软引用关联的对象只有在内存不够的情况下才会被回收</li><li>使用 SoftReference 类来创建软引用</li></ul></li><li>弱引用<ul><li>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</li><li>使用 WeakReference 类来创建弱引用</li></ul></li><li>虚引用<ul><li>又一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</li><li>使用 PhantomReference 来创建虚引用。</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li><p>标记 - 清除</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/mark-clean.png"></p><ul><li>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</li><li>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</li><li>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表</li><li>缺点：<ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul></li></ul></li><li><p>标记 - 整理</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/mark-compact.png"></p><ul><li>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</li><li>在整理阶段，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li><li>优点：<ul><li>不会产生内存碎片</li></ul></li><li>缺点：<ul><li>需要移动大量对象，处理效率比较低。</li></ul></li></ul></li><li><p>复制</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/repeat.png"></p><ul><li>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</li><li>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。</li><li>缺点：<ul><li>内存利用率只有一半</li></ul></li></ul></li><li><p>分代收集</p><ul><li>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。<ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul></li></ul></li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/garbage-collector.jpg"></p><ol><li><p>Serial 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/Serial.jpg"></p><ul><li>串行，即垃圾收集器与用户程序交替执行</li><li>单线程</li><li>优点<ul><li>简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率</li></ul></li></ul></li><li><p>ParNew 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/ParNew.jpg"></p><ul><li>Serial 收集器的多线程版本<ul><li>串行，即垃圾收集器与用户程序交替执行</li><li>多线程</li></ul></li></ul></li><li><p>Parallel Scavenge 收集器</p><ul><li>与 ParNew 一样是多线程收集器</li><li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</li><li>GC 自适应的调节策略：拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</li></ul></li><li><p>Serial Old 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/Serial-Old.jpg"></p><ul><li>是 Serial 收集器的老年代版本</li><li>标记 - 整理算法</li><li>串行，即垃圾收集器与用户程序交替执行</li><li>单线程</li></ul></li><li><p>Parallel Old 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/Parallel-Old.jpg"></p><ul><li>是 Parallel Scavenge 收集器的老年代版本</li><li>标记 - 整理算法</li><li>串行，即垃圾收集器与用户程序交替执行</li><li>多线程</li></ul></li><li><p>CMS 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/CMS.jpg"></p><ul><li>标记 - 清除算法</li><li>流程：<ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul></li><li>缺点：<ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul></li></ul></li><li><p>G1 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/G1.jpg"></p><ul><li><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个年轻代或者老年代，而 G1 通过年轻代收集集合和混合收集集合，可以单独收集年轻代，或者对年轻代和老年代一起回收。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/generations.png"></p><p>G1 把堆划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离，他们都是一部分Region的集合。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/G1-heap-allocation.png"></p><p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个 Region 都记录了一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。需要注意，对年轻代进行整体收集，因此引用源自年轻代的对象，不需要在RSet中记录。只有老年代的分区可能会有RSet记录。</p></li><li><p>流程：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul></li><li><p>优点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul></li></ul></li></ol><h2 id="CMS与G1的并发标记算法-三色标记法"><a href="#CMS与G1的并发标记算法-三色标记法" class="headerlink" title="CMS与G1的并发标记算法 - 三色标记法"></a>CMS与G1的并发标记算法 - 三色标记法</h2><p>CMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。</p><ul><li>白色是未标记</li><li>灰色自身被标记，所有引用的对象没有完全被标记</li><li>黑色自身与所有引用对象都已标记</li></ul><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/g1-three-color.png"></p><ol><li>GC 开始前所有对象都是白色。</li><li>初始标记时，所有GC Roots直达的对象被压到栈中，待搜索，此时颜色是灰色。</li><li>然后依次从栈中取出灰色对象，搜索其子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。</li><li>当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</li></ol><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/three-color.gif"></p><p>漏标问题。在重新标记/最终标记的过程中，若删除了灰色到白色的引用，而是改为黑色指向白色，此时如果不对黑色重新扫描，则会漏标，会把白色回收掉。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/three-color-spill-tag-1.png"></p><p>产生漏标问题的条件有两个：</p><ul><li>黑色对象指向了白色对象</li><li>灰色对象指向白色对象的引用消失</li></ul><p>所以要解决漏标问题，打破两个条件之一即可：</p><ul><li>跟踪黑指向白的增加 incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描该对象。CMS采用该方法。</li><li>记录灰指向白的消失 SATB snapshot at the beginning：关注引用的删除，当灰–&gt;白消失时，要把这个白色推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。</li></ul><p>为什么G1采用SATB而不用incremental update？</p><p>因为采用incremental update把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。G1有RSet与SATB相配合。RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。</p><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><p>对象优先在 Eden 分配</p><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p>大对象是指需要连续内存空间的对象，直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制</p></li><li><p>长期存活的对象进入老年代</p><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，并且能被 Survivor 容纳，年龄就增加 1 岁，增加到一定年龄（默认15）则移动到老年代中。</p></li><li><p>动态对象年龄判定</p><p>虚拟机并不是永远要求对象的年龄必须达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保</p><p>把Survivor无法容纳的对象直接转移到老年代。</p><p>在 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者不允许冒险，那么就要进行一次 Full GC。</p></li></ol><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><ol><li><p>调用 System.gc()</p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足</p><p>常见原因：</p><ol><li>老大对象直接进入老年代：尽量不要创建过大的对象以及数组</li><li>长期存活的对象进入老年代：通过调节虚拟机参数，让对象在新生代多存活一段时间</li></ol></li><li><p>空间分配担保失败</p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p></li><li><p> JDK 1.7 及以前的永久代空间不足</p></li></ol><p>   在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 OutOfMemoryError。解决方法是增大永久代空间或转为使用 CMS GC。</p><ol start="5"><li><p>Concurrent Mode Failure</p><p>并发清除阶段产生的浮动垃圾触发 Full GC。</p></li></ol><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="new对象都做了什么"><a href="#new对象都做了什么" class="headerlink" title="new对象都做了什么"></a>new对象都做了什么</h2><ol><li>检查<ol><li>是否有常量</li><li>类是否加载过</li></ol></li><li>分配内存</li><li>初始化为零值</li><li>对象头设置</li><li>初始化代码中设置的值</li></ol><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/class-life.png"></p><ol><li><p>加载</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</li><li>在内存中生成一个代表该类的 Class 对象，存储在方法区，作为方法区中该类各种数据的访问入口。</li></ul></li><li><p>验证</p><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p></li><li><p>准备</p><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。初始值一般为 0 值。如果类变量是常量，那么它将初始化为字面量。</p><p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p></li><li><p> 解析</p></li></ol><p>   将常量池的符号引用替换为直接引用</p><ol start="5"><li><p>初始化</p><p>初始化阶段是虚拟机执行类构造器方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p><p>一些需要注意的：</p><ul><li>类构造器是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。</li><li>由于父类的类构造器方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类</li><li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成类构造器方法。但接口与类不同的是，执行接口的类构造器方法不需要先执行父接口的类构造器方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的类构造器方法。</li><li>虚拟机会保证一个类的类构造器方法在多线程环境下被正确的加锁和同步。</li></ul></li></ol><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><ol><li><p>主动引用</p><ul><li>使用 new 关键字实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，会先初始化主类</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ul></li><li><p>被动引用</p><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li><li>常量在编译阶段会存入<strong>调用类</strong>的常量池中，本质上并没有直接引用到<strong>定义常量的类</strong>，因此不会触发定义常量的类的初始化</li></ul></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li>启动类加载器，使用 C++ 实现，是虚拟机自身的一部分；</li><li>所有其它的类加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li><li>自定义类加载器</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/parent-delegation-model.png"></p><p>类加载器之间的层次关系，称为双亲委派模型。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系来实现，而不是继承关系。</p><p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><p>好处：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="静态多态：重载方法匹配优先级"><a href="#静态多态：重载方法匹配优先级" class="headerlink" title="静态多态：重载方法匹配优先级"></a>静态多态：重载方法匹配优先级</h2><p>静态分派：看静态类型能查找并匹配到的方法版本</p><ol><li><p>自动转型</p><p>byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double</p></li><li><p>接口</p><p> 匹配到多个接口，其优先级一样，编译器会报错</p></li><li><p>父类</p><p>按照继承关系从下到上</p></li><li><p>可变长参数</p></li></ol><h2 id="动态多态：重写方法匹配过程"><a href="#动态多态：重写方法匹配过程" class="headerlink" title="动态多态：重写方法匹配过程"></a>动态多态：重写方法匹配过程</h2><p>动态分派：看动态类型能查找并匹配到的方法版本。</p><p>其底层实现是在类方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口就和父类相同方法的地址入口一致，都指向父类的方法实现入口。如果子类重写了这个方法，那子类的虚方法表里面的地址入口就指向子类实现版本的方法入口。确定动态类型后，查找虚方法表，返回方法的直接引用。</p><p>先考虑方法重写，再考虑方法重载。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基数统计算法</title>
    <link href="/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>基数指的是一个集合中不重复的元素的个数。例如集合{2,1,1,3,2,1}，其基数集合就是{1,2,3}的长度，即3。基数计数，或称基数统计，指的就是计算出集合的基数。常见的基数统计的使用场景就是统计网站访问UV。</p><p>下面介绍几种基数估计的算法。</p><h1 id="LogLog-Counting"><a href="#LogLog-Counting" class="headerlink" title="LogLog Counting"></a>LogLog Counting</h1><p>回顾一些高中知识。我们假设抛出一枚硬币，其正面朝上的概率是1/2，反面朝上的概率也是1/2，不存在其他情况。显然，每次抛硬币都是相互独立的。那么如果我们一直抛硬币k次都为正面，这个事件出现的概率就是1/2^k。但是，如果我们真的抛硬币k次，一定会发生上述事件吗？很明显不一定，但是根据概率论，只要我们的样本足够大，那么出现这个事件的概率就趋近于1/2^k。既然该事件出现的概率是1/2^k，那么就可以说，如果我们至少抛2^k次硬币，一定会发生该事件。</p><p>假设我们的集合是一个二进制数组，类似[0,0,…,1,0,1,…]这样，那么我们就可以将这个数据从左往右视作抛硬币的过程。我们假设0代表硬币反面，1代表硬币正面，如果从左往右连续出现了k个1，那么出现这种数据情况的概率是多少呢？如前所述，是1/2^k。即这个数字的出现，就代表了我们进行了2^k次抛硬币的行为。如果我们将基数集合中的每个元素，视作一次抛硬币，那么我们就可以说基数为2^k个。</p><p>我们再假设，我们有一个固定长度的二进制数组，长度为n，初始全为0。我们还有一个很牛的Hash函数，可以将数据很分散的映射到这个数组上，使其置为1，并且Hash还是还能保证每一位出现0、1的概率都是1/2。那么，当这个数据的基数远远大于n时，一定会出现数组全为1的情况。换言之，我们就可以通过数组中1的个数来推断基数了。这等同于，我们查找数组中最右边的1，并将其左边所有位都视为1来估计基数。</p><p>至此，我们就可以讲讲LLC算法了。</p><p>LLC将数据依次通过Hash函数转成固定长度L的二进制串a，Hash函数保证每一位出现0、1的概率都为1/2，并且相同元素产生的二进制串相同，那么我们记a中最左边的1的下标为ia。最终，我们会得到imax=max(ia, ib, …, in)，那么根据之前的介绍，我们就估计出不同元素的个数为2^imax。</p><p>显然，这个过程会因为数据特性产生很多意外情况，于是LLC将二进制串进行分桶，各个桶分别计算自己的imax，即各自的基数，最终结果为这些技术的几何平均数。</p><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>其原理与LLC一致，只是最终使用调和平均数代替几何平均数。原因是调和平均数具有更优秀的抗干扰能力，会忽略一些尖刺数据的影响。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm</a></p><p><a href="http://antirez.com/news/75"><a href="http://antirez.com/news/75">Redis new data structure: the HyperLogLog</a></a></p><p><a href="https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/">HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</a></p><p><a href="https://agkn.wordpress.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a></p><p><a href="https://zhuanlan.zhihu.com/p/271186546">基数估计算法</a></p><p><a href="https://seeing-theory.brown.edu/cn.html">看见统计</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork函数以及Copy-On-Write机制</title>
    <link href="/2023/06/09/fork%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8ACopy-On-Write%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/09/fork%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8ACopy-On-Write%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>fork操作的含义是根据当前进程，拷贝出一份“一模一样”的新进程来。fork是类Unix系统创建进程的主要手段。在详解fork操作之前，我们需要先具备一些基本知识，熟悉这些的小伙伴可以跳过。</p><h1 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一.预备知识"></a>一.预备知识</h1><h2 id="1-进程组成"><a href="#1-进程组成" class="headerlink" title="1.进程组成"></a>1.进程组成</h2><p>进程是程序关于某数据集的一次运行活动。进程包括：</p><ul><li>进程控制块（PCB）：进程存在的唯一标志。进程管理工作所需的信息都存放在PCB中，操作系统不直接操作进程本身，而是通过操作PCB控制进程<ul><li>进程标识信息<ul><li>进程标识符PID</li><li>用户标识符UID</li><li>…</li></ul></li><li>处理器状态信息：各种寄存器的值，用于实现进程切换时保存上下文信息<ul><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>上下文数据：进程执行时处理器的寄存器中的数</li><li>记账信息：包括处理器时间综合、使用的时钟数综合、时间限制、记帐号等</li><li>…</li></ul></li><li>进程控制信息<ul><li>进程当前状态</li><li>进程优先级</li><li>正在使用的文件信息</li><li>正在使用的内存区域</li><li>正在使用的I/O设备</li><li>CPU、磁盘、网络流量使用情况统计</li><li>…</li></ul></li></ul></li><li>文本区域/代码段（text region）：存储处理器执行的代码。</li><li>数据区域/数据段（data region）：存储变量和进程执行期间使用的动态分配的内存</li><li>堆栈（stack region）：存储着活动过程调用的指令和本地变量</li></ul><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/composition.png"></p><p>下面这张图是进程的虚拟内存地址空间的分配模型图。进程的虚拟内存地址空间分为用户空间和内核空间。用户空间存放着这个进程的代码段和数据段，以及运行时的堆和用户栈。内核空间存放着内核的代码和数据，以及内核为这个进程创建的相关数据结构，比如页表数据结构等。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/PCB.png"></p><h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2.虚拟内存"></a>2.虚拟内存</h2><p>随着应用程序的体积越来越庞大，想要将完整的应用程序完整地装载进内存并运行起来越来越不现实。虚拟内存的技术带来的效果就是，使应用程序认为它在使用一块比实际物理内存大得多的虚拟内存，而不需要考虑具体实现细节。</p><p>至于实现方式，简单说就是根据时空局部性原理，将应用程序在此时运行真正需要的数据加载进内存，其余数据暂不关心，等到真正需要时再置换进内存。</p><h2 id="3-内存分页"><a href="#3-内存分页" class="headerlink" title="3.内存分页"></a>3.内存分页</h2><p>内存分页技术是一种实现虚拟内存的技术。它将虚拟内存进行等分（与具体应用程序无关），称之为“页”。将物理内存也进行等分（与页大小一致），称之为“块”，也叫做“页框”。在应用程序运行过程中，动态地将所需要的页加载进真正的物理内存中，即以页为单位，加载进页框中。通过一个映射记录“页表”，记录实时的页与页框的对应关系，辅助应用程序与操作系统查找到虚拟内存中的物理内容。</p><h1 id="二-fork操作原理"><a href="#二-fork操作原理" class="headerlink" title="二.fork操作原理"></a>二.fork操作原理</h1><p>开篇说过，fork操作的含义是根据当前进程，拷贝出一份“一模一样”的新进程来，其作用就是创建新进程。被拷贝的当前进程称之为“父进程”，拷贝出来的新进程称之为“子进程”。对于Linux系统而言，所有进程都是通过init进程fork而来的，即init进程是所有进程的祖先进程。</p><p>一个进程调用fork后，操作系统会转入内核态，做以下几件事（考虑COW的情况）：</p><ol><li><p>分配新的内存块和内核数据结构给子进程</p></li><li><p>将父进程部分数据结构内容拷贝至子进程：PCB（大略上，除了进程标识重新分配以外，其他很多资源都需要复制）。代码段、数据段、堆栈的复制采用COW写时复制技术进行复制（这里面就包含了虚拟内存分页会使用到的页表数据结构），即父子进程的虚拟地址不同（子进程分配了新的内存页），但其对应的物理地址相同。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/fork-COW.jpg"></p></li><li><p>添加子进程到系统进程列表当中</p></li><li><p>fork返回，开始进程调度：父子进程的执行并没有固定的先后顺序，完全看操作系统的进程调度策略</p></li></ol><p>子进程执行起来后的局部变量，和父进程是独立的。我们看下面的例子</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span>  </span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>   </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start \n&quot;</span>);<br>    i=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-comment">// 在父进程中，fork返回新创建的子进程的进程ID</span><br>    <span class="hljs-comment">// 在子进程中，fork返回它的子进程的进程ID，因为没有，所以返回0</span><br>    <span class="hljs-comment">// 如果出现错误，fork返回一个负值</span><br>    <span class="hljs-comment">// fpid这个局部变量，在父子进程中根据fork()函数返回值的不同而不同</span><br>    <span class="hljs-comment">// 由于fork前i=0已经确定了，所以子进程中也是i=0，这是从父进程复制而来的</span><br>    fpid=fork();<br><br>    <span class="hljs-comment">// 父进程正常执行下面的代码</span><br>    <span class="hljs-comment">// 拷贝出来的子进程也会执行下面的代码</span><br>    <span class="hljs-keyword">if</span> (fpid &lt; <span class="hljs-number">0</span>)   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建进程失败!/n&quot;</span>);   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fpid == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是子进程，由父进程fork出来/n&quot;</span>);   <br>    &#125;  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是父进程/n&quot;</span>); <br>    &#125;  <br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end \n&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br></code></pre></td></tr></table></figure><p>创建好子进程后，父进程要执行这段代码，子进程也要执行这段代码。子进程不会像线程那样从run方法处开始执行，而是会从父进程调用fork函数的返回位置开始执行：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/fork.png"></p><h1 id="三-exec操作原理"><a href="#三-exec操作原理" class="headerlink" title="三.exec操作原理"></a>三.exec操作原理</h1><p>看完上面fork操作的原理，我们知道了怎样创建一个新进程。但是，为什么我们需要创建两个一模一样的进程呢？或者说，我们大多数情况下并不需要两个一模一样的进程，我们更需要的是执行新任务的新进程。这就用到了exec函数族，其中包括6个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...<span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...<span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[],<span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。大白话说，就是在函数外在包装（比如PID）不变的情况下，完全更改内部逻辑。exec系列函数在执行时会直接替换掉当前进程的物理地址空间。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/exec.png"></p><p>总结一下，fork会产生一个和父进程完全相同的子进程，但子进程在此后一般会调用exec，执行自己真正想要的功能。因为执行了exec，数据都被清空了，所以fork新创建子进程时复制过去的数据是没用的。因此，我们引入Copy On Write写时复制技术，在复制父进程时并不真正意义上的复制，而是子进程共享父进程的部分内存空间，这样一是复制速度快，二是避免无用复制，浪费资源。只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><h2 id="四-Copy-On-Write写时复制"><a href="#四-Copy-On-Write写时复制" class="headerlink" title="四.Copy On Write写时复制"></a>四.Copy On Write写时复制</h2><p>写时复制COW，是计算机编程中使用的一种资源管理技术。其效果是，如果一个资源被拷贝但没有被修改，则不会立即创建一个新的资源副本，而是在父子进程之间共享。只有在第一次修改资源时，才会复制资源，即COW是一种可以推迟甚至避免拷贝资源的技术。对部分资源的修改不会改变其他资源，没有修改的资源仍然是父子进程之间共享。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/COW.png"></p><p>对于fork而言：</p><ul><li>子进程exec之前，刚被创建出来的父子进程完全共享代码段、数据段、堆栈的物理空间。</li><li>子进程exec之后，由于两者执行的代码不同，子进程的代码段也会分配新的物理空间。</li></ul><h3 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h3><p>以页表为例，fork之后，内核会把父进程中所有的物理页框的权限都设为read-only，然后子进程的虚拟内存地址指向父进程的物理内存地址。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到物理页框是read-only的，于是触发页异常中断（page-fault），陷入到内核的一个中断例程。在这个中断例程中，内核就会把触发的异常的物理页框复制一份，子进程的虚拟内存地址指向这个新页框的物理地址，于是父子进程的虚拟内存地址各自指向了不同的物理地址。</p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><ul><li>减少了不必要的资源分配</li><li>降低了复制大量资源时带来的瞬间延时</li></ul><h3 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3.缺点"></a>3.缺点</h3><ul><li>少量增加了资源修改操作时的开销</li><li>如果在fork之后，父子进程都还需要继续进行写操作，会产生大量的分页错误</li></ul><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E8%A1%8C%E7%A8%8B">维基百科-进程</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503">百度百科-进程</a></li><li><a href="https://lfool.gitbook.io/operating-system/di-er-zhang-jin-cheng-guan-li/1.-jin-cheng-de-gai-nian-zu-cheng-te-zheng">进程的概念 &amp; 组成 &amp; 特征</a></li><li><a href="https://blog.csdn.net/pange1991/article/details/84770181">进程和线程的区别（操作系统级别解析）</a></li><li><a href="https://misakifx.github.io/2020/02/17/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">【操作系统原理】第二章-进程和线程 </a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">维基百科-虚拟内存</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E6%80%A7">维基百科-局部性原理</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E5%88%86%E9%A0%81">维基百科-分页</a></li><li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)">维基百科-fork（系统调用）</a></li><li><a href="https://blog.csdn.net/Dawn_sf/article/details/78709839">操作系统 — fork()函数的使用与底层原理</a></li><li><a href="https://blog.csdn.net/wu_zf/article/details/7640970">linux中fork函数及子进程父进程进程先后</a></li><li><a href="https://blog.csdn.net/daocaokafei/article/details/116785985">「进程管理」fork之后子进程到底复制了父进程什么？</a></li><li><a href="https://en.wikipedia.org/wiki/Exec_(system_call)">维基百科-exec（系统调用）</a></li><li><a href="https://en.wikipedia.org/wiki/Copy-on-write">维基百科-写时复制</a></li><li><a href="https://zhuanlan.zhihu.com/p/148683698?utm_id=0">Copy On Write机制了解一下</a></li><li><a href="https://www.cnblogs.com/wuchanming/p/4495479.html">Linux进程管理——fork()和写时复制</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础-单机数据库</title>
    <link href="/2023/05/31/Redis%E5%9F%BA%E7%A1%80-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/05/31/Redis%E5%9F%BA%E7%A1%80-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>Redis 服务器内会保存服务器信息与客户端信息，所以如无特殊说明，下文涉及的服务端状态指服务端保存的服务器的信息（保存在redis.h/RedisServer结构内），客户端状态指服务端保存的客户器的信息（保存在redis.h/RedisClientr结构内）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisServer</span> </span>&#123;<br>    <span class="hljs-comment">// 保存所有数据库具体信息的数组</span><br>    RedisDb[] db;<br>    <span class="hljs-comment">// 数据库数量</span><br>    <span class="hljs-keyword">int</span> dbnum;<br>    <span class="hljs-comment">// 距离上次持久化之后，所有数据库的修改次数</span><br>    <span class="hljs-keyword">long</span> dirty;<br>    <span class="hljs-comment">// 为防止持久化失败，在持久化之前复制dirty值，用于恢复</span><br>    <span class="hljs-keyword">long</span> dirtyBeforeBgsave;<br>    <span class="hljs-comment">// 上次执行SAVE或BGSAVE命令的时间戳</span><br>    <span class="hljs-keyword">long</span> lastsave;<br>    <span class="hljs-comment">// 是否可以执行RDB持久化的判断条件</span><br>    SaveParam[] saveParams;<br>    <span class="hljs-comment">// AOF缓冲区</span><br>    <span class="hljs-comment">// sds实现的动态字符串</span><br>    String aofBuf;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisClient</span> </span>&#123;<br>    <span class="hljs-comment">// 当前客户端的状态</span><br>    <span class="hljs-comment">// CLIENT_DIRTY_CAS表示事务被破坏</span><br>    <span class="hljs-keyword">int</span> flags;<br>    <span class="hljs-comment">// 当前客户端选择使用的数据库</span><br>    RedisDb db;<br>    <span class="hljs-comment">// 监视的所有键</span><br>    list&lt;string&gt; watchedKeys;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一-数据库"><a href="#一-数据库" class="headerlink" title="一.数据库"></a>一.数据库</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDb</span> </span>&#123;<br>    <span class="hljs-comment">// 键空间，保存了当前数据库的所有键值对</span><br>    Hash dict;<br>    <span class="hljs-comment">// 当前数据库被监听的所有键及监视他们的client</span><br>    <span class="hljs-comment">// key=键</span><br>    <span class="hljs-comment">// value=list&lt;client&gt;</span><br>    Hash watchedKeys;<br>    <span class="hljs-comment">// 保存本数据库中所有设置过过期时间的键及其过期时间戳</span><br>    <span class="hljs-comment">// key=键</span><br>    <span class="hljs-comment">// value=过期时间戳（精度：毫秒）</span><br>    Hash expires;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><p>类似于其他的数据库，如Mysql或Oracle等，一个服务端往往有多个数据库，Redis也是一样。服务器状态里的RedisServer.db保存了所有数据库的指针，RedisServer.dbnum当前的数据库数量（默认值为16，即Redis服务器默认创建16个数据库，默认值由配置文件里的database决定）。不同数据库之间的数据是独立的。</p><p>RedisDb就是具体某个数据库的信息。</p><p>客户端状态里的RedisClient.db表示当前客户端正在使用的数据库，可以通过SELECT命令切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 切换到1号数据库，数据库下标从0开始（数组下标）</span><br>SELECT <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="2-数据库键空间"><a href="#2-数据库键空间" class="headerlink" title="2.数据库键空间"></a>2.数据库键空间</h2><p>之前我们介绍过Redis的hash对象，对于每个数据库而言，它们就是通过一个hash对象来维护当前数据库的所有键值对的，称之为“键空间”。需要特别注意，之前我们说Redis不允许对象类型嵌套使用，即只能是list&lt;string&gt;、map&lt;string,string&gt;、set&lt;string&gt;、zset&lt;string&gt;，加上string这五种对象类型。但是，键空间这个hash对象是个例外，它的key是string对象类型，value是我们刚才说的五种对象类型。</p><p>有了之前hash对象的知识，我们很容易想象<em>键命令</em>是如何实现的：</p><ul><li>添加新键</li><li>删除键</li><li>更新键</li><li>查询键</li><li>其他<ul><li>清空当前数据库的所有键 FLUSHDB</li><li>随机返回某个键 RANDOMKEY</li><li>当前数据库的键数量 DBSIZE</li><li>是否存在某个键 EXISTS</li><li>重命名键 RENAME</li><li>查询所有键 KEYS</li><li>…</li></ul></li></ul><p>另外，当我们通过键命令读写键空间时，服务器还会额外执行一些操作：</p><ul><li>读写键之后，服务器会根据键是否存在，更新当前数据库的hit（键命中次数）、miss（键未命中次数）值</li><li>读写键之后，服务器会更新键对象的lru时间</li><li>读写键值之前，若键已经过期，服务器会删除键，然后执行剩余操作</li><li>修改（增删改）键之后，服务器会修改监视了当前键（WATCH命令）的客户端状态，表示其事务被破坏</li><li>修改（增删改）键之后，服务器的脏键计数器加1（RedisServer.dirty++），这个脏键计数器会触发服务器的持久化及复制操作</li><li>修改（增删改）键之后，若服务器开启了通知功能，那么服务器将按照配置发送相应通知</li></ul><h1 id="二-键的生存周期"><a href="#二-键的生存周期" class="headerlink" title="二.键的生存周期"></a>二.键的生存周期</h1><p>redisDb.expires字典保存了本数据中所有设置过过期时间的键，及其过期时间戳，称之为过期字典。其中，字典key是键指针，字典value是这个键的过期时间戳，单位毫秒。</p><h2 id="1-设置过期时间"><a href="#1-设置过期时间" class="headerlink" title="1.设置过期时间"></a>1.设置过期时间</h2><p>Redis中设置键过期的命令有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">EXPIRE key n<span class="hljs-comment">// 设置键n秒后过期</span><br>PEXPIRE key n<span class="hljs-comment">// 设置键n毫秒后过期</span><br>EXPIREAT key n<span class="hljs-comment">// 设置键某个时间戳过期，单位：秒</span><br>PEXPIREAT key n<span class="hljs-comment">// 设置键某个时间戳过期，单位：毫秒</span><br></code></pre></td></tr></table></figure><p>在Redis底层实现里，上述四个命令，最终都会转换成<em>PEXPIREAT</em>命令实现，不难想象，该命令的实现原理就是往redisDb.expires字典中插入数据。</p><p>我们单独讨论一下<em>SETEX</em>命令及Redis实现分布式锁的原理：<a href="http://www.jonxzzz.com/2023/06/04/Redis%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis应用-分布式锁 </a></p><h2 id="2-删除过期时间"><a href="#2-删除过期时间" class="headerlink" title="2.删除过期时间"></a>2.删除过期时间</h2><p>Redis中删除键过期的命令有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PRESIST key<span class="hljs-comment">// 删除该键之前设置过的过期时间</span><br></code></pre></td></tr></table></figure><p>该命令的实现原理就是删除redisDb.expires字典中对应数据。</p><h2 id="3-获取过期时间"><a href="#3-获取过期时间" class="headerlink" title="3.获取过期时间"></a>3.获取过期时间</h2><p>Redis中查询键还有多久过期的命令有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TTL key<span class="hljs-comment">// 返回键的剩余生存时间（time to live，TTL），单位：秒</span><br>PTTL key<span class="hljs-comment">// 返回键的剩余生存时间（time to live，TTL），单位：毫秒</span><br></code></pre></td></tr></table></figure><p>该命令的实现原理就是查询redisDb.expires字典中该键的过期时间戳，返回当前时间戳与过期时间戳的差值。</p><h2 id="4-判断键是否过期"><a href="#4-判断键是否过期" class="headerlink" title="4.判断键是否过期"></a>4.判断键是否过期</h2><p>其实通过上述TTL、PTTL的实现已经可以用来判断一个键是否过期了，但是对于Redis内部而言，调用一个命令的成本肯定要大于自己重新写一段代码。Redis判断一个键是否过期，就是对比当前时间戳和过期时间戳的大小。</p><h2 id="5-过期键删除策略"><a href="#5-过期键删除策略" class="headerlink" title="5.过期键删除策略"></a>5.过期键删除策略</h2><p>抛开Redis不谈，数据库对于过期键的删除策略有以下三种：</p><ul><li>定时删除<ul><li>在设置键的过期时间的同时，同时设置一个定时器，到了指定时间时间时，定时器会立即执行对键的删除操作。</li><li>最节省内存，不会出现无用数据占用内存的情况。</li><li>最消耗CPU。首先，每个过期键都需要一个定时器去处理它；其次，与处理服务器请求相比，处理过期数据非常不重要；最后，对于Redis而言，它的定时器实现需要用到时间事件，而Redis对于时间事件的实现是无序链表，查找到一个需要执行的事件时间复杂度是O(N)，这显然不够高效。</li></ul></li><li>惰性删除<ul><li>放任过期键不理会，但是每当服务器处理键的查询命令时，都会先判断该键是否已经过期。如果已经过期，则删除该键，返回空或报错；如果没有过期，则执行正常查询命令。</li><li>极端情况下，可能出现无用数据占用大量内存的情况。</li><li>最节省CPU，只有在过期键真正需要被删除的时候才会执行删除操作。</li></ul></li><li>定期删除<ul><li>每隔一段时间，就检查数据库，删除其中过期的数据。至于要隔多久检查、每次检查多少数据，都可以配置。</li><li>折中方案</li><li>可以通过控制执行周期间隔和每次执行的规模来决定对于内存和CPU的影响</li></ul></li></ul><p>Redis的实现方式是同时使用惰性删除和定期删除两种策略。我们主要看下定期删除的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个全局变量</span><br><span class="hljs-comment">// 代表数据库下标</span><br><span class="hljs-comment">// 用来记录Redis服务器清理过期键的进度</span><br><span class="hljs-keyword">int</span> current_db = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 每次Redis的周期函数serverCron执行时，都会调用本函数完成对数据库中的过期键清理</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activeExpireCycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 本次需要处理的数据库数量</span><br>    <span class="hljs-keyword">int</span> db_number = server.dbnum &lt; DEFAULT_DB_NUMBERS ? server.dbnum : DEFAULT_DB_NUMBERS;<br>    <span class="hljs-comment">// 遍历数据库</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i: du_numbers) &#123;<br>        <span class="hljs-comment">// 已经检查完一轮服务器的所有数据库，重新再来一遍</span><br>        <span class="hljs-keyword">if</span> (current_db == server.dbnum) &#123;<br>            curent_db = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取本次需要处理的数据库</span><br>        redisDb = server.db[current_db++];<br>        <br>        <span class="hljs-comment">// 遍历该数据库的部分数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j: DEFAULT_KEY_NUMBERS) &#123;<br>            <span class="hljs-comment">// 该数据库没有过期键，直接跳过</span><br>            <span class="hljs-keyword">if</span> (redisDb.expires.size == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 随机处理一个设置了过期时间的键</span><br>            key = redisDb.expires.get_random_key();<br>            <br>            <span class="hljs-comment">// 该键已经过期，删除它</span><br>            <span class="hljs-keyword">if</span> (is_expire(key)) &#123;<br>                <span class="hljs-comment">// 删除键并发送通知</span><br>                deleteExpiredKeyAndPropagat(key)<br>            &#125;<br>            <br>            <span class="hljs-comment">// 达到了本次的处理时间上限，立即结束</span><br>            <span class="hljs-keyword">if</span> (reach_time_limit()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Redis通过约束每次处理的数据库数量、键数量、总的处理时间，防止对于过期键的处理过多的影响服务器。</p><h2 id="6-RDB对于过期键的处理"><a href="#6-RDB对于过期键的处理" class="headerlink" title="6.RDB对于过期键的处理"></a>6.RDB对于过期键的处理</h2><p>生成RDB文件时，不会保存已经过期了的键到RDB文件。</p><p>载入RDB文件时：</p><ul><li>对于主服务器，程序会对RDB文件中的键进行检查，已经过期的键不会载入到数据库中。</li><li>对于从服务器，RDB文件保存的所有数据，不论是否已经过期，都会载入到数据库中。</li></ul><p>在这期间，如果我们从主服务器读取该键，是不会有返回值的。但是如果我们从从服务器读取该键，会返回之前已经过期的值，因为他还没有被删除，而且从服务器也不会惰性删除它。</p><p>随后，只有当主服务器删除掉这个过期键时，会发送一条DEL删除命令到从服务器，从服务会执行命令，从而删除该键。</p><p>之后讨论RDB和主从服务器时我们就知道原因啦。</p><h2 id="7-AOF对于过期键的处理"><a href="#7-AOF对于过期键的处理" class="headerlink" title="7.AOF对于过期键的处理"></a>7.AOF对于过期键的处理</h2><p>写入AOF文件时，如果某个键已经过期，但是它还没有被删除，那么依然会像处理未过期的键一样，将其写入到AOF文件中。随后当这个键被服务器删除时，会追加一条针对这个键的删除操作到AOF文件。</p><p>AOF重写时，程序会对服务器的键进行检查，已经过期的键不会保存到重写后的AOF文件中。</p><p>之后讨论AOF时我们就知道原因啦。</p><h1 id="三-通知机制"><a href="#三-通知机制" class="headerlink" title="三. 通知机制"></a>三. 通知机制</h1><p>客户端通过订阅频道，可以获知数据库中键的变化情况，以及命令的执行情况。从Redis服务器角度看，就是成功执行了某些命令、修改键值、事件发生之后，通知给客户端。</p><p>其原理就是通过<em>SUBSCRIBE</em>命令订阅固定的频道，然后由Redis发布消息，客户端接受消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// __&#123;通知类型&#125;@&#123;数据库id&#125;__&#123;键正则&#125;</span><br>SUBSCRIBE __keyspace@0__:message<br><span class="hljs-comment">// __&#123;通知类型&#125;@&#123;数据库id&#125;__&#123;命令名&#125;</span><br>SUBSCRIBE __keyevente@0__:del<br></code></pre></td></tr></table></figure><p>通知类型有：</p><ol><li>键空间通知：某个键执行了什么命令</li><li>键事件通知：某个命令作用到哪些键</li></ol><p>当命令成功执行后，会调用notifyKeyspaceEvent()方法进行通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// type：通知类型，这里主要是用于区分通用、SET等等，不是上述的键空间和键事件两类</span><br><span class="hljs-comment">// event：命令名</span><br><span class="hljs-comment">// key：键名</span><br><span class="hljs-comment">// dbid：数据库id</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyKeyspaceEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, String event, String key, <span class="hljs-keyword">int</span> dbid)</span> </span>&#123;<br>    <span class="hljs-comment">// 配置不允许发送此类通知，直接返回</span><br>    <span class="hljs-keyword">if</span>(server.notify_keyspace_events &amp; type == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置允许发送键空间通知</span><br>    <span class="hljs-keyword">if</span>(server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE == <span class="hljs-number">1</span>) &#123;<br>        String channel = String.format(<span class="hljs-string">&quot;__keyspace@%d__%s&quot;</span>, dbid, key);<br>        <span class="hljs-comment">// PUBLISH发布命令的底层实现</span><br>        <span class="hljs-comment">// 当前键执行了什么命令</span><br>        pubsubPublishMessage(channel, event);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置允许发送键事件通知</span><br>    <span class="hljs-keyword">if</span>(server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT == <span class="hljs-number">1</span>) &#123;<br>        String channel = String.format(<span class="hljs-string">&quot;__keyevente@%d__%s&quot;</span>, dbid, event);<br>        <span class="hljs-comment">// 当前命令作用到哪些键</span><br>        pubsubPublishMessage(channel, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>server.notify_keyspace_events是redis配置。</p><p>关于发布订阅及其原理我们随后会专门讲解。</p><h1 id="四-RDB持久化"><a href="#四-RDB持久化" class="headerlink" title="四.RDB持久化"></a>四.RDB持久化</h1><p>RDB持久化的作用是将Redis在内存中的数据库状态保存到磁盘中去，做数据备份，防止数据丢失。所谓数据库状态，指的是某个时刻Redis服务器中所有非空数据库及其键值对。</p><h2 id="1-RDB创建"><a href="#1-RDB创建" class="headerlink" title="1.RDB创建"></a>1.RDB创建</h2><h3 id="1-1-手动执行"><a href="#1-1-手动执行" class="headerlink" title="1.1.手动执行"></a>1.1.手动执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生成RDB文件：由主进程执行，即会阻塞主进程响应客户端任何命令，直到RDB文件创建完成</span><br>SAVE<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生成RDB文件：由主进程fork出的子进程执行，即不会阻塞主进程响应客户端任何命令</span><br>BGSAVE<br></code></pre></td></tr></table></figure><p>BGSAVE命令执行期间，服务器会：</p><ol><li><p>拒绝执行SAVE命令：都会调用rdbSave()方法，其间访问的资源会产生竞争。</p></li><li><p>拒绝执行BGSAVE命令：都会调用rdbSave()方法，其间访问的资源会产生竞争。</p></li><li><p>等到BGSAVE命令执行完成后，再执行BGREWRITEAOF命令：虽然不会产生资源竞争，但出于性能考虑，同时进行大量磁盘读写操作也不明智。</p></li></ol><p>另外，若先执行BGREWRITEAOF命令，则会拒绝执行BGSAVE命令，原因也是同时进行大量磁盘读写操作不利于性能。</p><h3 id="1-2-关键细节"><a href="#1-2-关键细节" class="headerlink" title="1.2.关键细节"></a>1.2.关键细节</h3><p>虽然BGSAVE命令采用子进程执行持久化工作，大大减少了主进程的阻塞时间，但是，为了创建出子进程，fork()操作本身也会阻塞主进程。主要原因是fork()出来的子进程需要拷贝进程必要的数据，如内存页表。以内存页表为例，它的作用是记录虚拟内存与物理内存的映射关系，那么，当我们的内存特别大时，这个页表也相应的很大，可想而知拷贝工作会消耗大量CPU，从而增大fork()阻塞时间。</p><p>另外，真正的内存数据在fork()时反而不会被立即拷贝，这主要是操作系统的写时复制（Copy on Write）机制。详情请看<a href="/2023/06/09/fork%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8ACopy-On-Write%E6%9C%BA%E5%88%B6/" title="[fork函数以及Copy-On-Write机制]">[fork函数以及Copy-On-Write机制]</a></p><h3 id="1-3-自动定期执行"><a href="#1-3-自动定期执行" class="headerlink" title="1.3.自动定期执行"></a>1.3.自动定期执行</h3><p>Redis周期函数会定期检查数据库，将其与服务器配置的save选项作比较，只要配置的条件中有一条被满足，就会触发执行BGSAVE命令。下面是默认的save配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务器在900秒之内，对数据库至少进行了1次修改</span><br>save <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-comment">// 服务器在300秒之内，对数据库至少进行了10次修改</span><br>save <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-comment">// 服务器在60秒之内，对数据库至少进行了10000次修改</span><br>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>该配置在Redis启动时会被读取写入到redisServer对象中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisServer</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 距离上次持久化之后，所有数据库的修改次数</span><br>    <span class="hljs-keyword">long</span> dirty;<br>    <span class="hljs-comment">// 为防止持久化失败，在持久化之前复制dirty值，用于恢复</span><br>    <span class="hljs-keyword">long</span> dirtyBeforeBgsave;<br>    <span class="hljs-comment">// 上次执行SAVE或BGSAVE命令的时间戳</span><br>    <span class="hljs-keyword">long</span> lastsave;<br>    <span class="hljs-comment">// 是否可以执行RDB持久化的判断条件</span><br>    SaveParam[] saveParams;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaveParam</span> </span>&#123;<br>    <span class="hljs-comment">// 时间区间，单位：秒</span><br>    <span class="hljs-keyword">long</span> seconds;<br>    <span class="hljs-comment">// 检查的修改次数</span><br>    <span class="hljs-keyword">int</span> changes;<br>&#125;<br></code></pre></td></tr></table></figure><p>上文我们说过，当修改（增删改）键之后，服务器的脏键计数器加1（RedisServer.dirty++）。</p><p>Redis的周期函数是这样检查是否触发了RDB持久化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serverCron</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历所有条件</span><br>    <span class="hljs-keyword">for</span>(SaveParam param: server.saveParams) &#123;<br>        <span class="hljs-keyword">long</span> save_interval = now() - server.lastsave;<br>        <br>        <span class="hljs-comment">// 若数据库被修改次数&gt;=条件允许的修改次数</span><br>        <span class="hljs-comment">// 并且距离上次RDB持久化的时间间隔&gt;条件时间</span><br>        <span class="hljs-comment">// 那么就触发RDB持久化</span><br>        <span class="hljs-keyword">if</span>(server.dirty &gt;= param.changes &amp;&amp; save_interval &gt; param.seconds) &#123;<br>            BGSAVE();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-RDB载入"><a href="#2-RDB载入" class="headerlink" title="2.RDB载入"></a>2.RDB载入</h2><p>RDB文件的载入工作没有专门的命令，因为其是在服务器启动时自动执行的。</p><p>结合之后要讲的AOF持久化，Redis载入数据的过程是这样的：</p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/load-rdb.png" width="50%"><p>RDB载入期间，服务器暂不提供任何服务，即一直处于阻塞状态，直到载入工作完成。</p><h2 id="3-RDB文件结构"><a href="#3-RDB文件结构" class="headerlink" title="3.RDB文件结构"></a>3.RDB文件结构</h2><p>RDB文件格式是非常紧凑的二进制格式，默认经过LZF算法压缩。如果不在乎最终的RDB文件大小，更关心RDB创建时的CPU消耗，那么可以通过配置文件的rdbcompression参数控制开关是否压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启RDB文件压缩功能</span><br>rdbcompression yes<br></code></pre></td></tr></table></figure><p>另外还有配置参数rdbchecksum，用来控制创建和载入RDB文件时是否校验文件是否损坏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启RDB文件损坏校验功能</span><br>rdbchecksum yes<br></code></pre></td></tr></table></figure><h2 id="4-RDB持久化的优缺点"><a href="#4-RDB持久化的优缺点" class="headerlink" title="4.RDB持久化的优缺点"></a>4.RDB持久化的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1.优点"></a>4.1.优点</h3><ul><li>RDB文件的内容为二进制的数据，占用内存更小，更紧凑，可以更快的传输到远程服务器进行服务恢复，更适合做为备份文件。压缩后更是如此。</li><li>BGSAVE命令可以更大程度的提高Redis服务器的运行速度，因为每次持久化时主进程都会fork() 一个子进程，由子进程进行数据持久化工作，主进程并不会执行磁盘I/O等操作。</li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2.缺点"></a>4.2.缺点</h3><ul><li>因为RDB文件只能保存某个时间间隔的数据，如果中途服务被意外终止了，则会丢失一段时间内的数据;</li><li>fork() 本身会造成阻塞，如果数据集很大且CPU性能不佳，则可能导致Redis服务器停止为客户端服务几毫秒甚至一秒钟。</li></ul><h1 id="五-AOF持久化"><a href="#五-AOF持久化" class="headerlink" title="五.AOF持久化"></a>五.AOF持久化</h1><p>AOF（Append Only File）是通过保存Redis 服务器所执行的<strong>写命令</strong>来记录数据库状态的，被写入AOF文件的命令都是以Redis的命令请求协议格式保存的，即是纯文本格式（不同于RDB文件的二进制文本格式）。服务器在启动时，可以通过加载并执行AOF文件内的所有命令来还原服务器被关闭前的数据库状态。</p><h2 id="5-1-AOF生成"><a href="#5-1-AOF生成" class="headerlink" title="5.1.AOF生成"></a>5.1.AOF生成</h2><p>AOF持久化功能依次分为三部分：</p><ol><li>命令追加：当服务器的AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以命令请求协议的格式被追加到redisServer.aofBuf缓冲区内。</li><li>文件写入 -&gt; 文件同步：每次事件循环函数处理完所有事件之后，都会调用flushAppendOnlyFile()函数，根据条件，考虑是否将redisServer.aofBuf缓冲区内的数据写入到内存中的AOF文件内，以及是否将内存AOF文件同步到磁盘AOF文件。<ol><li>服务器配置appendfsync决定了何时进行文件同步：<ol><li>always：由主进程立即将redisServer.aofBuf缓冲区内的所有数据写入内存AOF文件，并同步到磁盘AOF文件。</li><li>everysec：将redisServer.aofBuf缓冲区内的所有数据写入内存AOF文件，如果上次文件同步距今时间已超过一秒，那么由子线程负责将内存AOF文件同步到磁盘AOF文件中。</li><li>no：将redisServer.aofBuf缓冲区内的所有数据写入内存AOF文件，何时将内存AOF文件同步到磁盘AOF文件中，以及具体操作，均由操作系统决定并执行，Redis服务器什么也不做。</li></ol></li><li>这三种配置的优缺点分别是：<ol><li>always<ol><li>优点：最安全，即使服务器被关闭，也只会都是一条命令</li><li>缺点：每次执行写命令都需要写入磁盘，写入命令执行效率最低</li></ol></li><li>everysec<ol><li>优点：折中方案，安全性尚可，只会丢失一秒内的命令</li><li>缺点：写入命令执行效率足够快</li></ol></li><li>no<ol><li>优点：写入命令执行效率最高</li><li>缺点：风险最高，丢失的命令数量取决于操作系统的设置</li></ol></li></ol></li></ol></li></ol><p>至于为什么会出现文件写入与文件同步这两个阶段，也是出于效率考虑，现代操作系统做出的优化。操作系统通常会将写入磁盘的文件数据先暂存在一个内存缓冲区中，等到缓冲区满或超过了时间限制后，才真正地将缓冲区内的文件数据写入到磁盘。但正如前所述，这样做也带来了文件数据丢失的风险。</p><h2 id="5-2-AOF载入与数据还原"><a href="#5-2-AOF载入与数据还原" class="headerlink" title="5.2.AOF载入与数据还原"></a>5.2.AOF载入与数据还原</h2><p>步骤如下：</p><ol><li>由于Redis命令只能在客户端上下文中执行，所以创建一个不带网络连接的伪客户端，通过读取AOF文件中的命令代替本来由网络连接传输过来的命令，然后执行。其执行效果与带网络连接的普通客户端完全一样。</li><li>从AOF中读取一条写命令。</li><li>使用伪客户端执行被读取出来的写命令。</li><li>重复执行步骤2和3，直到AOF文件中的所有写命令都被处理完。</li></ol><p>至此，就通过AOF文件还原出了数据库状态。</p><h2 id="5-3-AOF重写"><a href="#5-3-AOF重写" class="headerlink" title="5.3.AOF重写"></a>5.3.AOF重写</h2><p><strong>为什么会有AOF重写？</strong>因为随着服务器不断执行接收到的一条条写命令，AOF文件的内容会越来越多，不仅对Redis服务器，甚至会对宿主机造成影响。并且，载入AOF所需要的时间也会越来越久。更要命的是，这里面还包含了大量的冗余指令。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">RPUSH list <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-string">&quot;B&quot;</span><br>RPUSH list <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-string">&quot;D&quot;</span><br>RPUSH list <span class="hljs-string">&quot;E&quot;</span> <span class="hljs-string">&quot;F&quot;</span><br>LPOP list<br>LPOP list<br></code></pre></td></tr></table></figure><p>上面的6条指令可以帮助我们还原list的最终状态，但是，我们真的需要这六条指令吗？换个角度想，我们只是需要记录下当前的数据库状态，即想要通过一条指令可以还原出[“C”, “D”, “E”, “F”]这个list，那么下面这条指令的含义是不是等于上面6条之和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RPUSH list <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-string">&quot;D&quot;</span> <span class="hljs-string">&quot;E&quot;</span> <span class="hljs-string">&quot;F&quot;</span><br></code></pre></td></tr></table></figure><p>这就是AOF重写的原理，即通过特定指令读取数据库当前状态，以替换原有的AOF文件，达到最小化AOF文件的效果。特点是：</p><ul><li>新老两份AOF文件表达的数据库状态完全一致</li><li>完全与原有的AOF文件无关，只与数据库当前状态有关</li></ul><p>整个AOF重写的过程用伪代码表达如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aofRewrite</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建新AOF文件</span><br>    File file = createFile();<br>    <br>    <span class="hljs-keyword">for</span> (RedisDb db: redisServer.db) &#123;<br>        <span class="hljs-comment">// 忽略空数据库</span><br>        <span class="hljs-keyword">if</span> (db.isEmpty()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 写入db选择命令</span><br>        f.writeCommand(SELECT, db.id);<br>        <br>        <span class="hljs-keyword">for</span> (String key: db.keys()) &#123;<br>            <span class="hljs-comment">// 忽略已经过期的key</span><br>            <span class="hljs-keyword">if</span> (key.isExpire) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">switch</span> (key.type) &#123;<br>                    STRING: rewriteString(file, key);<br>                    LIST: rewriteList(file, key);<br>                    SET: rewriteSet(file, key);<br>                    ZSET: rewriteZset(file, key);<br>                    HASH: rewriteHash(file, key);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 写入key的过期时间</span><br>            <span class="hljs-keyword">if</span> (key.hasExpireTime()) &#123;<br>                rewriteExpireTime(key)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 新文件写入完毕，关闭</span><br>    file.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteString</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用GET命令获取value</span><br>    String value = GET(key);<br>    <span class="hljs-comment">// 使用SET命令重写</span><br>    f.writeCommand(SET, key, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteList</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用LRANGE命令获取所有values</span><br>    String[] values = LRANGE(key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 使用RPUSH命令重写</span><br>    f.writeCommand(RPUSH, key, values);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteSet</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用SMEMBERS命令获取所有values</span><br>    String[] values = SMEMBERS(key);<br>    <span class="hljs-comment">// 使用SET命令重写</span><br>    f.writeCommand(SADD, key, values);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteZset</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用GET命令获取所有values、scores</span><br>    String[] valueAndScores = ZRANGE(key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;WITHSCORES&quot;</span>);<br>    <span class="hljs-comment">// 使用SET命令重写</span><br>    f.writeCommand(ZADD, key, valueAndScores);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteHash</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用HGETALL命令获取所有values</span><br>    String[] value = HGETALL(key);<br>    <span class="hljs-comment">// 使用HMSET命令重写</span><br>    f.writeCommand(HMSET, key, values);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteExpireTime</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取过期时间戳timestamp，单位：毫秒</span><br>    <span class="hljs-keyword">long</span> timestamp = getExpireTime(key);<br>    <span class="hljs-comment">// 使用PEXPIREAT命令重写</span><br>    f.writeCommand(PEXPIREAT, key, timestamp);<br>&#125;<br></code></pre></td></tr></table></figure><p>在处理集合类型的数据时，为了防止单个key多包含的元素过多，造成客户端缓冲区aofBuf溢出，会循环分批处理这个key中的元素（默认配置64个元素），即最终效果是写入多条命令。</p><p>之前我们提到过，写入AOF时，如果key已经过期，但还没有被删除，那么依然会将其写入到AOF文件内，等到它真正被删除时，再往AOF文件内追加一条DEL删除命令。之所以这样。是因为可以在不会影响AOF文件所表达出的数据库状态的情况下，保持AOF写入原则，忠实地记录写命令的执行情况。</p><p>另外，对于AOF重写，它所想要的效果是用最少的命令表达当前数据库的状态，很显然就不需要写入过期键到AOF重写文件内了。</p><p>触发AOF重写有两种方式：</p><ul><li>执行BGREWRITEAOF命令</li><li>serverCron周期扫描，检查是否符合条件，若符合所有条件则执行AOF重写<ul><li>没有子进程运行（RDB saving、AOF rewriting、其他）</li><li>当前AOF内存文件大小大于阈值，并且，当前AOF内存文件大小与最后一次AOF重写时的文件大小的比值，大于阈值时可以重写</li></ul></li></ul><h2 id="5-4-AOF后台执行重写"><a href="#5-4-AOF后台执行重写" class="headerlink" title="5.4.AOF后台执行重写"></a>5.4.AOF后台执行重写</h2><p>为了不让AOF这类日志操作影响正常的命令处理，Redis决定将AOF重写功能交由子进程执行（fork操作与前文同理），这样做的好处是：</p><ul><li>子进程处理AOF重写期间，主进程还可以继续响应命令</li><li>由于fork会写时复制父进程的当前数据，所以避免了父子进程的数据访问冲突，即在不加锁的情况下保证了数据安全</li></ul><p>如果父进程在AOF期间修改了数据，那么对子进程是不可见的，即产生了数据的不一致性。解决方案是，当Redis fork出子进程准备进入AOF重写时，会在主进程设置一个AOF重写缓冲区，专门记录子进程运行期间产生的不可见的数据更改。此时服务器处理命令的行为是：</p><ol><li>执行客户端命令</li><li>将命令追加到AOF缓冲区（前文介绍的，用于生成AOF文件，不要和AOF重写弄混）</li><li>将命令追加到AOF重写缓冲区</li></ol><p>当子进程处理完重写操作，生成好了新的AOF文件时，会发送一个信号给父进程，父进程在接收到这个信号后，会阻塞命令处理，进行以下行为：</p><ol><li>将AOF重写缓冲区的所有命令追加到新AOF文件末尾，这样一来，新的AOF文件就与当前数据库状态完全一致了</li><li>对新文件进行改名，原子地覆盖现有AOF文件</li></ol><p>至此，AOF重写大功告成。我们还需要回答几个问题：</p><p><strong>为什么不能用AOF缓冲区，要新开辟一片AOF重写缓冲区？</strong></p><p>一，目的不同。AOF缓冲区的目的是伴随着命令的处理，不断地追加AOF文件的。AOF重写缓冲区的目的是解决子进程AOF重写期间造成的数据不一致。</p><p>二，使用方式不同。前文说过，AOF缓冲区会根据具体策略，选择不同时机写入磁盘。AOF重写缓冲区是在子进程处理完成后，一次性追加到新的AOF文件末尾的。</p><p>三，“内容不一致”。AOF缓冲区会根据策略选择不同时机写入磁盘，意味着有可能出现缓冲区内容不断变化。极端一点，有可能在子进程AOF重写期间，AOF缓冲区就因为不断地写入内存，而产生变化。反观AOF重写缓冲区，他的职责是记录所有子进程处理期间的命令，所以不会发生上述情况。</p><p><strong>为什么不直接重写原AOF文件，而是等重写的最后再用生成好的新文件替换原AOF文件？</strong></p><p>一，子进程复用原AOF文件，必然会在某些时候和父进程产生争抢，从而影响父进程性能，这和我们一开始用子进程负责AOF重写的初衷不符。</p><p>二，若AOF重写过程中失败，复用原文件会对其产生污染，导致AOF功能不可用。</p><h1 id="六-事件"><a href="#六-事件" class="headerlink" title="六.事件"></a>六.事件</h1><p>Redis服务器主进程就是一个事件循环处理函数，依次处理文件事件与时间事件：</p><ul><li>文件事件：负责接收客户端的命令请求，以及向客户端发送命令回复。Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件完成一系列网络通信操作。</li><li>时间事件：负责处理像serverCron()函数这样需要定时运行的函数，时间事件就是对这类定时操作的抽象。</li></ul><h2 id="6-1-文件事件"><a href="#6-1-文件事件" class="headerlink" title="6.1.文件事件"></a>6.1.文件事件</h2><h3 id="6-1-1-基于Reactor-I-O多路复用模式的文件事件处理器"><a href="#6-1-1-基于Reactor-I-O多路复用模式的文件事件处理器" class="headerlink" title="6.1.1.基于Reactor I/O多路复用模式的文件事件处理器"></a>6.1.1.基于Reactor I/O多路复用模式的文件事件处理器</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/event-loop.png"></p><p>文件事件处理器由四部分组成：套接字、I/O多路复用程序、文件事件分派器、文件事件处理器：</p><ul><li>套接字<ul><li>文件事件是对套接字操作的抽象。每当一个套接字准备好执行链接应答、写入、读取、关闭等操作时，就会产生一个文件事件。</li></ul></li><li>I/O多路复用程序<ul><li>同时监听多个套接字，既实现了高性能的网络通信模型，又可以很好地与Redis服务器中同样以单线程运行的模块对接。</li><li>尽管由于服务器连接的多个套接字会并发地产生文件事件，但I/O多路复用程序总是会将所有产生事件的套接字，按照先后顺序、同步、每次一个的方案依次加入队列中，然后将套接字传送给文件事件分派器。只有当上一个套接字产生的事件被处理完毕后，I/O多路复用程序才会向文件事件分派器传送下一个套接字。</li></ul></li><li>文件事件分派器<ul><li>接收I/O多路复用程序传送来的套接字，根据套接字产生的事件的类型，为其关联不同的事件处理器进行处理。</li><li>文件事件类型：<ul><li>AE_READABLE：当套接字变得可读时（客户端对套接字执行connect、write、close操作），套接字产生AE_READABLE事件</li><li>AE_WRITABLE：当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件</li><li>当一个套接字同时产生AE_READABLE、AE_WRITABLE两类事件时，服务器会先处理AE_READABLE事件，再处理AE_WRITABLE事件。</li></ul></li></ul></li><li>文件事件处理器<ul><li>执行实际的处理动作。</li><li>分类：<ul><li>连接应答处理器：当服务器初始化的时候，会降<strong>服务器监听套接字的AE_READABLE事件</strong>与连接应答处理器关联起来。当有客户端连接服务器监听套接字时，套接字就会产生AE_READABLE事件，从而引发连接应答处理器的执行，并执行相应的套接字应答操作。</li><li>命令请求处理器：当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将<strong>客户端套接字的AE_READABLE事件</strong>和命令请求处理器关联起来。当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，从而引发命令请求处理器的执行，并执行相应的套接字读取操作。</li><li>命令回复处理器：当服务器有命令回复需要传输给客户端的时候，服务器会将<strong>客户端套接字的AE_WRITABLE事件</strong>和命令响应处理器关联起来。当客户端准备好接收服务器的命令回复的时候，套接字就会产生AE_WRITABLE事件，从而引发命令回复处理器的执行，并执行相应的套接字写入操作。</li><li>其他</li></ul></li></ul></li></ul><h3 id="6-1-2-一次完整的客户端与服务器连接事件示例"><a href="#6-1-2-一次完整的客户端与服务器连接事件示例" class="headerlink" title="6.1.2.一次完整的客户端与服务器连接事件示例"></a>6.1.2.一次完整的客户端与服务器连接事件示例</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/event-loop-demo.png"></p><ol><li>假设Redis服务器已经启动完成，那么此时服务器监听套接字的AE_READABLE事件会与连接应答处理器关联起来，并处于监听状态。</li><li>客户端向服务器发起建立 socket 连接的请求，监听套接字会产生AE_READABLE事件，触发连接应答处理器执行。连接应答处理器会对客户端的连接请求进行应答，创建客户端套接字及客户端状态，并将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，并处于监听状态。</li><li>客户端建立连接后，向服务器发送命令，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行。命令请求处理器读取客户端命令，然后传递给相关程序去执行。</li><li>执行命令获得相应的命令回复后，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器执行。命令回复处理器将命令回复全部写入到套接字中后，就会解除客户端套接字的 AE_WRITEABLE 事件与命令回复处理器的关联。</li><li>命令回复会由套接字负责传输给客户端。</li></ol><h2 id="6-2-时间事件"><a href="#6-2-时间事件" class="headerlink" title="6.2.时间事件"></a>6.2.时间事件</h2><p>时间事件的具体定义结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct aeTimeEvent &#123;<br>    <span class="hljs-comment">/* 全局唯一ID */</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> id; <span class="hljs-comment">/* time event identifier. */</span><br>    <span class="hljs-comment">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span><br>    <span class="hljs-keyword">long</span> when_sec; <span class="hljs-comment">/* seconds */</span><br>    <span class="hljs-comment">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span><br>    <span class="hljs-keyword">long</span> when_ms; <span class="hljs-comment">/* milliseconds */</span><br>    <span class="hljs-comment">/* 时间处理器 */</span><br>    aeTimeProc *timeProc;<br>    <span class="hljs-comment">/* 事件结束回调函数，析构一些资源*/</span><br>    aeEventFinalizerProc *finalizerProc;<br>    <span class="hljs-comment">/* 私有数据 */</span><br>    <span class="hljs-keyword">void</span> *clientData;<br>    <span class="hljs-comment">/* 前驱节点 */</span><br>    struct aeTimeEvent *prev;<br>    <span class="hljs-comment">/* 后继节点 */</span><br>    struct aeTimeEvent *next;<br>&#125; aeTimeEvent;<br></code></pre></td></tr></table></figure><p>时间事件分类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。</li></ul><p>区分时间事件类型的方法是通过时间事件处理器的返回值：</p><ul><li>如果返回值是 <code>AE_NOMORE</code>，那么这个事件是一个定时事件，该事件在到达后会被删除，之后不会再重复。</li><li>如果返回值是非 <code>AE_NOMORE</code> 的值，那么这个事件为周期性事件，当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 when 属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新下去。</li></ul><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/time-event-list.png"></p><p>Redis服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器处理。新产生的时间事件总是插到链表头。由于正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能。</p><p>综上所述，处理时间事件的函数如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">processTimeEvents</span><span class="hljs-params">(aeEventLoop *eventLoop)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maxId = eventLoop-&gt;timeEventNextId-<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/* 遍历服务器中的所有时间事件 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-function">timeEvent in <span class="hljs-title">allTimeEvent</span><span class="hljs-params">()</span>) </span>&#123;<br>        <span class="hljs-keyword">long</span> now_sec, now_ms;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> id;<br><br>        <span class="hljs-comment">/* 删除需要删除的时间事件 */</span><br>        <span class="hljs-keyword">if</span> (timeEvent.id == AE_DELETED_EVENT_ID) &#123;<br>            <span class="hljs-comment">// 从链表中删除</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* id 大于最大maxId,是该循环周期生成的时间事件，不处理 */</span><br>        <span class="hljs-keyword">if</span> (timeEvent.id &gt; maxId) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        aeGetTime(&amp;now_sec, &amp;now_ms);<br>        <span class="hljs-comment">/* 事件已经到达，调用其timeProc函数 */</span><br>        <span class="hljs-keyword">if</span> (timeEvent.whenSec &lt;= now)<br>        &#123;<br>            <span class="hljs-keyword">int</span> retval = timeEvent.timeProc(eventLoop, id, timeEvent.clientData);<br>            <br>            <span class="hljs-comment">/* 如果返回值不等于 AE_NOMORE,表示是一个周期性事件，修改其whenSec和whenMs属性*/</span><br>            <span class="hljs-keyword">if</span> (retval != AE_NOMORE) &#123;<br>                aeAddMillisecondsToNow(retval, timeEvent.whenSec, timeEvent.whenMs);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* 一次性事件，标记为需删除，下次遍历时会删除*/</span><br>                timeEvent.id = AE_DELETED_EVENT_ID;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>serverCron函数默认每100ms执行一次，可以通过修改hz配置来调整其执行周期，它的职责包括：</p><ul><li>更新服务器的各类统计信息</li><li>清理过期键值对</li><li>关闭和清理连接失效的客户端</li><li>尝试进行RDB或AOF持久化</li><li>如果服务器是master，那么对slave进行定期同步</li><li></li></ul><h1 id="七-客户端"><a href="#七-客户端" class="headerlink" title="七.客户端"></a>七.客户端</h1><h1 id="八-服务端"><a href="#八-服务端" class="headerlink" title="八.服务端"></a>八.服务端</h1><p><strong>todo list</strong></p><ul><li><input disabled="" type="checkbox"> 图完善</li><li><input disabled="" type="checkbox"> 源码解读</li><li><input disabled="" type="checkbox"> 最新版本Redis由获取客户端目标数据库的命令了吗？</li><li><input disabled="" type="checkbox"> 为什么Redis不允许对象类型嵌套使用？</li><li><input disabled="" type="checkbox"> Redis最新的时间事件实现</li><li><input disabled="" type="checkbox"> 新版本Redis实现的notifyKeyspaceEvent，有采样机制，会导致大量key过期时阻塞</li><li><input disabled="" type="checkbox"> RDB文件结构及解析工具</li><li><input disabled="" type="checkbox"> 详细说copy on write机制</li><li><input disabled="" type="checkbox"> aof延迟</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础-基本数据结构与对象</title>
    <link href="/2023/05/30/Redis%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/30/Redis%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>我们使用redis时，最直观接触到的就是redis对象及其命令。那我们今天就一起了解下这些对象的实现细节。</p><h1 id="一-基本数据结构"><a href="#一-基本数据结构" class="headerlink" title="一.基本数据结构"></a>一.基本数据结构</h1><h2 id="1-简单动态字符串-SDS"><a href="#1-简单动态字符串-SDS" class="headerlink" title="1.简单动态字符串 SDS"></a>1.简单动态字符串 SDS</h2><p>redis是用C语言实现的，我们需要先认识一下C语言里面的字符串（以下简称C字符串）。</p><p>“Redis\0”这是一个C语言字符串，它具有以下特点：</p><ul><li>必须以 ‘\0’ 空字符结尾</li><li>系统不维护该字符串的长度（不像java的String类型有length），获取字符串长度必须遍历整个字符串，即时间复杂度为 O(n)</li><li>每次更改（缩短或增长）字符串都需要重新内存分配，否则可能造成内存泄漏或缓冲区溢出</li><li>只能保存文本数据</li><li>C语言有相关代码库，支持各类字符串操作</li></ul><p>对于redis而言，只有像log这类字符串一定没有变化的场景会使用C字符串实现以外，其余大多数场景都使用它自己的SDS来实现字符串，例如：</p><ul><li>命令里的key和value SET name “xqz”</li><li>各类嵌套对象 [“a”, “b”]</li><li>缓冲区：AOF缓冲区、客户端的输入输出缓冲区</li><li>等等</li></ul><p>SDS的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDS</span> </span>&#123;<br><span class="hljs-comment">// 记录buf中已经被使用的长度</span><br>  <span class="hljs-keyword">int</span> len;<br>  <span class="hljs-comment">// 记录buf中没有被使用的长度</span><br>  <span class="hljs-keyword">int</span> free;<br>  <span class="hljs-comment">// 实际存储字符串的地方</span><br>  <span class="hljs-comment">// 其末尾以&#x27;\0&#x27;结尾，不记录在上述两个长度内，即SDS实际字符长度为 len+free+1</span><br>  <span class="hljs-keyword">char</span>[] buf;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们可以解释 SDS 名称的由来：</p><ul><li>简单：相比于C字符串，要获取SDS内的字符串长度，可以直接通过len字段，时间复杂度为 O(1)</li><li>动态：每次对 SDS增长时，redis都会自己检查free是否充足，如果不够，那么就会自动进行内存分配以获取足够的空间，即redis保证了不会发生缓冲区溢出</li></ul><p>那么，我们又引申出一个小问题，那就是sds的内存分配策略：</p><ul><li>字符串增长时<ul><li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li><li><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/sds_edit.png"></li></ul></li><li>字符串减短时<ul><li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li></ul></li></ul><p>总结，SDS相比于C字符串的特点是：</p><ul><li>实际也以 ‘\0’ 空字符结尾</li><li>获取字符串长度的时间复杂度为 O(1)</li><li>每次更改（缩短或增长）字符串，调用者不需要重新内存分配，redis会保证不造成内存泄漏或缓冲区溢出</li><li>sds的所有api都是二进制安全的，即sds不仅可以保存文本数据，还可以保存任意格式的二进制数据</li><li>因为实际以 ‘\0’ 字符结尾，可以使用C语言相关代码库</li></ul><h2 id="2-双向链表LinkedList（已经被快速链表代替）"><a href="#2-双向链表LinkedList（已经被快速链表代替）" class="headerlink" title="2.双向链表LinkedList（已经被快速链表代替）"></a><del>2.双向链表LinkedList（已经被快速链表代替）</del></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> </span>&#123;<br>  <span class="hljs-comment">// 头节点指针</span><br>  ListNode head;<br>  <span class="hljs-comment">// 尾节点指针</span><br>  ListNode tail;<br>  <span class="hljs-comment">// 链表总长度</span><br>  uint64 len;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 前一个节点指针</span><br>  ListNode pre;<br>  <span class="hljs-comment">// 后一个节点指针</span><br>  ListNode next;<br>  <span class="hljs-comment">// 指向具体内容的指针</span><br>  Object value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-键值对映射HashTable（字典）"><a href="#3-键值对映射HashTable（字典）" class="headerlink" title="3.键值对映射HashTable（字典）"></a>3.键值对映射HashTable（字典）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dict</span> </span>&#123;<br>  <span class="hljs-comment">// 为对象多态服务，DictType保存了针对每种不同类型键值对的特定函数</span><br>  DictType type;<br>  <span class="hljs-comment">// 为对象多态服务，保存了不同特定函数的可选参数</span><br>  Object privData;<br>  <span class="hljs-comment">// ht[0]指向正在使用的hash表，ht[1]正常情况下指向null，rehash过程中指向即将迁移过去的hash表</span><br>  DictHt[] ht;<br>  <span class="hljs-comment">// rehash索引</span><br>  <span class="hljs-keyword">int</span> rehashidx;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictHt</span> </span>&#123;<br>  <span class="hljs-comment">// hash桶，存储具体数据</span><br>  DictEntry[] table;<br>  <span class="hljs-comment">// 桶大小</span><br>  uint64 size; <br>  <span class="hljs-comment">// 桶已使用大小</span><br>  uint64 used;<br>  <span class="hljs-comment">// 用于计算对象下标，sizemask=size-1</span><br>  uint64 sizemask;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictEntry</span> </span>&#123;<br>  <span class="hljs-comment">// 只能是字符串类型</span><br>  Object key;<br>  <span class="hljs-comment">// 对象多态</span><br>  <span class="hljs-comment">// 另外，并没有使用字符串对象处理整数和普通对象，下面讲字符串对象时会涉及</span><br>  union &#123;<br>    <span class="hljs-comment">// value类行为对象</span><br>    Object v;<br>    <span class="hljs-comment">// value类型为无符号整数</span><br>    uint64 u64;<br>    <span class="hljs-comment">// value类型为有符号整数</span><br>    int64 s64;<br>  &#125; value;<br>  <span class="hljs-comment">// 拉链法解决hash冲突：key相同的下一个value对象</span><br>  DictEntry next;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然提到hash，那么着重解决一下几个问题：</p><ul><li>hash函数怎么选择？</li><li>hash冲突如何解决？</li><li>如何维护hash冲突的概率？</li></ul><h3 id="3-1-hash函数如何选择？"><a href="#3-1-hash函数如何选择？" class="headerlink" title="3.1.hash函数如何选择？"></a>3.1.hash函数如何选择？</h3><p>redis选用<a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C">murmurhash2</a>算法生成key对应的hash值，记做hash(key)，则最终插入下标index=hash(key) &amp; ht[x].sizemask。这里面信息量比较大，我们一一介绍：</p><ul><li>若N为2的n次幂，则 H%N = H&amp;(N-1)，这是快速计算方式，并且后续会看到redis保证桶大小为2的n次幂（java的HashMap也有类似设计），这里也解释了为什么会有一个sizemask字段</li><li>ht[x]的含义是，若当前字典不是rehash状态，则x=0，否则x=1</li></ul><h3 id="3-2-hash冲突如何解决？"><a href="#3-2-hash冲突如何解决？" class="headerlink" title="3.2.hash冲突如何解决？"></a>3.2.hash冲突如何解决？</h3><p>一般的hash冲突解决方法有两种：开放定址法和拉链法，redis和java.HashMap均采用拉链法，即将hash到相同桶下标的entry组织成一个链表（java的HashMap在链表长度大于8时，会将该链表转换为一棵红黑树，即平衡树，依次来提高检索效率）。</p><p>另外，此处的链表不是双向链表，所以采用头插法快速添加新节点（多嘴说一句，并发环境下，头插法可能产生循环链表问题，jdk8前后的解决方法并不相同，感兴趣的小伙伴可以搜一搜，但是单线程的redis并不存在这个问题）</p><h3 id="3-3-如何维护hash冲突的概率？"><a href="#3-3-如何维护hash冲突的概率？" class="headerlink" title="3.3.如何维护hash冲突的概率？"></a>3.3.如何维护hash冲突的概率？</h3><p>介绍一个概念：负载因子=桶已被使用的大小/桶总大小，可以看出，若负载因子过大，则产生hash冲突的可能性就更高，若负载因子过小，则空间利用率就变低。因此，根据负载因子大小，在合适的时机调整桶大小就变的尤为重要。</p><p>下面是redis执行的rehash的具体步骤：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/rehash.png"></p><ul><li>负载因子过大：<ul><li>服务器没有执行 <a href="https://www.runoob.com/redis/server-bgsave.html">BGSAVE</a> 或 <a href="https://www.runoob.com/redis/server-bgrewriteaof.html">BGREWRITEAOF</a> 命令时，&gt;=1，这是因为这些命令都会采取写时复制的手段来优化子进程的执行效率，那么就需要降低非必要的内存写入操作</li><li>服务器执行 BGSAVE 或 BGREWRITEAOF 命令时，&gt;=5</li></ul></li><li>负载因子过小：&lt;0.1</li></ul><p>最后，需要注意，rehash过程不是一次性完成的，而是延迟、渐进式的完成的，其过程是：</p><ol><li>rehash开始，将rehashidx置为0，代表rehash开始</li><li>其后每次对该字典有增删改查（包括rehash开始时的那一次）操作时，都会将ht[0]桶rehashidx位置上的数据重新写入到ht[1]桶内，删除ht[0]桶rehashidx位置上的所有数据，rehashidx++</li><li>当ht[0]桶上所有数据都迁移完成后，将rehashidx置为-1，代表rehash结束</li></ol><p>很明显，在rehash期间，插入操作会直接在ht[1]桶上完成（保证ht[0]只减不增，另外，先插入到ht[0]再rehash到ht[1]也太傻了），删除、更改、查询操作都会先检索ht[0]，数据不存在时再检索ht[1]得到最终结果</p><h2 id="4-跳表SkipList"><a href="#4-跳表SkipList" class="headerlink" title="4.跳表SkipList"></a>4.跳表SkipList</h2><p>鉴于大学的数据结构课本或者《算法导论》这样的书上都没有跳表的内容，所以我们得先介绍下跳表这种数据结构（这里奉上原始论文，感兴趣的同学可以看看<a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf%EF%BC%89%E3%80%82">https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf）。</a></p><p>这是一个链表：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist1.png"></p><p>我们给他加一点索引，用来加快检索速度：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist2.png"></p><p>当数据量特别大的时候，我们可能需要多层索引，获取更好的检索速度：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist3.png"></p><p>好了，我们可以做一个优化，即相同元素（初始元素及该元素代表的索引）只使用一个节点即可。</p><p>这就是跳表，我们来看下跳表如何检索一个元素（下述跳表中查找71）：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist4.png"></p><p>其时间复杂度 = 索引的高度 * 每层索引遍历元素的个数，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。那么跳表的总高度 h = log2n。并且，上层两个索引中间对应的下层索引个数最多为3，即时间复杂度=O(log2n)。</p><p>空间复杂度显然等于 n/2+n/4+…+n/h=O(n)。</p><p>那么，接下来的问题就变成了，随着元素的插入/删除，我们应该如何去维护跳表的索引，以使其保持优良的性能？</p><p>一种设计方案是，还是假设每两个结点会抽出一个结点作为上一级索引的结点，那么当本层元素大于3时，我们就要将其分裂为两部分，并且在上层添加这两部分的索引。删除同理。好了，说到这你应该意识到，这是B树的设计。</p><p>另一种方案，即跳表天才的设计，用概率来维护索引。即每个元素都有1/2的概率建立上层索引，当数据量足够大时，我们有理由相信这种概率建立起来的索引是离散的，即所有元素不会堆积在一起。</p><p>那么，我们来看一下跳表如何插入元素。假设在我们插入元素时，有一个函数randomLevel(x)，其返回值表示应该为这个元素新建几层索引。例如，randomLevel(x)=2，则新建1层索引。我们保证，randomLevel(x)函数有1/2的概率返回1，有1/4的概率返回2，以此类推。有的小伙伴会问，为什么不是randomLevel(x)=1新建一层索引呢？这是因为，只要randomLevel(x)&gt;1那么就会新建第一层的索引，那么randomLevel(x)=1的概率为1/2，就等同于第一层索引不被建立的概率等于1/2，那么，只要randomLevel(x)=2我们再开始建立索引就可以了。</p><p>我们举一个插入87的例子，randomLevel(87)=3，</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist5.png"></p><p>最后看一眼删除（删除87），我们只需要该元素整个删除即可（包括该元素代表的索引）：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png"></p><p>至此，我们可以介绍下redis的跳表了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br>  <span class="hljs-comment">// 指向跳表头节点</span><br>  <span class="hljs-comment">// 头节点不是实际的元素节点，即不计算在level、length内</span><br>  SkipListNode header;<br>  <span class="hljs-comment">// 指向跳表尾节点</span><br>  <span class="hljs-comment">// 尾节点是实际的元素节点</span><br>  SkipListNode tail;<br>  <span class="hljs-comment">// 层数最大的节点的层数</span><br>  <span class="hljs-keyword">int</span> level;<br>  <span class="hljs-comment">// 节点个数</span><br>  <span class="hljs-keyword">int</span> length;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 分数，redis跳表通过分数作为元素插入位置的依据</span><br>  <span class="hljs-comment">// 分数按从小到大的顺序排列</span><br>  <span class="hljs-comment">// 不同元素分数可以相同，但是对象不能相同。相同分数的不同对象按照字典序排列。</span><br>  <span class="hljs-keyword">double</span> score;<br>  <span class="hljs-comment">// 对象指针</span><br>  Object obj;<br>  <span class="hljs-comment">// 后退指针，指向紧邻的前一个元素。注意，后退指针不参与跳表的索引结构，就像B+树的叶子结点链表一样，将所有的元素节点连接起来。方便检索范围内的所有数据。</span><br>  SkipListNode backward;<br>  <span class="hljs-comment">// 层（上述的各层索引）</span><br>  <span class="hljs-comment">// Level1-Level32，L1可以看做之前讲的基础数据，L2-L32可以看做索引</span><br>  SkipListLevel[] level;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListLevel</span> </span>&#123;<br>  <span class="hljs-comment">// 前进指针，指向拥有同层索引的下一个节点</span><br>  SkipListNode forward;<br>  <span class="hljs-comment">// 跨度，注意，跨度并不参与实际的检索过程（有疑惑的抛开redis再看看前面的跳表介绍），只是用于计算同层两个节点间的元素个数</span><br>  uint32 span;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们看一下redis如何实现前述的randomLevel(x)函数的：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png"></p><p>上述代码等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">func <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level+1</span><br>  <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>    level += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，redis设置的SKIPLIST_P=0.25，即每4个元素生成一个上层索引</p><h2 id="5-整数集合IntSet"><a href="#5-整数集合IntSet" class="headerlink" title="5.整数集合IntSet"></a>5.整数集合IntSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSet</span> </span>&#123;<br>  <span class="hljs-comment">// 编码方式（注意与之后对象结构内的编码方式区分）</span><br>  <span class="hljs-comment">// 目前支持：int16、int32、int64</span><br>  uint32 encoding;<br>  <span class="hljs-comment">// 集合长度，即元素个数</span><br>  uint32 length;<br>  <span class="hljs-comment">// 具体数据，不会有重复值，按值大小从小往大排列</span><br>  <span class="hljs-comment">// 需要注意，具体数据类型与编码格式相关，并不是int8类型</span><br>  int8[] contents;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入元素的执行步骤：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/intsetAdd.png"></p><p>整数数组的特点是：</p><ul><li>灵活：支持不同类型的整数</li><li>节约内存：并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li><li>一旦编码升级，就不会降级了</li></ul><h2 id="6-压缩列表ZipList（已经被快速链表代替）"><a href="#6-压缩列表ZipList（已经被快速链表代替）" class="headerlink" title="6.压缩列表ZipList（已经被快速链表代替）"></a><del>6.压缩列表ZipList（已经被快速链表代替）</del></h2><p>压缩列表是为节约内存而开发的，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。其编码格式为：</p><table><thead><tr><th align="left">记录整个压缩列表占用的内存字节数</th><th align="left">记录压缩列表尾节点距离起始位置的字节数</th><th align="left">记录节点个数</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">特殊值0xFF，标志压缩列表结尾</th></tr></thead><tbody><tr><td align="left">zlbytes</td><td align="left">zltail</td><td align="left">zllen</td><td align="left">entry1</td><td align="left">…</td><td align="left">entryn</td><td align="left">zlend</td></tr><tr><td align="left">4B</td><td align="left">4B</td><td align="left">2B</td><td align="left">不定</td><td align="left">不定</td><td align="left">不定</td><td align="left">1B</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>根据压缩列表地址p和zltail，我们可以计算出尾节点的起始位置p+zltail</li><li>若节点数&lt;65535，则zllen代表真实的节点数量，否则真实数量只能通过遍历压缩列表得到</li></ul><p>其中，entry的编码格式为：</p><table><thead><tr><th align="left">前一节点的长度（单位：B）</th><th align="left">记录了content的数据类型和长度</th><th align="left">具体值</th></tr></thead><tbody><tr><td align="left">previous_entry_length</td><td align="left">encoding</td><td align="left">content</td></tr><tr><td align="left">1B or 5B</td><td align="left">1B、2Bor5B</td><td align="left">不定</td></tr></tbody></table><p>特殊说明：</p><ul><li>previous_entry_length<ul><li>若前一节点长度小于254B，则其长度就保存在1B内</li><li>否则，previous_entry_length长度为5B，其第一字节被设置为固定值0xFE（254），后4字节保存前一节点的实际长度</li></ul></li><li>encoding<ul><li>字节数组编码<ul><li>1B，00开头，content长度由去除头两位的其余位表达</li><li>2B，01开头，content长度由去除头两位的其余位表达</li><li>5B，10开头，content长度由去除头两位的其余位表达</li></ul></li><li>整数编码<ul><li>1B，11开头，不同编码代表了不同的int类型</li><li>特殊的，1111开头，对应节点没有content字段，剩余四位表达具体数据</li></ul></li></ul></li></ul><p>压缩列表的遍历方式：</p><ol><li>根据压缩列表起始地址p和zltail，计算出尾节点的起始位置 pn=p+zltail</li><li>根据pn，获取到pn-1的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>根据pn-1，获取到pn-2的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>…</li><li>根据p1，获取到p0的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>结束遍历</li></ol><p>最后，当我们插入或者删除数据时，有可能会导致原本用1B记录前一节点大小的previous_entry_length不够用了，从而引发一连串的节点更新，这种现象就叫做“连锁更新”。连锁更新时，最终压缩列表的大小需要依次计算得出，时间复杂度为O(n)，但是最终只需要一次内存分配。</p><p>总结下压缩列表的优缺点：</p><ul><li>优点<ul><li>节省空间</li></ul></li><li>缺点<ul><li>因为需要遍历访问，不适合保存过多元素</li><li>因为可能会引发连锁更新，所以不适合保存过大元素</li></ul></li></ul><h2 id="7-快速链表QuickList"><a href="#7-快速链表QuickList" class="headerlink" title="7.快速链表QuickList"></a>7.快速链表QuickList</h2><p>简单说，快速链表=双向链表+压缩列表，即双向链表的每个节点是一个压缩列表。这么做的目的是在获得压缩列表节约空间的好处同时，解决压缩列表无法存储过多元素的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quicklist</span> </span>&#123;<br>    <span class="hljs-comment">// quicklist 的链表头</span><br>    QuicklistNode head;<br>    <span class="hljs-comment">// quicklist 的链表尾</span><br>    QuicklistNode tail;<br>    <span class="hljs-comment">// 所有 ziplist 中的总元素个数</span><br>    <span class="hljs-keyword">long</span> count;<br>    <span class="hljs-comment">// quicklistNodes 的个数</span><br>    <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-comment">// 控制每个node中ziplist的元素个数</span><br>    <span class="hljs-comment">// 负数-n表示ziplist大小小于2^(n+1)KB</span><br>    <span class="hljs-comment">// 正数n表示ziplist元素个数小于n</span><br>    <span class="hljs-keyword">long</span> fill;<br>    <span class="hljs-comment">// 其他</span><br>    ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuicklistNode</span> </span>&#123;<br>    <span class="hljs-comment">// 前一个链表节点</span><br>    QuicklistNode prev;<br>    <span class="hljs-comment">// 后一个链表节点</span><br>    QuicklistNode next;<br>    <span class="hljs-comment">// 本节点是存储处元素的 ziplist</span><br>    <span class="hljs-comment">// 字节形式存储</span><br>    <span class="hljs-keyword">char</span> zl;<br>    <span class="hljs-comment">// ziplist 的字节大小</span><br>    <span class="hljs-keyword">int</span> sz;<br>    <span class="hljs-comment">// ziplist 的元素个数</span><br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-comment">// 原始字节=1</span><br>    <span class="hljs-comment">// 压缩存储=2</span><br>    <span class="hljs-keyword">int</span> encoding;<br>    <span class="hljs-comment">// 存储方式</span><br>    <span class="hljs-comment">// null=1</span><br>    <span class="hljs-comment">// ZIPLIST=2</span><br>    <span class="hljs-keyword">int</span> container;<br>    <span class="hljs-comment">// 数据是否被压缩</span><br>    <span class="hljs-keyword">int</span> recompress;<br>    <span class="hljs-comment">// 数据能否被压缩</span><br>    <span class="hljs-keyword">int</span> attempted_compress;<br>    <span class="hljs-comment">// 预留的 bit 位</span><br>    <span class="hljs-keyword">int</span> extra;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终结果如图所示：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/quicklist.png"></p><p>当往快速链表中插入数据时（以链表tail插入为例），若tail对应的ziplist已满，则需要创建新的node，当前节点的next指向新node，tail也指向新node，把元素插入到新node的ziplist中去。</p><h2 id="8-紧凑链表ListPack"><a href="#8-紧凑链表ListPack" class="headerlink" title="8.紧凑链表ListPack"></a>8.紧凑链表ListPack</h2><h3 id="8-1-编码格式"><a href="#8-1-编码格式" class="headerlink" title="8.1.编码格式"></a>8.1.编码格式</h3><p>本质上说，quickList并没有从根本上解决zipList连锁更新的问题，他只是将连锁更新的范围控制在一个节点内。并且，链表指针也会消耗内存空间，这不符合压缩列表的初衷。因此，根本解决方案就是紧凑列表ListPack。</p><p>压缩列表之所以会出现连锁更新的问题，本质上是因为单个元素大小的变动，会影响其相邻元素的previous_entry_length字段占用的空间大小，从而级联影响下去。那我们就需要在干掉这个previous_entry_length的情况下，依然支持对元素进行遍历。</p><p>我们看看ListPack的编码格式：</p><table><thead><tr><th align="left">记录整个紧凑列表占用的内存字节数</th><th align="left">记录紧凑列表的元素总数</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">特殊值0xFF，标志j紧凑列表结尾</th></tr></thead><tbody><tr><td align="left">totalBytes</td><td align="left">numElements</td><td align="left">element1</td><td align="left">…</td><td align="left">elementn</td><td align="left">listpackEndByte</td></tr><tr><td align="left">4B</td><td align="left">2B</td><td align="left">不定</td><td align="left">不定</td><td align="left">不定</td><td align="left">1B</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>若节点数&lt;65535，则numElements代表真实的节点数量，否则真实数量只能通过遍历紧凑列表得到</li></ul><p>其中，element的编码格式为：</p><table><thead><tr><th align="left">当前元素数据类型以及值长度</th><th align="left">具体值</th><th>当前元素总长度</th></tr></thead><tbody><tr><td align="left">encodingType</td><td align="left">data</td><td>tolLen</td></tr><tr><td align="left">不定</td><td align="left">不定</td><td>不定</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>encodingType和tolLen一定有值，但是data不一定，因为若data过小，会直接存储在encodingType内（下面会介绍）。</li><li>element只记录了当前元素的长度，所以不会引起压缩列表那样的连锁更新。</li></ul><p>编码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>|xxxxxxx// 表示<span class="hljs-number">7</span>位无符号整数，encodingType后<span class="hljs-number">7</span>位为data<br><span class="hljs-attribute">10</span>|xxxxxx// 表示短字符串，后<span class="hljs-number">6</span>位表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">110</span>|xxxxx// 表示<span class="hljs-number">13</span>位有符号整数，后<span class="hljs-number">5</span>位+下个字节存储具体数字<br><span class="hljs-attribute">1110</span>|xxxx// 表示<span class="hljs-number">12</span>位长度的字符串，后<span class="hljs-number">4</span>位+下个字节表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0000</span>// 表示长字符串，后<span class="hljs-number">4</span>字节表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0001</span>// 表示<span class="hljs-number">16</span>位有符号整数，后<span class="hljs-number">2</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0010</span>// 表示<span class="hljs-number">24</span>位有符号整数，后<span class="hljs-number">3</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0011</span>// 表示<span class="hljs-number">32</span>位有符号整数，后<span class="hljs-number">4</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0100</span>// 表示<span class="hljs-number">64</span>位有符号整数，后<span class="hljs-number">8</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0101</span> - <span class="hljs-number">1111</span>|<span class="hljs-number">1110</span>// 未使用<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">1111</span>// 结尾标志占用<br></code></pre></td></tr></table></figure><p>备注：</p><ul><li>处于复杂度和性能考虑，并未使用1111|0001 - 1111|1110这些编码去表达各种长度的有/无符号整数。</li></ul><p>最后是当前元素总长度的编码方式。由于encodingType及data的长度不固定，所以tolLen的长度也不是固定的。其编码方式是从当前的element的最右侧（结束位置）开始，一字节一字节的解析。其中，每一字节的最高位表示是否还需要更多的字节（0不需要，1需要），剩余7位就是长度的二进制表示部分。我们通过从右往左不断遍历每一字节，获取长度的所有二进制位，最终将他们拼接起来就是tolLen的值了。</p><p>例如，tolLen=500时，500的二进制表示为：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">111110100</span><br></code></pre></td></tr></table></figure><p>那么，我们就需要用两个字节来表示它：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>]<span class="hljs-number">0000011</span> [<span class="hljs-number">1</span>]<span class="hljs-number">1110100</span><br></code></pre></td></tr></table></figure><h3 id="8-2-正向查询元素"><a href="#8-2-正向查询元素" class="headerlink" title="8.2.正向查询元素"></a>8.2.正向查询元素</h3><p>正向遍历使用不到tolLen，我们只需要根据encodingType就可以确定data的起始位置和长度了，并据此计算出tolLen的长度，即整个元素的长度。这个过程是：</p><ol><li>指针跳转到头元素的起始位置</li><li>解析encodingType，获取data的起始位置和长度</li><li>解析data内容</li><li>计算encodingType+data的长度，即为len</li><li>根据len推导出tolLen的长度，即知道了元素的总长度</li><li>跳转指针到下一个元素的起始位置</li></ol><h3 id="8-3-逆向查询元素"><a href="#8-3-逆向查询元素" class="headerlink" title="8.3.逆向查询元素"></a>8.3.逆向查询元素</h3><ol><li>指针跳转到尾元素的结束位置</li><li>从右往左解析当前元素的tolLen</li><li>计算出当前元素的起始位置和前一个元素的结束位置</li><li>从当前元素的起始位置开始，解析encodingType，获取data的起始位置和长度</li><li>解析data内容</li><li>跳转指针到前一个元素的结束位置</li></ol><h1 id="二-拓展数据结构"><a href="#二-拓展数据结构" class="headerlink" title="二.拓展数据结构"></a>二.拓展数据结构</h1><h2 id="1-位图BitMap"><a href="#1-位图BitMap" class="headerlink" title="1.位图BitMap"></a>1.位图BitMap</h2><p>位图底层就是用字符串实现的，适合记录二值状态的数据。众所周知，字符串包含多个字符，一个字符包含多个字节，一个字节又由8个bit位组成，位图正是利用每个bit位存储二值数据。</p><h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2.HyperLogLog"></a>2.HyperLogLog</h2><p>首先需要清楚，HyperLogLog是用来解决基数统计相关问题的。</p><p>这里所谓基数，就是一个集合中不重复的元素个数。举个例子：有一个数字集合{2,1,3,1,2}，它没有顺序，数字也会重复，其基数就是{1,2,3}的长度，即3。</p><p>基数统计就是计算出这个集合的基数，即不重复的元素的个数。HyperLogLog算法就是用来解决基数统计问题的，关于该算法的详情可以看这篇文章<a href="/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/" title="[基数统计算法]">[基数统计算法]</a>。</p><p>可以完成基数统计的方式如下：</p><table><thead><tr><th>数据结构</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashTable</td><td>准确，没有误差</td><td>内存占用比最大</td></tr><tr><td>BitMap</td><td>准确，没有误差<br />内存占用比HashTable小</td><td>内存占用比HyperLogLog大</td></tr><tr><td>HyperLogLog</td><td>固定占用内存12KB，就可以支持2^64个元素的基数统计</td><td>基于概率的算法，存在误差</td></tr></tbody></table><h2 id="3-GEO"><a href="#3-GEO" class="headerlink" title="3.GEO"></a>3.GEO</h2><p>GEO经常用于LBS，即基于位置的服务，指的是使用地理数据信息向用户提供服务的软件应用，例如附近美食、打车等。众所周知，我们可以使用一组经纬度信息唯一表达地理位置信息。如北京的经纬度坐标是(39.9042, 116.4074)，含义是北京处于北纬39.9042度，东经116.4074度。</p><h3 id="3-1-GEOHash编码"><a href="#3-1-GEOHash编码" class="headerlink" title="3.1.GEOHash编码"></a>3.1.GEOHash编码</h3><p>在Redis中，正是将经纬度信息作为有序集合Sorted Set的score，将业务数据作为value进行存储。但是，数组并不能直接作为score存储，需要将其转换为浮点类型数字，这就是GEOHash编码了。</p><p>经纬度信息的范围都是[-180, 180]，我们可以通过二分查找的方式不断接近真实的经纬度，还是以北京(39.9042, 116.4074)为例：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash1.png"></p><p>如图所示，维度39.9042经过三次二分最终落在区间[0, 45)内，从根节点到叶子节点的路径编码是100，也就是说，我们通过编码100就知道北京的维度在区间[0, 45)内。可想而知，随着上述二叉树的高度不断增高，即叶子节点区间更加精细，我们通过编码得到的经纬度误差也就越低。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash2.png"></p><p>同理，北京的经度编码为110。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash3.jpg"></p><p>至此，我们实际上是将整个地球的表面切割为一个个小方块，编码位数越长，每个小方块越小，即小方块所代表的经纬度精度越高。</p><p>然后将经纬度的编码进行整合，经度编码全部放在偶数位，纬度编码全部放在奇数位，那北京的最终编码为：111000。如此一来，一般情况下，经纬度相邻的位置，其小方格也相邻，即地理位置也是相邻的。但是，对于一些临界值，经纬度相邻，小方格可能差的很远，所以我们一般通过查询给定小方格四周4到8个小方格来查找相邻地理位置。</p><h1 id="三-对象"><a href="#三-对象" class="headerlink" title="三.对象"></a>三.对象</h1><p>首先，redis数据库中的数据都是通过键值对（字典）的形式组织的。其中，键key永远是字符串对象。</p><p>其次，redis中只有字符串对象可以被嵌套使用，其余对象（list、set、zset、hash对象）都不可以互相嵌套使用。例如，[“a”, “b”]是允许的，但[{“k1”: “v1”}, {“k2”: “v2”}]是不允许的。</p><p>下面是redis对象的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisObject</span> </span>&#123;<br>  <span class="hljs-comment">// 类型</span><br>  uint4 type;<br>  <span class="hljs-comment">// 具体的数据结构</span><br>  uint4 encoding;<br>  <span class="hljs-comment">// 引用计数</span><br>  <span class="hljs-keyword">int</span> refcount;<br>  <span class="hljs-comment">// 对象最后一次被命令程序访问的时间点</span><br>  <span class="hljs-keyword">int</span> lru;<br>  <span class="hljs-comment">// 指针，指向具体对象</span><br>  Object ptr;<br>&#125;<br><br><span class="hljs-comment">// 查看key对应的value.type</span><br>TYPE &#123;key&#125;<br><span class="hljs-comment">// 查看key对应的value.encoding</span><br>OBJECT ENCODING &#123;key&#125;<br></code></pre></td></tr></table></figure><h2 id="1-string对象"><a href="#1-string对象" class="headerlink" title="1.string对象"></a>1.string对象</h2><p>string对象可以用来存储整数（12345）、浮点数（123.45）、字符串（“xqz”），其底层的实现方式是不同的，我们逐个探讨。</p><h3 id="1-1-整数"><a href="#1-1-整数" class="headerlink" title="1.1.整数"></a>1.1.整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = <span class="hljs-keyword">int</span><br>obj.ptr = 具体的整数<br></code></pre></td></tr></table></figure><h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2.字符串"></a>1.2.字符串</h3><p>当创建的字符串长度 &gt; 39B时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = raw<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>当创建的字符串长度 &lt;= 39B时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>可以看到，存储字符串时，底层数据结构都是sds，但是具体的编码方式不同：</p><table><thead><tr><th align="left">编码</th><th align="left">内存结构</th><th align="left">读写操作</th></tr></thead><tbody><tr><td align="left">raw</td><td align="left">obj和sds分开申请，两片独立的内存空间，使用ptr指针连接</td><td align="left">可读/可写</td></tr><tr><td align="left">embstr</td><td align="left">obj和sds同时申请，一片连续的内存空间，使用ptr指针连接</td><td align="left">只读</td></tr></tbody></table><h3 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3.浮点数"></a>1.3.浮点数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>浮点数实际是通过字符串来存储的，在浮点数计算时，redis从sds内取出字符串，转换成浮点数进行计算，并将计算结果再次转换成字符串进行存储。另外，过长的整型数也是通过这种方式存储的。</p><h3 id="1-4-编码转换"><a href="#1-4-编码转换" class="headerlink" title="1.4.编码转换"></a>1.4.编码转换</h3><p>当我们执行操作将整形数据变为字符串时，该对象的编码格式也变成了raw，如 1+”a”这种操作。</p><p>之前也提到，embstr是只读的，所以当我们修改embstr编码的字符串时，其底层编码也会变为raw。</p><h2 id="2-list对象"><a href="#2-list对象" class="headerlink" title="2.list对象"></a>2.list对象</h2><p>同时满足以下两个条件的list对象使用ziplist编码，即压缩列表数据结构，否则使用linkedlist编码，即双向链表数据结构。</p><ol><li>list中元素个数小于512（list-max-ziplist-entries可调）</li><li>list中所有字符串元素长度小于64字节（list-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到linkedlist，将保存在压缩列表的元素遍历取出，转成双向链表节点保存。</p><p>反之，若一开始是linkedlist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><p>另外，redis 3.2版本后引入quicklist数据结构，本文暂不介绍。</p><h3 id="2-1-ziplist编码"><a href="#2-1-ziplist编码" class="headerlink" title="2.1.ziplist编码"></a>2.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><h3 id="2-2-linkedlist编码"><a href="#2-2-linkedlist编码" class="headerlink" title="2.2.linkedlist编码"></a>2.2.linkedlist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = linkedlist<br>obj.ptr = 双向链表对象<br></code></pre></td></tr></table></figure><h2 id="3-hash对象"><a href="#3-hash对象" class="headerlink" title="3.hash对象"></a>3.hash对象</h2><p>同时满足以下两个条件的hash对象使用ziplist编码，即压缩列表数据结构，否则使用ht编码，即字典数据结构。</p><ol><li>hash中元素个数小于512（hash-max-ziplist-entries可调）</li><li>hash中所有字符串元素（键或值）长度小于64字节（hash-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在压缩列表的元素遍历取出，转成字典节点保存。</p><p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="3-1-ziplist编码"><a href="#3-1-ziplist编码" class="headerlink" title="3.1.ziplist编码"></a>3.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><p>插入元素时，会先往压缩列表中添加键对象，再往压缩列表中添加值对象。</p><h3 id="3-2-ht编码"><a href="#3-2-ht编码" class="headerlink" title="3.2.ht编码"></a>3.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure><h2 id="4-set对象"><a href="#4-set对象" class="headerlink" title="4.set对象"></a>4.set对象</h2><p>同时满足以下两个条件的set对象使用intset编码，即整数集合数据结构，否则使用ht编码，即字典数据结构。</p><ol><li>set中元素个数小于512（set-max-ziplist-entries可调）</li><li>set中所有元素均为整数</li></ol><p>若一开始是intset编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在整数集合的元素遍历取出，转成字典节点保存。</p><p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="4-1-intset编码"><a href="#4-1-intset编码" class="headerlink" title="4.1.intset编码"></a>4.1.intset编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = intset<br>obj.ptr = 整数集合对象<br></code></pre></td></tr></table></figure><h3 id="4-2-ht编码"><a href="#4-2-ht编码" class="headerlink" title="4.2.ht编码"></a>4.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure><p>实现类似于java的HashSet，即字典键保存数据，字典值为NULL。</p><h3 id="4-3-聚合统计操作"><a href="#4-3-聚合统计操作" class="headerlink" title="4.3.聚合统计操作"></a>4.3.聚合统计操作</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 返回给定所有集合的并集</span><br><span class="hljs-function"><span class="hljs-title">SUNION</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回给定所有集合的并集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SUNIONSTORE</span></span> dest key1 key2 ...<br><br><span class="hljs-comment">// 返回给定所有集合的交集</span><br><span class="hljs-function"><span class="hljs-title">SINTER</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回给定所有集合的交集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SINTERSTORE</span></span> dest key1 key2 ...<br><br><span class="hljs-comment">// 返回key1集合与其他所有集合的差集</span><br><span class="hljs-function"><span class="hljs-title">SDIFF</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回key1集合与其他所有集合的差集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SDIFFSTORE</span></span> dest key1 key2 ...<br></code></pre></td></tr></table></figure><p>需要注意：</p><ul><li>由于这些统计计算比较耗时，执行上述命令可能会阻塞主线程。因此，对于SUNION、SINTER、SDIFF这类纯读命令，可以在从库上执行。</li><li>如果服务器处于集群模式，即数据分散在多个实例上，那么使用上述的统计命令时，可能由于多个key存在多个实例上，导致结果错误或直接报错。即上述命令不支持跨机器查询。</li></ul><p>所以，实际开发中，复杂的聚合统计操作不应该使用Redis完成。</p><h2 id="5-zset有序集合对象"><a href="#5-zset有序集合对象" class="headerlink" title="5.zset有序集合对象"></a>5.zset有序集合对象</h2><p>同时满足以下两个条件的zset对象使用ziplist编码，即压缩列表数据结构，否则使用skiplist编码，这里指跳表+字典数据结构。</p><ol><li>zset中元素个数小于128（zset-max-ziplist-entries可调）</li><li>zset中所有字符串元素长度小于64字节（zset-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到skiplist，将保存在压缩列表的元素遍历取出，转成跳表+字典节点保存。</p><p>反之，若一开始是skiplist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="5-1-ziplist编码"><a href="#5-1-ziplist编码" class="headerlink" title="5.1.ziplist编码"></a>5.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><p>插入元素时，会遍历压缩列表所有元素，根据score从小往大的顺序（即靠近表头位置的元素score小），先往压缩列表中添加数据对象，再往压缩列表中添加score对象。</p><h3 id="5-2-skiplist编码"><a href="#5-2-skiplist编码" class="headerlink" title="5.2.skiplist编码"></a>5.2.skiplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = skiplist<br>obj.zsl = 跳表对象<br>obj.dict = 字典对象<br></code></pre></td></tr></table></figure><p>跳表中元素按score从小往大的顺序排列。</p><p>字典键等于数据元素（string类型），字典值等于score（double类型），即该字典的作用时从元素映射到对应score。</p><p>为什么需要跳表+字典两个数据结构？速度。如前所述，跳表可以提供优秀的范围查找能力，字典做不到。字典可以O(1) 地查看元素分值，跳表做不到（需要遍历找到节点）。</p><p>最后一点，跳表与字典对应的底层数据对象，是共用的，这是为了节约空间。</p><h1 id="四-自定义数据结构"><a href="#四-自定义数据结构" class="headerlink" title="四.自定义数据结构"></a>四.自定义数据结构</h1><h2 id="1-自定义新数据类型的底层结构"><a href="#1-自定义新数据类型的底层结构" class="headerlink" title="1.自定义新数据类型的底层结构"></a>1.自定义新数据类型的底层结构</h2><p>我们开发一个新数据类型：单链表。使用singlelist.h文件保存单链表的基本定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleList</span> </span>&#123;<br>    SingleListNode head;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleListNode</span> </span>&#123;<br>    String value;<br>    SingleListNode next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-增加新数据类型的全局定义"><a href="#2-增加新数据类型的全局定义" class="headerlink" title="2.增加新数据类型的全局定义"></a>2.增加新数据类型的全局定义</h2><p>在server.h文件中新增单链表的全局定义。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">...<br><span class="hljs-comment">// 数字7是根据现有枚举值追加的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_SINGLE_LIST 7</span><br></code></pre></td></tr></table></figure><h2 id="3-开发新数据类型的构造和析构函数"><a href="#3-开发新数据类型的构造和析构函数" class="headerlink" title="3.开发新数据类型的构造和析构函数"></a>3.开发新数据类型的构造和析构函数</h2><p>根据Redis规范，新建t_singlelist.c文件保存单链表的各种操作，如构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">SingleList <span class="hljs-title">newSingleList</span><span class="hljs-params">()</span> </span>&#123;<br>    SingleList list = zmalloc(sizeof());<br>    list.head = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>在object.c文件中增加新数据结构的全局创建函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">robj <span class="hljs-title">createSingleList</span><span class="hljs-params">()</span> </span>&#123;<br>    SingleList list = newSingleList();<br>    robj o = createObject(OBJ_SINGLE_LIST, list);<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>createObject函数是Redis提供的创建Redis对象的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">robj <span class="hljs-title">createObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, Object ptr)</span> </span>&#123;<br>    robj o = zmalloc(sizeof());<br>    o.type = type;<br>    o.ptr = ptr;<br>    ...<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数创建过程类似。</p><h2 id="4-开发新数据类型的命令操作"><a href="#4-开发新数据类型的命令操作" class="headerlink" title="4.开发新数据类型的命令操作"></a>4.开发新数据类型的命令操作</h2><p>我们新增一个往单链表末尾插入元素的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SLINSERT key value<br></code></pre></td></tr></table></figure><p>首先，在t_singlelist.c文件中实现该操作的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slinsertCommand</span><span class="hljs-params">(RedisClient c)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在server.h文件中声明这个函数，以便在server.c文件中可以引用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slinsertCommand</span><span class="hljs-params">(RedisClient c)</span></span><br></code></pre></td></tr></table></figure><p>最后，在server.c文件中将命令与实现函数关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">redisCommandTable[] = [<br>    ...<br>    &#123;<span class="hljs-string">&quot;SLINSERT&quot;</span>, slinsertCommand, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;m&quot;</span>, ....&#125;<br>]<br></code></pre></td></tr></table></figure><h1 id="五-对象其他细节"><a href="#五-对象其他细节" class="headerlink" title="五.对象其他细节"></a>五.对象其他细节</h1><h2 id="1-命令类型检查"><a href="#1-命令类型检查" class="headerlink" title="1.命令类型检查"></a>1.命令类型检查</h2><p>大体上可以将redis的操作键的命令分为两类</p><ol><li>可以对任意对象类型生效</li><li>只对命令绑定的对象类型生效</li></ol><p>对于第二种类型命令，redis会根据obj.type字段，在执行命令前主动检查：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/checkobject.png"></p><h2 id="2-命令多态实现"><a href="#2-命令多态实现" class="headerlink" title="2.命令多态实现"></a>2.命令多态实现</h2><ul><li>基于类型的多态：可以对任意对象类型生效的命令，会根据value对象具体类型，做不同处理</li><li>基于编码的多态：作用到具体对象上的命令，会根据对象编码，调用对应数据结构API实现命令</li></ul><h2 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3.内存回收机制"></a>3.内存回收机制</h2><p>c语言不像java，java虚拟机会帮助程序员管理对象占用的内存，在对象不被使用时自动释放内存。redis使用引用计数算法实现了一套内存管理机制，现简单介绍。</p><p>首先了解下redis对象生命周期</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/objectlife.png"></p><p>与之对应的，之前说到的obj.refcount值是这样变化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建一个对象时，refcount初始化为1，因为不论有无key对象，服务器都需要持有这个对象</span><br>Object obj = <span class="hljs-keyword">new</span> StringObject();<br><br><span class="hljs-comment">// 对象被新程序使用时，调用incrRefCount(obj)函数，obj.refcount++</span><br><span class="hljs-comment">// 对象不再被新程序使用时，调用decrRefCount(obj)函数，obj.refcount--</span><br>...<br>  <br><span class="hljs-comment">// 最终，调用decrRefCount(obj)函数，将obj.refcount减为0，会导致该对象被redis服务器回收，内存被释放</span><br>decrRefCount(obj);<br></code></pre></td></tr></table></figure><p>涉及到函数列表：</p><table><thead><tr><th align="left">函数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">incrRefCount()</td><td align="left">refcount++</td></tr><tr><td align="left">decrRefCount()</td><td align="left">refcount–</td></tr><tr><td align="left">resetRefCount()</td><td align="left">refcount=0，但是不会释放对象</td></tr></tbody></table><h2 id="4-对象共享机制"><a href="#4-对象共享机制" class="headerlink" title="4.对象共享机制"></a>4.对象共享机制</h2><p>类似于java常量池机制，redis也会将常用字符串做为“常量”共享起来。在redis初始化服务器时，会创建0-9999共一万个整数字符串（通过redis.h/REDIS_SHARED_INTEGERS设置），后续共享使用。这些对象不仅是字符串对象可以共享，前述所有类型对象都可以使用。</p><p>但是，需要注意，redis只支持整数字符串的共享，这主要是因为要共享一个对象，当然需要判断两个引用对应的对象是否一致，整数对象可以在O(1)时间内验证，但当字符串复杂时，或其他结构的对象时（如list），这个验证过程会很消耗CPU并且不可控。</p><p>最后需要注意，当对象被共享时，其refcount++。</p><h2 id="5-对象空转时长"><a href="#5-对象空转时长" class="headerlink" title="5.对象空转时长"></a>5.对象空转时长</h2><p>前面提到的obj.lru记录了该对象最后一次被命令程序访问的时间点。</p><p>我们可以通过 OBJECT IDLETIME 命令查看值对象的 空转时长=当前时间-obj.lru。这个命令比较特殊，不会刷新obj.lru的值。</p><p>空转时长是当服务器内存不够时，用来判断该对象是否可以被回收时使用的，这个之后的专题会详细介绍。</p><p>至此，我们了解了redis所有的对象及其底层数据结构，希望对大家的工作学习有所帮助，谢谢～</p><p><strong>todo list:</strong></p><ul><li><input disabled="" type="checkbox"> 图完善</li><li><input disabled="" type="checkbox"> 源码解读</li><li><input disabled="" type="checkbox"> 指令及对应数据结构操作</li><li><input disabled="" type="checkbox"> 新版本数据结构</li><li><input disabled="" type="checkbox"> 布隆过滤器</li><li><input disabled="" type="checkbox"> Stream</li><li><input disabled="" type="checkbox"> bitcount 命令实现 SWAR算法</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-003-REST</title>
    <link href="/2021/09/08/SAC-003-REST/"/>
    <url>/2021/09/08/SAC-003-REST/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>架构级别的所有设计决策都应该在所设计系统的功能、行为和社会需求的背景下做出，这是一个同样适用于软件架构和传统建筑架构领域的原则。“形式追随功能”的准则来自数百年失败的构建项目的经验，但经常被软件从业者忽视。</p><p>改变应用程序的交互方式对性能的影响比所使用的通信协议更大。</p><p>一般而言，基于网络的体系结构和软件体系结构之间的主要区别在于，如果可以在运行时基于组件的位置选择更有效的机制，则组件之间的通信仅限于消息传递或等效于消息传递。</p><p>分布式系统在用户看来就像一个普通的集中式系统，但运行在多个独立的 CPU 上。相比之下，基于网络的系统是那些能够跨网络运行的系统，但不一定以对用户透明的方式运行。在某些情况下，用户需要了解需要网络请求的操作与可在其本地系统上满足的操作之间的区别，特别是当网络使用意味着额外的交易成本时 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。</p><p>应用程序软件架构是整个系统的抽象级别，其中用户操作的目标可表示为功能架构属性。</p><p>这与网络抽象形成对比，网络抽象的目标是将位从一个位置移动到另一个位置，而不考虑为什么移动这些位。只有在应用程序级别，我们才能根据每个用户操作的交互次数、应用程序状态的位置、所有数据流的有效吞吐量（相对于单个数据流的潜在吞吐量）来评估设计权衡)、每个用户操作执行的通信范围等。</p><p>基于网络的应用程序的性能首先受应用程序需求的约束，然后是选择的交互方式，其次是实现的架构，最后是每个组件的实现。</p><p>关于基于网络的应用程序的一个有趣观察是，最好的应用程序性能是通过不使用网络来获得的。这实质上意味着基于网络的应用程序最有效的架构风格是那些在可能的情况下可以有效地最大限度地减少网络使用的风格，通过重用先前的交互（缓存），减少网络交互的频率与用户操作（复制数据和断开连接的操作）相关，或者通过将数据处理移动到更靠近数据源（移动代码）来消除某些交互的需要。</p><p>可修改性是指对应用程序架构进行更改的难易程度。可修改性可以进一步分解为可进化性、可扩展性、可定制性、可配置性和可重用性，如下所述。基于网络的系统的一个特别关注点是动态可修改性，其中对已部署的应用程序进行修改而无需停止和重新启动整个系统。</p><p>即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。由于参与基于网络的应用程序的组件可能分布在多个组织边界，因此系统必须为渐进的、碎片化的变化做好准备，在这种变化中，新旧实现并存，同时又不妨碍新实现利用其扩展功能。</p><p>构建软件的目的不是创建特定的交互拓扑或使用特定的组件类型——而是创建一个满足或超过应用程序需求的系统。为系统设计选择的架构风格必须符合这些需求，而不是相反。因此，为了提供有用的设计指导，架构风格的分类应该基于这些风格所引发的架构特性。</p><p>Berners-Lee [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_20">20</a> ] 写道，“Web 的主要目标是成为一个共享的信息空间，通过它人和机器可以进行通信。” 人们需要一种方法来存储和构建他们自己的信息，无论是永久的还是短暂的，以便他们自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护本地副本。</p><p>该系统的预期最终用户位于世界各地，通过互联网连接的各个大学和政府高能物理研究实验室。他们的机器是终端、工作站、服务器和超级计算机的异构集合，需要操作系统软件和文件格式的大杂烩。信息范围从个人研究笔记到组织电话列表。面临的挑战是构建一个系统，该系统将为这种结构化信息提供普遍一致的接口，可在尽可能多的平台上使用，并且随着新人员和组织加入项目而逐步部署。</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此体系结构需要最大限度地减少网络交互（数据传输协议内的往返）。</p><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p><p>假设 I：WWW 体系结构背后的设计原理可以用一种体系结构风格来描述，该体系结构风格由应用于 Web 体系结构中元素的一组约束组成。</p><p>假设二：可以在 WWW 架构风格中添加约束，以推导出一种新的混合风格，更好地反映现代 Web 架构所需的属性。</p><p>假设 III：可以将修改 Web 架构的建议与更新的 WWW 架构风格进行比较，并在部署之前分析冲突。</p><h1 id="XML-RPC"><a href="#XML-RPC" class="headerlink" title="XML-RPC"></a>XML-RPC</h1><p><strong>XML-RPC</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a>（Remote Procedure Call，RPC）的<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算</a><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2%E5%8D%94%E8%AD%B0">协议</a>，通过<a href="https://zh.wikipedia.org/wiki/XML">XML</a>将调用函数封装，并使用<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>协议作为发送机制。</p><p>XML-RPC 消息是一个 HTTP-POST 请求。请求的正文采用 XML 格式。一个过程在服务器上执行，它返回的值也采用 XML 格式。</p><p>过程参数可以是标量、数字、字符串、日期等；也可以是复杂的记录和列表结构。</p><p>下面是一个 XML-RPC 请求的例子：</p><p>必须指定用户代理和主机。</p><p>内容类型是 text/xml。</p><p>必须指定 Content-Length 并且必须正确。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">POST /RPC2 HTTP/1.0<br>User-Agent: Frontier/5.1.2 (WinNT)<br>Host: betty.userland.com<br>Content-Type: text/xml<br>Content-length: 181<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodCall</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">methodName</span>&gt;</span>examples.getStateName<span class="hljs-tag">&lt;/<span class="hljs-name">methodName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i4</span>&gt;</span>41<span class="hljs-tag">&lt;/<span class="hljs-name">i4</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodCall</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是对 XML-RPC 请求的响应示例：</p><p>除非出现低级错误，否则总是返回 200 OK。</p><p>内容类型是 text/xml。Content-Length 必须存在且正确。</p><p>响应的主体是单个 XML 结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 158<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:08 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>South Dakota<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>故障示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 426<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:02 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">fault</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">struct</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultCode<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">int</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">int</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultString<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Too many parameters.<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">struct</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">fault</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>XML-RPC发表于1998年，由<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>（<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>）的<a href="https://zh.wikipedia.org/w/index.php?title=Dave_Winer&action=edit&redlink=1">Dave Winer</a>及<a href="https://zh.wikipedia.org/wiki/Microsoft">Microsoft</a>共同发表[<a href="https://zh.wikipedia.org/wiki/XML-RPC#cite_note-2">2]</a>。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的<a href="https://zh.wikipedia.org/wiki/SOAP">SOAP</a>协议。</p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>SOAP 的最初意图相当温和：编写如何发送 <em>瞬态</em>XML 文档以触发远程主机上的操作或响应的方法。OAP 1.2 版提供了基于 XML 的信息的定义，该信息可用于在分散的分布式环境中的对等点之间交换结构化和类型化信息。</p><p><strong>SOAP</strong>（原为<strong>Simple Object Access Protocol</strong>的<a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E5%86%99">首字母缩写</a>，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，使用在计算机网络<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1">Web服务</a>（web service）中，交换带结构的信息。SOAP为了简化网页服务器（Web Server）从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>通信协议，遵从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><p>目前SOAP 1.1版是业界共同的标准，属于第二代的XML协议（第一代具主要代表性的技术为XML-RPC以及WDDX）</p><p>用一个简单的例子来说明SOAP使用过程，一个SOAP消息可以发送到一个具有Web Service功能的Web站点，例如，一个含有房价信息的数据库，消息的参数中标明这是一个查询消息，此站点将返回一个XML格式的信息，其中包含了查询结果（价格，位置，特点，或者其他信息）。由于数据是用一种标准化的可分析的结构来传递的，所以可以直接被第三方站点所利用。</p><ul><li>SOAP封装（envelope）：定义了一个框架，描述消息中的内容是什么、是谁发送的、谁应当接受并处理它以及如何处理它们；</li><li>SOAP编码规则（encoding rules）：定义了一种<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的机制，用于表示应用程序需要使用的数据类型的实例；</li><li>SOAP RPC表示（RPC representation）：定义了一个协定，用于表示远程过程调用和应答；</li><li>SOAP绑定（binding），它定义了SOAP使用哪种协议交换信息。使用<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>/<a href="https://zh.wikipedia.org/wiki/TCP">TCP</a>/<a href="https://zh.wikipedia.org/wiki/UDP">UDP</a>协议都可以。</li></ul><p>把SOAP绑定到HTTP的方式，同时利用了SOAP的样式和分散的灵活性特点以及HTTP的丰富特征库的优点。在HTTP上传送SOAP并不意味着SOAP会覆盖现有的HTTP语义，而是HTTP上的SOAP语义会自然地映射到HTTP语义。在使用HTTP作为协议绑定的场合中，RPC请求映射到HTTP请求上，而RPC应答映射到HTTP应答。然而，在RPC上使用SOAP并不仅限于HTTP协议绑定。</p><p>SOAP使用因特网应用层协议作为其传输协议。<a href="https://zh.wikipedia.org/wiki/SMTP">SMTP</a>以及<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>协议都可以用来传输SOAP消息，但是由于HTTP在如今的因特网结构中工作得很好，特别是在网络防火墙下仍然正常工作，所以被广泛采纳。SOAP亦可以在<a href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>上传输。</p><p>SOAP的消息格式采用<a href="https://zh.wikipedia.org/wiki/XML">XML</a>。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>定义了 SOAP 信封，它是一种结构，它定义了一个整体框架，用于表示 SOAP 消息的内容，确定谁应该处理全部或部分消息，以及处理这些部分是可选的还是强制性的。它还定义了一个协议绑定框架，它描述了如何编写将 SOAP 绑定到另一个底层协议的规范。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a>定义了<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP</a>的数据模型，一种特定的数据类型编码方案，可用于传送远程过程调用 (RPC)，以及[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1] 中</a>定义的底层协议绑定框架的一个具体实现。此绑定允许将 SOAP 消息作为 HTTP POST 请求和响应的有效负载进行交换，或者作为对 HTTP GET 的响应中的 SOAP 消息进行交换。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>描述了一个抽象特性，用于优化特定类型内容的 SOAP 消息的有线格式，以及它在 HTTP 绑定中实现的具体实现，同时仍将 SOAP 消息建模为单个 XML 信息集.</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP]</a>定义了一种更有效地序列化具有二进制内容的 XML 信息集的约定。 [<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>利用 [ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP</a> ] 格式来优化 SOAP 消息的传输。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L4299">ResRep]</a>指定了一个 SOAP 头块，它携带 Web 资源的表示，这是处理 SOAP 消息所需要的，但接收者不愿意或不能通过取消引用消息中携带的资源的 URI 来获得。</p><p>SOAP 从根本上是一种无状态的单向消息交换范例，但应用程序可以通过将此类单向交换与底层协议提供的功能相结合来创建更复杂的交互模式（例如，请求/响应、请求/多响应等）和/或特定于应用程序的信息。SOAP 对它所传达的任何特定于应用程序的数据的语义保持沉默，因为它涉及诸如 SOAP 消息的路由、可靠的数据传输、防火墙穿越等问题。但是，SOAP 提供了一个框架，通过该框架，特定于应用程序的信息可以以可扩展的方式传达。此外，SOAP 提供了 SOAP 节点在接收 SOAP 消息时采取的所需操作的完整描述。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/primer-figure-1.png" alt="primer-figure-1"></p><p>SOAP标头元素是可选的，但它已被包括在示例来解释SOAP的某些特征。SOAP 标头是一种扩展机制，它提供了一种在 SOAP 消息中传递不是应用程序有效负载的信息的方法。这种“控制”信息包括例如与消息处理相关的传递指令或上下文信息。这允许以特定于应用程序的方式扩展 SOAP 消息。该元素的直接子元素<code>env:Header</code>称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#encapsulation"> 标头块</a>，代表数据的逻辑分组，如下所示，可以单独针对 SOAP 节点，这些节点在从发送方到最终接收方的消息路径中可能会遇到。SOAP 标头的设计考虑到 SOAP 的各种用途，其中许多将涉及其他 SOAP 处理节点（称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts"> SOAP 中介）</a>的参与，沿着从<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">初始 SOAP 发送方</a>到<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">最终 SOAP 接收</a><a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">方</a>的消息路径。这允许 SOAP 中介提供增值服务。标题，如后所示，可以被沿<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">SOAP 消息路径</a>遇到的 SOAP 节点检查、插入、删除或转发. （不过，应该记住，SOAP 规范不处理头元素的内容，或者 SOAP 消息如何在节点之间路由，或者确定路由的方式等等。这些是整个应用程序的一部分，并且可能是其他规范的主题。）</p><p>SOAP Version 1.2 是一个简单的消息传递框架，用于在初始 SOAP 发送方和最终 SOAP 接收方之间传输以 XML 信息集形式指定的信息。更有趣的场景通常涉及这两个节点之间的多个消息交换。最简单的这种交换是请求-响应模式。[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R11">SOAP 1.1</a> ] 的一些早期使用强调使用这种模式作为传送远程过程调用 (RPC) 的手段，但重要的是要注意并非所有 SOAP 请求-响应交换都可以或需要建模为 RPC。当需要对某个程序行为建模时使用后者，交换的消息符合远程调用及其返回的预定义描述。比请求-响应模式所涵盖的更多的使用场景集可以简单地建模为在 SOAP 消息中交换的基于 XML 的内容以形成来回“对话”，其中语义处于发送和接收应用程序。</p><p>SOAP 1.2 版的设计目标之一是使用 XML 的可扩展性和灵活性封装远程过程调用功能。尽管用于 RPC 的 SOAP 的大多数示例都使用 HTTP 协议绑定，但它并不仅限于这种方式。要调用 SOAP RPC，需要以下信息：</p><ol><li>目标 SOAP 节点的地址。</li><li>过程或方法名称。</li><li>要传递给过程或方法的任何参数的标识和值以及任何输出参数和返回值。</li><li>用于识别作为 RPC 实际目标的 Web 资源的参数的明确分离，与传送用于处理目标资源调用的数据或控制信息的参数形成对比。</li><li>将用于传达 RPC 的消息交换模式，以及要使用的所谓“Web 方法”（稍后将详细介绍）的标识。</li><li>可选地，可以作为 SOAP 头块的一部分携带的数据。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:reference</span>&gt;</span>uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:20:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">m:reservation</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itinerary</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-14<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>late afternoon<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>&gt;</span>aisle<span class="hljs-tag">&lt;/<span class="hljs-name">p:seatPreference</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-20<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>mid-morning<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itinerary</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">q:lodging</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:q</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/hotels&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">q:preference</span>&gt;</span>none<span class="hljs-tag">&lt;/<span class="hljs-name">q:preference</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">q:lodging</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span> =<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   &lt; m:reference&gt;uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:35:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span> <br>  &lt;/m:reservation &gt; <br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env</span> <span class="hljs-attr">:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itineraryClarification</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span> &gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>          JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span> <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span> <br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>         JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>     &lt;/p:arriving &gt; <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itineraryClarification</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">xmlns:rpc</span>=<span class="hljs-string">&#x27;http://www.w3.org/2003/05/soap-rpc&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">env:Fault</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Code</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>env:Sender<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Subcode</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>rpc:BadArguments<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">env:Subcode</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Code</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Reason</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span>Processing error<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;cs&quot;</span>&gt;</span>Chyba zpracování<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Reason</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Detail</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">e:myFaultDetails</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:e</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/faults&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:message</span>&gt;</span>Name does not match card number<span class="hljs-tag">&lt;/<span class="hljs-name">e:message</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:errorcode</span>&gt;</span>999<span class="hljs-tag">&lt;/<span class="hljs-name">e:errorcode</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">e:myFaultDetails</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Detail</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">env:Fault</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>头块和正文的进一步处理取决于SOAP 节点为处理给定消息所承担的<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts"> 角色</a>。SOAP 定义了（可选）<code>env:role</code>属性 - 在语法上， <code>xs:anyURI</code>- 可能出现在头块中，它标识该头块的预期目标所扮演的角色。如果 SOAP 节点承担由 URI 的值标识的角色，则它需要处理头块。</p><p>为了确保 SOAP 节点不会忽略对应用程序的总体目的很重要的头块，SOAP 头块还提供了附加的可选属性<code>env:mustUnderstand</code>，如果为“true”，则意味着目标 SOAP 节点<em>必须</em>根据该块的规范处理该块。</p><p>为了规避处理模型的默认规则，使用附加属性标记标题块<code>env:relay</code> 值为“true”时允许中介在它选择不处理它的情况下转发针对它自己的标头块。</p><p>SOAP 消息可以使用各种“底层”协议进行交换，包括其他应用层协议。SOAP 消息如何使用底层协议从一个 SOAP 节点传递到另一个节点的规范称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts">SOAP 绑定</a>。[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>以[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R12">XML Infoset</a> ]的形式定义了一个SOAP 消息，即，根据称为the <code>env:Envelope</code>（参见<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#soapenv">SOAP Part 1，第5 节</a>）的抽象“文档”的元素和属性信息项 。但是，SOAP 消息可能会在发送方和最终接收方之间经过几跳，其中每一跳可能是不同的协议绑定。换言之，在一个跳跃中由协议绑定支持的特征（例如，消息相关性、可靠性等）可能不被沿消息路径的另一个支持。SOAP 本身并没有提供任何机制来隐藏不同底层协议提供的特性差异。但是，特定应用程序需要的任何端到端或多跳特性，但在<em>预期</em>消息路径上的底层基础设施中可能不可用，可以通过作为 SOAP 的一部分携带来补偿消息信息集，即作为某个模块中指定的 SOAP 头块。应用程序设计者必须解决许多问题才能完成特定的应用程序语义，包括如何利用可用于所选环境的底层协议的本机特性</p><p>功能描述由 URI 标识，因此所有引用它的应用程序都确保具有相同的语义。特征由<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#bindprops">属性</a>限定，提供有助于实现该功能的附加信息。当 RPC 定义使得其方法描述的所有部分都可以描述为资源标识时，RPC 的整个目标可以由 URI 标识。如果应用程序需要使用只能在 SOAP 信息集中具有特定于绑定的表达式的功能，即使用 SOAP 标头块，则应用程序必须选择 HTTP POST 方法，并在请求正文中包含 SOAP 消息.如果 RPC 描述包含非资源识别的数据（参数），它还需要使用通过 HTTP POST 实现的<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>。即使在这种情况下，带有 SOAP 消息的 HTTP POST 也可以以 Web 友好的方式表示。与 GET 的使用一样，[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a> 建议在一般情况下，在 HTTP 请求 URI 中标识用于标识请求被 POST 到的资源的 SOAP 消息的任何部分。当然，相同的参数可以保留在 SOAP<code>env:Body</code>元素中。（在基于 SOAP 的 RPC 的情况下，参数必须保留在主体中，因为这些参数与接收应用程序期望的过程/方法描述相关。）</p><p>SOAP 规范中的建议是以 Web 架构兼容的方式使用 URI - 即作为资源标识符 - 无论使用的是 GET 还是 POST。</p><p>HTTP 具有众所周知的连接模型和消息交换模式。客户端通过 URI 识别服务器，使用底层 TCP/IP 网络连接到它，发出 HTTP 请求消息并通过相同的 TCP 连接接收 HTTP 响应消息。HTTP 隐式地将其请求消息与其响应消息相关联；因此，使用此绑定的应用程序可以选择推断 HTTP 请求消息正文中发送的 SOAP 消息与 HTTP 响应中返回的 SOAP 消息之间的相关性。类似地，HTTP 通过 URI 标识服务器端点，即<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2">Request-URI</a>，它也可以用作服务器上 SOAP 节点的标识。HTTP 允许在初始客户端和由 Request-URI 标识的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html#sec1.3">源服务器</a>之间存在多个中介 ，在这种情况下，请求/响应模型是一系列这样的对。但是请注意，HTTP 中介与 SOAP 中介不同。SOAP Part2中的 HTTP 绑定利用<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#WebMethodFeature">SOAP Web 方法特性</a>来允许应用程序选择所谓的 Web 方法——将其限制为 GET 或 POST 之一——以通过 HTTP 消息交换使用。此外，它还利用了两种消息交换模式，为应用程序提供了两种通过 HTTP 交换 SOAP 消息的方式：1) 使用 HTTP POST 方法在 HTTP 请求和响应消息的正文中传送 SOAP 消息，以及 2)在 HTTP 请求中使用 HTTP GET 方法在 HTTP 响应的正文中返回 SOAP 消息。第一种使用模式是称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>的绑定特性的 HTTP 特定实例，而第二种使用称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#soapresmep">SOAP 响应消息交换模式</a>。由于 HTTP SOAP GET 用法不允许请求中包含 SOAP 消息，因此在出站交互中需要功能的应用程序显然不能由 SOAP 信息集中的绑定特定表达式（即，作为 SOAP 标头块）支持利用这种消息交换模式。请注意，HTTP POST 绑定可用于所有情况。SOAP 使用 HTTP 传输，遵循 HTTP 状态代码的语义以在 HTTP 中传递状态信息。</p><p>万维网最核心的概念之一是作为资源标识符的 URI。使用 HTTP 绑定并希望与其他 Web 软件互操作的 SOAP 服务应该使用 URI 来寻址其服务中的所有重要资源。例如，万维网的一个非常重要（实际上占主导地位）的用途是纯信息检索，其中由 URI 标识的可用资源的表示是使用 HTTP GET 请求获取的，而不会以任何方式影响资源。（这在 HTTP 术语中称为<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1">安全且幂等的方法</a>。）关键点是资源的发布者提供其 URI，消费者可以“获取”该 URI。在许多情况下，SOAP 消息被设计用于纯粹用于信息检索的用途，例如请求某些资源（或对象，在编程术语中）的状态，而不是执行资源操作的用途。在这种情况下，使用 SOAP 主体来携带状态请求，主体的一个元素代表所讨论的对象，被视为与 Web 精神背道而驰，因为资源不是由请求标识的—— HTTP GET 的 URI。（在一些 SOAP/RPC 实现中，HTTP 请求 URI 通常不是资源本身的标识符，而是一些必须评估 SOAP 消息以识别资源的中间实体。）</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>为了方便后续讨论 REST 和 RESTful Api，我们先说 HTTP 协议的资源、请求方法与响应码的定义。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>HTTP 请求的目标称为<strong>资源</strong>。 每个资源都由统一资源标识符 URI 标识。人们很容易将 URI 视为远程文件系统路径名，并将该资源的表示视为此类文件的副本。但即使将 URI 映射机制绑定到文件系统，服务端也可能被配置为以请求作为输入执行文件，并将输出作为表示进行响应，而不是直接传输文件。无论如何，只有服务端需要知道它的每个 URI 如何对应于一个实现，以及每个实现如何管理、如何发送目标资源的当前表示以响应 GET 方法等工作。</p><p>HTTP 不限制资源的性质，资源可以是任何东西，例如一份文档，亦或是数据库中存储的数据，等等。HTTP 只是定义了一个与资源交互的统一接口。统一接口类似于一个窗口，只有通过向另一侧的某个独立参与者传递消息才能观察和处理资源。HTTP 没有定义资源是如何存储的，也没有定义这种存储如何响应资源状态变化，也没有定义服务端如何将资源转换为表示。</p><p>就 HTTP 而言，资源的表示（以下统称为<strong>表示</strong>）是旨在反映给定资源过去、当前或期望状态的信息（举例，若将订单视为一种资源，那么查询订单就是希望获取订单资源过去或者当前的信息，创建订单就是在传输订单的期望信息）。表示由元数据和数据流组成，可以轻松地通过 HTTP 进行传输。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>HTTP 的一个设计目标是将资源标识与请求方法分离，这是通过在请求方法和一些请求头字段中赋予语义来实现的：请求方法被设想为将语义应用于目标资源，这很类似于在已识别的对象上调用其定义好的方法，从而将方法语义应用到该对象上的方式。 如果请求方法语义与 URI 本身隐含的任何语义之间存在冲突，则请求方法语义优先。</p><p>与对象方法不同，HTTP 中的标准化请求方法不是特定于某类资源的。尽管每个资源自己确定这些语义是否被允许以及如何实现，但是应该确保标准化方法在应用于任何资源时具有相同的语义。统一的标准化方法在基于网络的系统中提供了更好的可见性和重用性。</p><p>下面根据请求方法的语义对方法进行分类：</p><ul><li><p>安全方法</p><p>如果请求方法所定义的语义本质上是只读的，则该请求方法被认为是安全的。客户端不会请求，也不期望将安全方法应用于目标资源，从而导致服务端上该资源的任何状态变更。同样，合理使用安全方法不会对服务端造成任何伤害、财产损失或异常负担。</p><p>安全方法的定义不会阻止服务端上的方法实现包含潜在有害的行为、并非完全只读的行为或调用时会导致副作用的行为。然而，重要的是客户端没有要求额外的行为，也不会为此负责。例如，大多数服务端在响应完成时会记录访问日志，无论使用何种方法，即使日志存储可能已满并导致服务端崩溃，该方法也被认为是安全的。同样，查看广告而发起的安全请求通常会产生向广告帐户收费的副作用，这也是安全的。</p><p>区分安全和不安全方法的目的是为了支持爬虫和缓存。此外，它允许用户代理在处理潜在不可信内容时对不安全方法应用适当的约束。</p></li><li><p>幂等方法</p><p>如果使用该请求方法的多个相同请求与使用单个此类请求对服务器的预期效果相同，则该请求方法被认为是幂等的。</p><p>与安全方法的定义一样，幂等性仅适用于客户端，服务端可以记录每次历史访问，或为每个幂等请求实现其他非幂等副作用。</p><p>客户端可以自动重复发送幂等请求。例如，如果客户端发送 PUT 请求，并且在收到任何响应之前网络底层连接已关闭，则客户端可以建立新连接并重试该幂等请求。</p></li><li><p>可缓存方法</p><p>请求方法若被定义为可缓存的，则表示允许中介存储对它们的响应以备将来重用。 通常，不依赖于当前或权威响应的安全方法被定义为可缓存的方法。</p><p>但即使规范定义为可缓存方法，但类似于 GET 方法，可以通过在请求头中设置 Cache-Control 字段，更改可缓存特性。</p></li></ul><table><thead><tr><th>方法名</th><th>介绍</th><th>是否安全</th><th>是否幂等</th><th>是否可缓存</th><th>是否有请求体</th></tr></thead><tbody><tr><td>GET</td><td>获取目标资源的当前选定表示</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>HEAD</td><td>与 GET 请求相同，但是只传输状态码和响应头</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>POST</td><td>请求目标资源根据资源自身的特定语义处理请求中包含的表示</td><td>否</td><td>否</td><td>否（规范上定义为可缓存，但大多数实现为不可缓存）</td><td>是</td></tr><tr><td>PUT</td><td>使用请求体中包含的表示替换目标资源当前所有表示，即请求目标资源的状态被<strong>创建</strong>或<strong>替换</strong>为由包含在请求消息有效负载中的表示所定义的状态</td><td>否</td><td>是</td><td>否</td><td>是</td></tr><tr><td>PATCH</td><td>请求创建新资源或对现有资源应用部分修改</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>DELETE</td><td>请求删除目标资源当前所有表示</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>CONNECT</td><td>建立到（被目标资源标识的）服务端的隧道</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>OPTIONS</td><td>请求有关可用于目标资源的通信选项，无论这些信息是存储在服务端还是中介</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>TRACE</td><td>沿着到目标资源的网络路径执行 HTTP 消息的环回测试</td><td>否</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><p>下面详细介绍各请求方法：</p><ul><li><p>GET</p><p>GET 方法是信息检索的主要机制，也是几乎所有性能优化的重点。客户端通过在请求头中设置 Range 字段，可以将 GET 方法的语义更改为“范围请求”，即请求仅传输所选表示的某些部分。注意，这不是类似于对订单信息的分页查询，而是请求对响应的部分获取。</p></li><li><p>HEAD</p><p>HEAD 方法可用于在不传输表示数据的情况下获取所选表示的元数据，通常用于测试超文本链接的有效性、可访问性和最近是否修改。HEAD方法的 响应可能对先前缓存的 GET 方法响应产生影响。</p></li><li><p>POST</p><p>POST 方法不可以被理解为仅代表<strong>创建</strong>。简单说，我们将请求分为读、写两类，那么自然 GET 方法代表读请求，POST 方法代表写请求。写请求自然包含很多语义，类似于创建、修改、删除、取消、预约等等。这是一开始 POST 方法的设计，也是过去（现在甚至还存在）很多系统对于 GET 和 POST 方法的使用方式。可以说，有了 GET 和 POST 方法就可以了。但是，为了更好的利用网络资源，对 HTTP 消息进行优化，比如缓存，以及规范客户端与服务端的交互，就逐渐需要更细化的方法定义，这也是 PUT、DELETE等方法的由来。</p></li><li><p>PUT</p><p>POST 和 PUT 方法之间的根本区别是： POST 方法旨在根据目标资源自己所定义的语义处理请求中的资源表示，而 PUT 方法被定义为替换目标资源的状态。</p><p>除了客户端请求的意图和服务端响应的语义可以表达的内容之外，HTTP 没有确切定义 PUT 方法如何影响服务端资源的状态。资源接口 URI 背后的所有实现细节都被服务端隐藏。</p><p>服务端应该保证 PUT 方法不会修改所定义的资源约束，并验证请求中的表示符合任何约束。当 PUT 方法请求中的表示与目标资源不一致时，服务端应该通过转换表示或更改资源配置来使它们一致，或者以包含足够信息的错误响应来解释表示为什么不合适。</p></li><li><p>PATCH</p><p>PATCH 方法将请求体中描述的一组更改应用于 URI 所标识的资源。更改的格式为补丁文档。如果 URI 未指向现有资源，则服务器可以创建新资源，具体取决于补丁文档类型是否可以在逻辑上修改空资源，以及权限等限制。</p><p>PUT 和 PATCH 方法之间的区别体现在服务端处理表示从而修改 URI 所标识的资源的方式上。PUT 方法请求所包含的表示被认为是存储在源服务器服务端上的资源的修改版本，客户端请求使用这个资源的修改版本替换现有的存储版本。但是 PATCH 方法请求所包含的表示是一组指令，它描述了当前服务端上的资源应如何修改以生成新版本。 服务端必须以原子方式应用整个更改指令，并且不会提供部分修改的表示。如果无法成功应用整个补丁文档，则服务端不得应用任何更改。原子性要求适用于所有直接受影响的文件和数据。如果补丁文档的大小大于 PUT 方法请求中的新资源的大小，那么更应该使用 PUT 方法。</p><p>POST 方法的使用方式多种多样，如果服务器愿意，可以将 POST 方法实现为类似 PUT 和 PATCH 的操作。如果操作没有以可预测的方式修改由 URI 标识的资源，则更应考虑 POST 方法。</p></li><li><p>DELETE</p><p>如果目标资源具有一个或多个表示，它们可能会或不会被服务端销毁，并且其存储可能会或不会被回收，这完全取决于资源的性质及其服务端的实现。</p></li><li><p>CONNECT</p><p>隧道通是通过一个或多个代理所创建的端到端的虚拟连接，可以使用 TLS 进行保护。除了成功响应之外的任何响应都表明隧道尚未连接成功，并且连接仍然由 HTTP 控制。如果隧道连接成功，则此后客户端与服务端的<strong>发送或者接受 TCP 消息流</strong>，直到隧道关闭。</p><p>建立通向任意服务端的隧道存在重大风险，特别是当目标服务端不是众所周知或保留的 TCP 端口时。</p></li><li><p>OPTIONS</p><p>客户端应该在向用户呈现通信选项时区分安全和不安全的方法。</p></li><li><p>TRACE</p></li></ul><h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><p>客户端必须理解任何状态代码类别（例如 3xx），并将无法识别的状态代码视为等同于该类别的 x00 状态码。</p><ul><li>1xx（信息）：请求已收到，继续处理。</li><li>2xx（成功）：请求被成功接收、理解和接受。</li><li>3xx（重定向）：需要采取进一步行动才能完成请求。</li><li>4xx（客户端错误）：请求包含错误的语法或无法完成。</li><li>5xx（服务器错误）：服务器未能满足有效的请求。</li></ul><h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><h2 id="World-Wide-Web-万维网特点及其需求"><a href="#World-Wide-Web-万维网特点及其需求" class="headerlink" title="World Wide Web 万维网特点及其需求"></a>World Wide Web 万维网特点及其需求</h2><p>在理解 REST 设计思想之前，我们需要先明确 Web 的特点，即 Web 系统架构的设计要求。</p><p>Web 的主要目标是成为一个人与机器互联互通的信息共享空间：人们需要一种方法来构建和存储他们自己的信息，无论这些信息是永久的还是短暂的，以便自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护信息的本地副本。Web 系统的最终预期是用户位于世界各地，并通过 Web 连接的。用户所使用的机器是终端、工作站、服务器和超级计算机的异构集合，有各式各样的操作系统软件和文件格式。信息范围从个人研究笔记到组织电话列表。Web 系统需要为这些异构信息提供普遍一致的接口，在尽可能多的平台上使用，并且随着新人员和组织加入而逐步部署整个 Web 系统。</p><p>尽管对它的成功感到欣喜若狂，但 Internet 开发人员社区开始担心 Web 使用的快速增长以及早期 HTTP 的一些不良网络特性会迅速超过 Internet 基础设施的容量并导致全面崩溃。Web 上应用程序交互性质的变化使情况变得更糟。最初的协议是为单个请求-响应对设计的，而新站点使用越来越多的内嵌图像作为网页内容的一部分，从而产生不同的浏览交互配置文件。部署的架构在支持可扩展性、共享缓存和中介方面存在重大限制，这使得针对日益增长的问题开发临时解决方案变得困难。同时，</p><p>Internet Engineering Taskforce 内的工作组成立以研究 Web 的三个主要标准：URI、HTTP 和 HTML。这些小组的章程是定义在早期 Web 架构中普遍和一致实现的现有架构通信的子集，识别该架构中的问题，然后指定一组标准来解决这些问题。这给我们带来了一个挑战：我们如何向已经广泛部署的架构引入一组新功能，以及我们如何确保它的引入不会对支持 Web 的架构属性产生不利影响甚至破坏成功？</p><p>Web 系统有以下特点：</p><ul><li><p>低门槛</p><p>由于参与信息的创建和构建是自愿的，因此需要低门槛才能充分采用。这适用于 Web 架构的所有用户：读者、作者和应用程序开发人员。</p><p>选择超媒体作为用户界面是因为它的简单性和通用性：无论信息来源如何，都可以使用相同的界面，超媒体关系（链接）的灵活性允许无限的结构化，链接的直接操作允许内部的复杂关系指导读者完成应用程序的信息。由于大型数据库中的信息通常更容易通过搜索界面而不是浏览来访问，因此 Web 还集成了通过向服务提供用户输入的数据并将结果呈现为超媒体来执行简单查询的能力。</p><p>对于作者而言，主要要求是整个系统的部分可用性不得妨碍内容的创作。超文本创作语言需要简单并且能够使用现有的编辑工具进行创建。作者希望以这种格式保存个人研究笔记等内容，无论是否直接连接到互联网，因此不能允许某些参考信息暂时或永久不可用的事实阻止阅读和创作可用的信息。出于类似的原因，必须能够在该引用的目标可用之前创建对信息的引用。由于鼓励作者合作开发信息源，参考文献需要易于交流，</p><p>简单性也是应用程序开发人员的目标。由于所有协议都定义为文本，因此可以使用现有网络工具查看和交互测试通信。尽管缺乏标准，这使得协议的早期采用得以实现。</p></li><li><p>可拓展性</p><p>虽然简单性使得部署分布式系统的初始实现成为可能，但可扩展性使我们能够避免永远陷入部署的限制。即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。一个想要像 Web 一样长期存在的系统必须准备好接受变化。</p></li><li><p>分布式超媒体</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此架构需要最小化网络交互（数据传输协议内的往返）。</p></li><li><p>互联网规模</p><p>万维网旨在成为一个<em>互联网规模的</em>分布式超媒体系统，这意味着不仅仅是地理上的分散。互联网是关于跨越多个组织边界的互连信息网络。信息服务供应商必须能够应对无政府可扩展性和软件组件独立部署的需求。</p><h4 id="4-1-4-1-无政府可扩展性"><a href="#4-1-4-1-无政府可扩展性" class="headerlink" title="4.1.4.1 无政府可扩展性"></a>4.1.4.1 无政府可扩展性</h4><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>架构元素及其运行平台的安全性也成为一个重要的问题。多个组织边界意味着在任何通信中都可能存在多个信任边界。中间应用程序（例如防火墙）应该能够检查应用程序交互并防止组织安全策略之外的应用程序被执行。应用程序交互中的参与者应该假设收到的任何信息都是不可信的，或者在给予信任之前需要一些额外的身份验证。这要求架构能够传达身份验证数据和授权控制。但是，由于身份验证会降低可扩展性，因此架构的</p><h4 id="4-1-4-2-独立部署"><a href="#4-1-4-2-独立部署" class="headerlink" title="4.1.4.2 独立部署"></a>4.1.4.2 独立部署</h4><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>具象状态传输（REST）</strong>是一种软件架构风格，旨在指导万维网架构的设计和开发，特别是客户端-服务端应用程序。但更重要的是，REST 为互联网规模的分布式超媒体系统的架构定义了一组约束条件，因此客户端和服务端之间的耦合必须尽可能松散以促进大规模使用。这是通过定义<strong>资源</strong>作为抽象层，从而隐藏了底层实现细节。这种方法允许在跨组织（信任）边界的大规模分布式环境中的客户端和服务端之间实现最大的互操作性。</p><p>REST 的目标是提高性能、可扩展性、简单性、可修改性、可见性、可移植性和可靠性。这是通过遵循 REST 原则来实现的，例如客户端 - 服务器架构、无状态、可缓存性、分层系统的使用、按需代码支持以及使用统一接口。要对系统进行分类，必须遵循这些原则。REST架构风格强调组件间交互的可扩展性、统一接口、组件独立部署、分层架构、方便缓存组件、减少用户感知延迟、加强安全性和封装遗留系统。</p><p>就其本质而言，架构风格独立于任何特定的实现，虽然 REST 是作为 Web 标准开发的一部分创建的，但 Web 的实现并不遵守 REST 架构风格中的每一个约束。不匹配可能由于无知或疏忽而发生，但 REST 架构风格的存在意味着它们可以在标准化之前被识别出来。例如，Fielding 将会话信息嵌入 URI 确定为违反 REST 的约束，这会对共享缓存和服务器可扩展性产生负面影响。<a href="https://en.wikipedia.org/wiki/HTTP_cookies">HTTP cookie</a>也违反了 REST 约束，因为它们可能与浏览器的应用程序状态不同步，从而使它们不可靠；它们还包含可能涉及隐私和安全的不透明数据。</p><p>REST 已被整个软件行业采用，并且是一套被广泛接受的用于创建无状态、可靠的<a href="https://en.wikipedia.org/wiki/Web_API">Web API 的指南</a>。遵守<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints">REST 约束的</a>Web API被非正式地描述为<strong>RESTful</strong>。RESTful Web API 通常松散地基于<a href="https://en.wikipedia.org/wiki/HTTP_method">HTTP 方法</a>，通过<a href="https://en.wikipedia.org/wiki/URL-encoding">URL 编码的</a>参数访问<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_concepts">资源</a>，并使用<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或<a href="https://en.wikipedia.org/wiki/XML">XML</a>传输数据。</p><p>为了创建 REST 架构风格，Fielding 确定了在创建基于全球网络的应用程序时适用的要求，例如需要低进入壁垒以实现全球采用。他还调查了基于网络的应用程序的许多现有架构风格，确定了哪些功能与其他风格共享，例如缓存和客户端-服务器功能，以及 REST 独有的功能，例如资源概念。Fielding 试图对当前实现的现有架构进行分类，并确定哪些方面应该被视为 Web 的行为和性能要求的核心。</p><p>其核心原则是定义可以用少量方法控制的命名资源。这些资源和方法被称为 API 的“名词”和“动词”。使用 HTTP 协议时，资源名称自然映射到网址，方法自然映射到 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>。这使得要学习的内容减少了很多，因为开发人员可以专注于资源及其关系，并假定它们拥有的标准方法同样很少。</p><p>一个万维网应该如何工作的模型。</p><p>REST 最初被称为“HTTP 对象模型”，但该名称通常会导致将其误解为 HTTP 服务器的实现模型。“具象状态转移”这个名称旨在唤起一个精心设计的 Web 应用程序行为的图像：网页网络（虚拟状态机），用户通过选择链接（状态转换）在应用程序中前进。REST 提供了一组架构约束，当作为一个整体应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署和中间组件，以减少交互延迟、加强安全性和封装遗留系统。</p><p>Representational State Transfer (REST) 风格是分布式超媒体系统中架构元素的抽象。REST 忽略了组件实现和协议语法的细节，以便专注于组件的角色、它们与其他组件交互的约束以及它们对重要数据元素的解释。它包含对组件、连接器和数据的基本约束，这些约束定义了 Web 体系结构的基础，从而定义了其作为基于网络的应用程序的行为的本质。</p><p>REST 定义了一个预期应用程序行为模型，该模型支持简单而健壮的应用程序，这些应用程序在很大程度上不受困扰大多数基于网络的应用程序的部分故障条件的影响。</p><p>通过将延迟减少作为架构目标，REST 可以根据用户感知的性能区分媒体类型（表示的数据格式）。</p><p>REST 是一组协调的架构约束，它试图最大限度地减少延迟和网络通信，同时最大限度地提高组件实现的独立性和可扩展性。这是通过对连接器语义施加约束来实现的，而其他样式则专注于组件语义。REST 实现了交互的缓存和重用、组件的动态可替代性以及中介对动作的处理，从而满足了互联网规模的分布式超媒体系统的需求。</p><p>REST 仅详细阐述了被认为对互联网规模的分布式超媒体交互必不可少的架构部分。对于基于网络的应用程序，系统性能取决于网络通信。对于分布式超媒体系统，组件交互由大粒度数据传输而不是计算密集型任务组成。REST 风格是为响应这些需求而开发的。它对资源和表示的通用连接器接口的关注启用了组件的中间处理、缓存和可替换性，这反过来又允许基于 Web 的应用程序从 1994 年的 100,000 个请求/天扩展到 1999 年的 600,000,000 个请求/天。</p><p>REST 或 REpresentational State Transfer 是一种架构风格，用于在网络上的计算机系统之间提供标准，使系统更容易相互通信。符合 REST 的系统，通常称为 RESTful 系统，其特点是它们是无状态的，并且将客户端和服务器的关注点分开。</p><p>2000 年，Roy Fielding 提出了表征状态转移 (REST) 作为设计 Web 服务的架构方法。REST 是一种基于超媒体构建分布式系统的架构风格。REST 独立于任何底层协议，不一定与 HTTP 绑定。但是，最常见的 REST API 实现使用 HTTP 作为应用程序协议。REST 相对于 HTTP 的主要优势在于它使用开放标准，并且不会将 API 或客户端应用程序的实现绑定到任何特定实现。</p><ul><li>REST API 是围绕<em>资源</em>设计的，<em>资源</em>是客户端可以访问的任何类型的对象、数据或服务。</li><li>资源有一个<em>identifier</em>，它是唯一标识该资源的 URI。</li><li>客户端通过交换资源<em>表示</em>与服务交互。</li><li>REST API 使用统一的接口，这有助于将客户端和服务实现解耦。对于基于 HTTP 构建的 REST API，统一接口包括使用标准 HTTP 动词对资源执行操作。最常见的操作是 GET、POST、PUT、PATCH 和 DELETE。</li><li>REST API 使用无状态请求模型。HTTP 请求应该是独立的并且可以以任何顺序发生，因此在请求之间保持瞬态信息是不可行的。唯一存储信息的地方是资源本身，每个请求都应该是一个原子操作。此约束使 Web 服务具有高度可扩展性，因为无需在客户端和特定服务器之间保留任何关联。任何服务器都可以处理来自任何客户端的任何请求。也就是说，其他因素可能会限制可扩展性。</li><li>REST API 由表示中包含的超媒体链接驱动。</li></ul><h2 id="架构约束"><a href="#架构约束" class="headerlink" title="架构约束"></a>架构约束</h2><p>六个指导性约束定义了一个 RESTful 系统。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-SOA_with_REST-6">6] </a>[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Richardson_2007-8">8]</a>这些约束限制了服务器处理和响应客户端请求的方式，因此，通过在这些约束内运行，系统可以获得理想的<a href="https://en.wikipedia.org/wiki/Non-functional_requirement">非功能特性</a>，例如性能、可伸缩性、简单性、可修改性、可见性、便携性和可靠性。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a>如果系统违反了任何必需的约束，则不能将其视为 RESTful。</p><p>正式的 REST 约束如下：</p><h3 id="客户端-服务端架构"><a href="#客户端-服务端架构" class="headerlink" title="客户端-服务端架构"></a>客户端-服务端架构</h3><p>关注点分离是客户端-服务器约束背后的原则。通过将用户界面问题与数据存储问题分开，我们提高了用户界面跨多个平台的可移植性，并通过简化服务器组件提高了可扩展性。然而，也许对 Web 最重要的是分离允许组件独立发展，从而支持多个组织域的 Internet 规模需求。</p><p>在 REST 架构风格中，客户端的实现和服务器的实现可以独立完成，彼此互不了解。只要每一方都知道要向另一方发送什么格式的消息，它们就可以保持模块化和分离。将用户界面问题与数据存储问题分开，我们提高了跨平台界面的灵活性，并通过简化服务器组件来提高可扩展性。此外，分离允许每个组件独立发展的能力。通过使用 REST 接口，不同的客户端访问相同的 REST 端点，执行相同的操作，并接收相同的响应。</p><p>一个或多个客户端必须能够同时监视和操作同一资源。</p><p>大多数现代 Web 应用程序都公开了客户端可用于与应用程序交互的 API。一个设计良好的 Web API 应该旨在支持：</p><ul><li><strong>平台独立性</strong>。无论 API 在内部如何实现，任何客户端都应该能够调用 API。这需要使用标准协议，并具有一种机制，使客户端和 Web 服务可以就要交换的数据格式达成一致。</li><li><strong>服务进化</strong>。Web API 应该能够独立于客户端应用程序发展和添加功能。随着 API 的发展，现有的客户端应用程序应该无需修改即可继续运行。所有功能都应该是可发现的，以便客户端应用程序可以充分使用它。</li></ul><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>在计算中，无状态协议是一种<a href="https://en.wikipedia.org/wiki/Communications_protocol">通信协议</a>，其中接收方（通常是服务器）不保留会话信息。客户端将相关会话数据发送到接收器，这样传输的每个信息包都可以被孤立地理解，而无需会话中先前数据包的上下文信息。无状态协议的这一特性使它们成为高容量应用程序的理想选择，通过消除由保留会话信息引起的服务器负载来提高性能。</p><p>我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_3">第 3.4.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_3">图 5-3</a>）的客户端-无状态-服务器 (CSS) 风格，这样从客户端到服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。这种约束导致了可见性、可靠性和可伸缩性的特性。可见性得到改善，因为监控系统不必查看单个请求数据之外的内容来确定请求的全部性质。可靠性得到提高，因为它简化了从部分故障中恢复的任务 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。可扩展性得到改进，因为不必在请求之间存储状态允许服务器组件快速释放资源，并进一步简化实现，因为服务器不必管理跨请求的资源使用。与大多数架构选择一样，无状态约束反映了设计权衡。缺点是它可能会通过增加一系列请求中发送的重复数据（每次交互开销）来降低网络性能，因为这些数据不能在共享上下文中留在服务器上。此外，将应用程序状态置于客户端会减少服务器对一致应用程序行为的控制，因为应用程序变得依赖于跨多个客户端版本的正确语义实现。</p><p>遵循 REST 范式的系统是无状态的，这意味着服务器不需要知道客户端处于什么状态，反之亦然。这样，服务器和客户端都可以理解收到的任何消息，即使没有看到以前的消息。这种无状态约束是通过使用<em>资源</em>而不是<em>命令</em>来强制执行的。资源是 Web 的名词——它们描述您可能需要存储或发送到其他服务的任何对象、文档或 <em>事物</em>。由于 REST 系统通过对资源的标准操作进行交互，因此它们不依赖于接口的实现。这些约束帮助 RESTful 应用程序实现可靠性、快速性能和可扩展性，作为可以管理、更新和重用的组件，即使在系统运行期间也不影响整个系统。</p><p>系统状态应该始终是可发现和可测试的。即使操作跟踪资源不再处于活动状态，客户端也应该能够确定系统状态。查询长时间运行的操作状态的行为本身应该利用网络的原则。即具有统一接口语义的明确定义的资源。客户端可以对某些资源发出 GET 请求以确定长时间运行的操作的状态</p><p>长期运行的操作应该适用于希望“即发即忘”的客户以及希望积极监控结果并采取行动的客户。</p><p>取消并不明确意味着回滚。在每个 API 定义的情况下，它可能意味着回滚、补偿、完成或部分完成等。在取消操作之后，客户不应该负责将服务返回到允许继续服务的一致状态。</p><h3 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h3><p>在万维网上，客户端和中介可以缓存响应。响应必须隐式或显式地将自己定义为可缓存或不可缓存，以防止客户端提供陈旧或不适当的数据以响应进一步的请求。管理良好的缓存部分或完全消除了一些客户端-服务器交互，进一步提高了可扩展性和性能。</p><p>为了提高网络效率，我们添加缓存约束，形成<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_4">3.4.4节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_4">图5-4</a>）的client-cache-stateless-server样式。缓存约束要求对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权为以后的等效请求重用该响应数据。添加缓存约束的优势在于它们有可能通过减少一系列交互的平均延迟来部分或完全消除某些交互，从而提高效率、可扩展性和用户感知性能。然而，权衡是，如果缓存中的陈旧数据与将请求直接发送到服务器时获得的数据显着不同，则缓存会降低可靠性。</p><h3 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h3><p>统一接口约束是任何 RESTful 系统设计的基础。它简化和解耦了架构，使每个部分都可以独立演进。这个统一接口的四个约束是：</p><ul><li>请求中的资源标识 - 单个资源在请求中标识，例如在 RESTful Web 服务中使用URI。资源本身在概念上与返回给客户端的表示分开。例如，服务器可以以HTML、XML或JSON格式从其数据库发送数据——这些都不是服务器的内部表示。</li><li>通过表示进行资源操作 - 当客户端持有资源的表示（包括附加的任何<a href="https://en.wikipedia.org/wiki/Metadata">元数据）时</a>，它有足够的信息来修改或删除资源的状态。</li><li>自描述消息 - 每条消息都包含足够的信息来描述如何处理消息。例如，要调用的解析器可以由<a href="https://en.wikipedia.org/wiki/Media_type">媒体类型</a>指定。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a></li><li>超媒体作为应用状态（发动机<a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>） -已经进入一个初始的URI REST应用类似于人类的Web用户访问该<a href="https://en.wikipedia.org/wiki/Home_page">主页</a>网站-REST客户端的话应该能够动态地使用服务器提供的链接发现它需要的所有可用资源。随着访问的进行，服务器以包含指向当前可用的其他资源的<a href="https://en.wikipedia.org/wiki/Hyperlink">超链接的</a>文本进行响应。客户端无需使用有关应用程序结构或动态的信息进行硬编码。</li></ul><p>将 REST 架构风格与其他基于网络的风格区分开来的核心特征是它强调组件之间的统一接口（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_6">图 5-6</a>）。通过将通用性的软件工程原理应用于组件接口，简化了整个系统架构并提高了交互的可见性。实现与它们提供的服务分离，这鼓励了独立的可进化性。然而，代价是统一的接口会降低效率，因为信息是以标准化的形式传输的，而不是特定于应用程序需求的形式。REST 接口被设计为高效的大粒度超媒体数据传输，针对 Web 的常见情况进行优化，但导致接口对于其他形式的架构交互不是最佳的。为了获得统一的接口，需要多个架构约束来指导组件的行为。REST 由四个接口约束定义：资源识别、通过表征操纵资源、自我描述信息、超媒体作为应用程序状态的引擎。</p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>客户端通常无法判断它是直接连接到终端服务器还是沿途的中介。如果在客户端和服务器之间放置代理或负载均衡器，则不会影响它们的通信，也不需要更新客户端或服务器代码。中间服务器可以通过启用负载平衡和提供共享缓存来提高系统可扩展性。此外，安全性可以添加为 Web 服务之上的一个层，将业务逻辑与安全逻辑分开。将安全添加为一个单独的层会强制执行安全策略。最后，中间服务器可以调用多个其他服务器来生成对客户端的响应。</p><p>为了进一步改善 Internet 规模需求的行为，我们添加了分层系统约束（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_7">图 5-7</a>）。如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_2">第 3.4.2 节</a>所述，分层系统风格允许架构通过约束组件行为而由分层层组成，使得每个组件不能“看到”超出与其交互的直接层。通过将系统的知识限制在单个层，我们对整个系统的复杂性进行了限制，并促进了基板的独立性。层可用于封装遗留服务并保护来自遗留客户端的新服务，通过将不常用的功能移动到共享中介来简化组件。中介还可用于通过跨多个网络和处理器实现服务负载平衡来提高系统可扩展性。分层系统的主要缺点是它们增加了数据处理的开销和延迟，降低了用户感知的性能 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_32">32</a> ]。对于支持缓存约束的基于网络的系统，这可以被中介共享缓存的好处所抵消。在组织域的边界放置共享缓存可以带来显着的性能优势 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_136">136</a> ]。这些层还允许对跨越组织边界的数据实施安全策略，这是防火墙的要求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_79">79</a> ]。分层系统和统一接口约束的组合产生类似于统一管道和过滤器风格（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_2_2">第 3.2.2 节</a>）的架构特性。尽管 REST 交互是双向的，但超媒体交互的大粒度数据流都可以像数据流网络一样进行处理，过滤器组件有选择地应用于数据流，以便在内容通过时对其进行转换 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_26">26</a> ]。在 REST 中，中介组件可以主动转换消息的内容，因为消息是自描述的，并且它们的语义对中介是可见的。</p><h3 id="按需代码（可选）"><a href="#按需代码（可选）" class="headerlink" title="按需代码（可选）"></a>按需代码（可选）</h3><p>服务器可以通过传输可执行代码来临时扩展或自定义客户端的功能：例如，已编译的组件（如Java 小程序）或客户端脚本（如JavaScript）。</p><p>我们为 REST 设置的最后一项约束来自<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_5_3">第 3.5.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_8">图 5-8</a>）的按需代码风格。REST 允许通过下载和执行小程序或脚本形式的代码来扩展客户端功能。这通过减少需要预先实现的功能数量来简化客户端。允许在部署后下载功能提高了系统可扩展性。但是，它也会降低可见性，因此它只是 REST 中的一个可选约束。可选约束的概念似乎是矛盾的。但是，它在包含多个组织边界的系统的架构设计中确实有其用途。这意味着体系结构只有在已知可选约束对整个系统的某些领域有效时才能获得它们的好处（并遭受缺点）。可选约束允许我们设计一个架构，在一般情况下支持所需的行为，但要理解它可能在某些上下文中被禁用。</p><h2 id="架构元素"><a href="#架构元素" class="headerlink" title="架构元素"></a>架构元素</h2><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p><img src="/images/SAC/REST/data_element.png"></p><p>数据元素的性质和状态是 REST 架构的一个重要方面。</p><p>许多分布式处理范式将处理逻辑（例如代码、存储过程、搜索表达式等，MapReduce 即是此思想的代表）移动到数据端，而不是将数据移动到处理组件中，这些分布式对象的所有数据都封装在处理组件中并由处理组件隐藏。在 REST 架构中，用户选择链接后，数据需要从其存储位置移动到用户的位置。有如下三种基本的数据移动方式：</p><ol><li><strong>在数据所在的位置渲染数据并将固定格式的渲染结果发送给接收者。</strong>传统的客户端 - 服务器风格，允许所有关于数据真实性质的信息隐藏在发送者中，防止对数据结构做出假设并使客户端实现更容易。但是，它也严重限制了接收方的功能，并将大部分处理负载置于发送方，从而导致可扩展性问题。    </li><li><strong>用渲染引擎封装数据并发送给接收者。</strong>移动对象样式 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_50">50</a>]，提供信息隐藏，同时通过其独特的渲染引擎对数据进行专门处理，但将接收方的功能限制在该引擎中的预期范围内，并可能大大增加传输的数据量。</li><li><strong>将原始数据连同描述数据类型的元数据一起发送给接收者，以便接收者可以选择自己的渲染引擎。</strong>允许发送方在最小化传输的字节数的同时保持简单和可扩展，但失去了信息隐藏的优势，并且要求发送方和接收方都理解相同的数据类型。</li></ol><p>REST 通过关注对数据类型与元数据的共同理解，提供了所有三个选项的混合，但限制了向标准化接口显示的内容的范围。REST 组件通过以与一组不断发展的标准数据类型之一匹配的格式传输资源的表示来进行通信，根据接收者的能力或愿望以及资源的性质动态选择。无论表示形式与原始源的格式相同，还是源自源，都隐藏在界面后面。通过发送由封装渲染引擎的标准数据格式中的指令组成的表示，可以近似移动对象样式的好处。因此，REST 获得了客户端-服务器风格的关注点分离，而没有服务器可扩展性问题，允许通过通用接口隐藏信息以实现服务的封装和演变，并通过可下载的功能引擎提供多样化的功能集。</p><p>REST 中信息的关键抽象是<em>资源</em>。任何可以命名的信息都可以是资源：文档或图像、时间服务（例如“洛杉矶今天的天气”）、其他资源的集合、非虚拟对象（例如人）等. 换句话说，任何可能成为作者超文本引用目标的概念都必须符合资源的定义。资源是到一组实体的概念映射，而不是在任何特定时间点对应于映射的实体。更准确地说，资源<em>R</em>是随时间变化的隶属函数<em>M</em> R <em>(t)<em>，它在时间</em>t</em>映射到一组等效的实体或值。集合中的值可以是<em>资源表示</em>和/或<em>资源标识符</em>。资源可以映射到空集，这允许在该概念的任何实现存在之前对其进行引用——这个概念对于 Web 之前的大多数超文本系统来说是陌生的 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_61">61]</a>]。某些资源在某种意义上是静态的，即在它们创建后的任何时间进行检查时，它们始终对应于相同的值集。其他人的价值随着时间的推移有很大程度的变化。资源唯一需要静态的是映射的语义，因为语义是区分一种资源与另一种资源的原因。资源的这种抽象定义启用了 Web 架构的关键特性。首先，它通过包含许多信息源而没有人为地按类型或实现来区分它们来提供通用性。其次，它允许对表示的引用进行后期绑定，从而能够根据请求的特征进行内容协商。最后，它允许作者引用该概念而不是该概念的某些单一表示，从而无需在表示更改时更改所有现有链接（假设作者使用了正确的标识符）。REST 使用资源标识符来标识组件之间交互中涉及的特定资源。REST 连接器提供了一个通用接口，用于访问和操作资源的值集，而不管成员函数是如何定义的或处理请求的软件类型如何。分配资源标识符的命名机构，使引用资源成为可能，负责随着时间的推移维护映射的语义有效性（即，确保成员函数不会改变）。</p><p>REST 组件通过使用表示来捕获该资源的当前或预期状态并在组件之间传输该表示来对资源执行操作。表示是一个字节序列，加上描述这些字节的表示元数据。表示的其他常用但不太精确的名称包括：文档、文件和 HTTP 消息实体、实例或变体。表示包括数据、描述数据的元数据，有时还包括描述元数据的元数据（通常用于验证消息完整性）。元数据采用名称-值对的形式，其中名称对应于定义值结构和语义的标准。响应消息可能包括表示元数据和资源元数据：关于资源的信息，不是特定于所提供的表示。控制数据定义了组件之间消息的目的，例如请求的操作或响应的含义。它还用于参数化请求并覆盖某些连接元素的默认行为。例如，缓存行为可以通过包含在请求或响应消息中的控制数据进行修改。根据消息控制数据，给定的表示可以指示所请求资源的当前状态、所请求资源的期望状态或某些其他资源的值，例如客户端查询表单中输入数据的表示，或响应的某些错误条件的表示。例如，资源的远程创作要求创作者向服务器发送一个表示，从而为该资源建立一个值，该值可以由以后的请求检索。如果给定时间资源的值集由多个表示组成，则可以使用内容协商来选择最佳表示以包含在给定消息中。</p><p>但定义比这更普遍：任何可以命名的信息都可以是资源：图像、数据库查询、时间服务（例如“伦敦今天的天气”），甚至是其他资源的集合</p><p>面向资源的 API 通常被构建为资源层次结构，其中每个节点是一个“简单资源”或“集合资源”。为方便起见，它们通常被分别称为资源和集合。</p><ul><li>一个集合包含<strong>相同类型</strong>的资源列表。 例如，一个用户拥有一组联系人。</li><li>资源具有一些状态和零个或多个子资源。 每个子资源可以是一个简单资源或一个集合资源。</li></ul><p>例如，Gmail API 有一组用户，每个用户都有一组消息、一组线程、一组标签、一个个人资料资源和若干设置资源。</p><p>虽然存储系统和 REST API 之间存在一些概念上的对应，但具有面向资源 API 的服务不一定是数据库，并且在解释资源和方法方面具有极大的灵活性。例如，创建日历事件（资源）可以为参与者创建附加事件、向参与者发送电子邮件邀请、预约会议室以及更新视频会议时间安排。</p><p>虽然完整的资源名称类似于普通网址，但两者并不相同。单个资源可以由不同的 API 版本、API 协议或 API 网络端点公开。完整资源名称未指明此类信息，因此在实际使用中必须将其映射到特定的 API 版本和 API 协议。</p><p>“Web 资源”首先在万维网上定义为由其URL标识的文档或文件。今天，该定义更加通用和抽象，包括可以在 Web 上以任何方式识别、命名、寻址、处理或执行的所有事物、实体或操作。在 RESTful Web 服务中，对资源的<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>发出的请求会引发响应，其<a href="https://en.wikipedia.org/wiki/Payload_(computing)">有效负载</a>格式为<a href="https://en.wikipedia.org/wiki/HTML">HTML</a>、<a href="https://en.wikipedia.org/wiki/XML">XML</a>、<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或某种其他格式。例如，响应可以确认资源状态已更改。响应还可以包含<a href="https://en.wikipedia.org/wiki/Hypertext">超文本</a>相关资源的链接。这些请求和响应最常见的协议是 HTTP。它提供操作（<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP 方法</a>），例如 GET、POST、PUT 和 DELETE。通过使用无状态协议和标准操作，RESTful 系统旨在通过重用可以管理和更新的组件来实现快速性能、可靠性和增长能力，即使在系统运行时也不影响整个系统。</p><p>客户端只能使用<strong>URI</strong>访问资源。换句话说，客户端使用 URI 请求资源，服务器使用资源的<strong>表示</strong>进行响应。资源的表示是 REST 中的另一个重要概念。为了确保响应可以被尽可能多的客户端<strong>应用程序</strong>解释，资源的表示以超文本格式发送。因此，通过在客户端和服务器之间的<strong>消息中</strong>传输的超文本表示来操纵资源。客户端和服务器的强解耦以及使用统一寻址协议的基于文本的信息传输为满足 Web 的要求提供了基础：健壮性（无政府可扩展性）、组件的独立部署、大粒度数据传输和内容读者、内容作者和开发人员的低准入门槛。</p><p>REST 架构风格的约束影响以下架构属性：</p><ul><li>组件交互中的性能，这可能是用户感知性能和网络效率的主导因素；[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch2-7">7]</a></li><li><a href="https://en.wikipedia.org/wiki/Scalability">可扩展性</a>允许支持大量组件和组件之间的交互；</li><li>统一界面的简单性；</li><li>组件的可修改性以满足不断变化的需求（即使在应用程序运行时）；</li><li>服务代理组件之间通信的可见性；</li><li>通过随数据移动程序代码来实现组件的可移植性；</li><li>在组件、连接器或数据中存在故障时，系统级抗故障的可靠性。</li></ul><p>REST 用于定义 URI 标准的术语资源 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_21">21</a>]，以及通过其表示来操作资源的通用接口的整体语义。早期的 Web 架构将 URI 定义为文档标识符。作者被指示根据文档在网络上的位置来定义标识符。然后可以使用 Web 协议来检索该文档。然而，由于多种原因，这个定义被证明是不令人满意的。首先，它表明作者正在识别传输的内容，这意味着只要内容发生变化，标识符就应该改变。其次，存在许多对应于服务而不是文档的地址——作者可能打算将读者引导至该服务，而不是先前访问该服务的任何特定结果。最后，在某些时间段存在与文档不对应的地址，REST 中资源的定义基于一个简单的前提：标识符应尽可能不经常更改。因为 Web 使用嵌入式标识符而不是链接服务器，作者需要一个与他们想要的超媒体引用语义密切匹配的标识符，允许引用保持静态，即使访问该引用的结果可能会随着时间的推移而改变。REST 通过将资源定义为作者想要识别的语义，而不是在创建引用时对应于这些语义的值来实现这一点。然后由作者确保为引用选择的标识符确实标识了预期的语义。</p><p>定义资源以便 URI 标识概念而不是文档给我们留下了另一个问题：用户如何访问、操作或传输概念，以便在选择超文本链接时他们可以获得有用的东西？REST 通过将被操作的事物定义为已识别资源的表示而不是资源本身来回答这个问题。源服务器维护从资源标识符到对应于每个资源的一组表示的映射。因此，通过资源标识符定义的通用接口传输表示来操纵资源。REST 对资源的定义源自 Web 的核心需求：跨多个信任域独立创作互连的超文本。强制接口定义与接口要求相匹配会导致协议看起来模糊，但这只是因为被操作的接口只是一个接口而不是一个实现。协议特定于应用程序操作的意图，但接口背后的机制必须决定该意图如何影响资源映射到表示的底层实现。信息隐藏是推动 REST 统一接口的关键软件工程原则之一。由于客户端仅限于对表示的操作而不是直接访问资源的实现，因此可以以命名机构所需的任何形式构造实现，而不会影响可能使用其表示的客户端。此外，如果在访问资源时存在多个资源表示，则可以使用内容选择算法来动态选择最适合该客户端能力的表示。当然，缺点是资源的远程创作不像文件的远程创作那么简单。</p><p>通过 Web 的统一接口进行远程创作的挑战是由于客户端可以检索的表示与服务器上可能用于存储、生成或检索该表示的内容的机制之间的分离。单个服务器可以将其命名空间的某些部分映射到文件系统，文件系统又映射到可以映射到磁盘位置的 inode 的等价物，但是这些底层机制提供了一种将资源与一组表示相关联的方法，而不是而不是识别资源本身。许多不同的资源可以映射到相同的表示，而其他资源可能根本没有映射。资源不是存储对象。资源不是服务器用来处理存储对象的机制。资源是一个概念映射——服务器接收标识符（标识映射）并将其应用于其当前的映射实现（通常是特定于集合的深度树遍历和/或哈希表的组合）以查找当前负责的处理程序实现和处理程序实现然后根据请求内容选择适当的操作+响应。所有这些特定于实现的问题都隐藏在 Web 界面后面；只能通过 Web 界面访问的客户端无法假定它们的性质。</p><p>如上所述，一个资源可以有许多标识符。换句话说，当用于访问服务器时，可能存在两个或多个具有等效语义的不同 URI。也可能有两个 URI 导致在访问服务器时使用相同的机制，但这些 URI 标识两个不同的资源，因为它们的含义不同。语义是分配资源标识符和用表示填充这些资源的行为的副产品。服务器或客户端软件在任何时候都不需要知道或理解 URI 的含义——它们只是作为一个渠道，资源的创建者（人类命名机构）通过它可以将表示与由 URI 标识的语义相关联。 URI。换句话说，服务器上没有资源；只是通过资源定义的抽象接口提供答案的机制。这可能看起来很奇怪，但这就是使 Web 能够跨许多不同实现工作的本质。</p><p>尽管 URI 设计符合 REST 的标识符架构概念，但仅靠语法不足以强制命名机构根据资源模型定义自己的 URI。一种滥用形式是在超媒体响应表示引用的所有 URI 中包含标识当前用户的信息。当软件试图将 Web 视为分布式文件系统时，会发生与 REST 资源接口的另一个冲突。由于文件系统公开其信息的实现，因此存在将这些信息“镜像”到多个站点的工具，作为负载平衡和重新分配更接近用户的内容的一种手段。但是，它们之所以能够这样做，只是因为文件具有一组固定的语义（命名的字节序列），可以轻松复制。相比之下，尝试将 Web 服务器的内容镜像为文件将失败，因为资源接口并不总是与文件系统的语义匹配，并且因为数据和元数据都包含在表示的语义中并且对表示的语义很重要. 可以在远程站点复制 Web 服务器内容，但只能通过复制整个服务器机制和配置，或选择性地仅复制那些具有已知静态表示的资源。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>![image-20210913181829225](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913181829225.png)</p><p>REST 使用各种连接器类型（在<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#tab_5_2">表 5-2</a>中进行了总结）来封装访问资源和传输资源表示的活动。连接器为组件通信提供了一个抽象接口，通过提供清晰的关注点分离和隐藏资源和通信机制的底层实现来增强简单性。接口的通用性还实现了可替换性：如果用户只能通过抽象接口访问系统，则可以在不影响用户的情况下替换实现。由于连接器管理组件的网络通信，因此可以在多个交互之间共享信息，以提高效率和响应能力。所有 REST 交互都是无状态的。也就是说，每个请求都包含连接器理解请求所需的所有信息，独立于可能在它之前的任何请求。这种限制实现了四个功能：1）它消除了连接器在请求之间保留应用程序状态的任何需要，从而减少了物理资源的消耗并提高了可扩展性；2）它允许并行处理交互，而不需要处理机制理解交互语义；3）它允许中介孤立地查看和理解请求，这在服务动态重新排列时可能是必要的；并且，4) 它强制所有可能影响缓存响应可重用性的信息出现在每个请求中。主要的连接器类型是客户端和服务器。第三种连接器类型，缓存连接器，可以位于客户端或服务器连接器的接口上，以便保存对当前交互的可缓存响应，以便它们可以重用于以后请求的交互。REST 试图在缓存行为的透明性需求与高效使用网络的需求之间取得平衡，而不是假设始终需要绝对透明性。缓存能够确定响应的可缓存性，因为接口是通用的而不是特定于每个资源的。默认情况下，对检索请求的响应是可缓存的，而对其他请求的响应是不可缓存的。如果某种形式的用户身份验证是请求的一部分，或者如果响应指示不应共享它，则该响应只能由非共享缓存进行缓存。组件可以通过包含将交互标记为可缓存、不可缓存或仅在有限时间内可缓存的控制数据来覆盖这些默认值。解析器将部分或完整的资源标识符转换为建立组件间连接所需的网络地址信息。连接器类型的最后一种形式是隧道，它只是跨连接边界中继通信，例如防火墙或较低级别的网络网关。它被建模为 REST 的一部分而不是作为网络基础设施的一部分抽象出来的唯一原因是某些 REST 组件可能会从活动组件行为动态切换到隧道行为。主要示例是 HTTP 代理，它响应 CONNECT 方法请求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_71">71</a> ]切换到隧道，从而允许其客户端使用不允许代理的不同协议（例如 TLS）直接与远程服务器通信。当两端终止通信时，隧道消失。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>![image-20210913182732672](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913182732672.png)</p><p>用户代理使用客户端连接器发起请求并成为响应的最终接收者。最常见的示例是 Web 浏览器，它提供对信息服务的访问并根据应用程序需要呈现服务响应。源服务器使用服务器连接器来管理所请求资源的命名空间。它是其资源表示的最终来源，并且必须是旨在修改其资源值的任何请求的最终接收者。每个源服务器为其服务提供一个通用接口作为资源层次结构。资源实现细节隐藏在接口后面。中间组件既充当客户端又充当服务器，以便在可能的翻译、请求和响应的情况下进行转发。</p><p>![image-20210913183608285](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913183608285.png)</p><p>REST 的客户端-服务器关注点分离简化了组件实现，降低了连接器语义的复杂性，提高了性能调优的有效性，并增加了纯服务器组件的可扩展性。分层系统约束允许在通信中的各个点引入中介——代理、网关和防火墙——而不改变组件之间的接口，从而允许它们通过大规模共享缓存来协助通信转换或提高性能。REST 通过将消息约束为自描述性来实现中间处理：请求之间的交互是无状态的，标准方法和媒体类型用于指示语义和交换信息，响应明确指示可缓存性。由于组件是动态连接的，它们的排列和功能对于特定的应用程序操作具有类似于管道和过滤器样式的特性。尽管 REST 组件通过双向流进行通信，但每个方向的处理都是独立的，因此容易受到流转换器（过滤器）的影响。通用连接器接口允许基于每个请求或响应的属性将组件放置在流上。服务可以使用复杂的中介层次结构和多个分布式源服务器来实现。REST 的无状态特性允许每个交互独立于其他交互，无需了解整体组件拓扑，这是 Internet 规模架构不可能完成的任务，并允许组件充当目的地或中介，动态确定通过每个请求的目标。连接器只需要在其通信范围内知道彼此的存在，尽管出于性能原因，它们可能会缓存其他组件的存在和功能。</p><p>客户端连接器检查资源标识符，以便为每个请求选择适当的通信机制。例如，当标识符指示它是本地资源时，客户端可以被配置为连接到特定代理组件，可能充当注释过滤器的代理组件。同样，客户端可以配置为拒绝对某些标识符子集的请求。REST 不限制特定协议的通信，但它确实限制了组件之间的接口，因此限制了组件之间可能以其他方式进行的交互和实现假设的范围。</p><p>REST 组件交互以分层的客户端-服务器风格构建，但通用资源接口的附加约束为中介提供了可替代性和检查的机会。请求和响应具有远程调用风格的外观，但 REST 消息针对的是概念资源而不是实现标识符。已经进行了多次尝试将 Web 体系结构建模为分布式文件系统（例如 WebNFS）的形式或分布式对象系统 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_83">83</a> ]。然而，他们将各种 Web 资源类型或实现策略排除为“不有趣”，而实际上它们的存在使这些模型的假设无效。REST 运行良好，因为它不会将资源的实现限制为某些预定义的模型，允许每个应用程序选择最符合其自身需求的实现，并能够在不影响用户的情况下替换实现。向消费组件发送资源表示的交互方法与基于事件的集成 (EBI) 风格有一些相似之处。主要区别在于 EBI 样式是基于推送的。包含状态的组件（相当于 REST 中的源服务器）在状态更改时发出事件，无论是否有任何组件实际上对此类事件感兴趣或侦听此类事件。在 REST 风格中，消费组件通常会提取表示。尽管将其视为希望监控单个资源的单个客户端时效率较低，但 Web 的规模使得不受监管的推送模型不可行。</p><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><ul><li><p>围绕资源组织 API 设计</p><p>关注 Web API 公开的业务实体。如果可能，资源 URI 应基于名词（资源）而不是动词（对资源的操作）。资源不必基于单个物理数据项。避免创建简单地反映数据库内部结构的 API。REST 的目的是对实体以及应用程序可以对这些实体执行的操作进行建模。客户端不应暴露于内部实现。实体通常被组合成集合（订单、客户）。集合是与集合中的项目不同的资源，应该有自己的 URI。如有必要，在数据库和 Web API 之间引入一个映射层。这样，客户端应用程序就与底层数据库方案的更改隔离开来。</p><p>在 URI 中采用一致的命名约定。一般来说，对引用集合的 URI 使用复数名词会有所帮助。将集合和项目的 URI 组织成层次结构是一种很好的做法。这种方法有助于保持 Web API 的直观性。</p><p>还要考虑不同类型资源之间的关系以及如何公开这些关联。更好的解决方案是在 HTTP 响应消息的正文中提供指向相关资源的可导航链接。在更复杂的系统中，提供 URI 使客户端能够浏览多个级别的关系可能很诱人，例如<code>/customers/1/orders/99/products</code>. 但是，如果资源之间的关系在未来发生变化，这种复杂程度可能难以维护并且不灵活。相反，尽量保持 URI 相对简单。一旦应用程序拥有对资源的引用，就应该可以使用此引用来查找与该资源相关的项目。可以将前面的查询替换为 URI<code>/customers/1/orders</code>来查找客户 1 的所有订单，然后<code>/orders/99/products</code>查找该订单中的产品。</p><p>另一个因素是所有 Web 请求都会对 Web 服务器施加负载。请求越多，负载越大。因此，尽量避免暴露大量小资源的“健谈”Web API。此类 API 可能需要客户端应用程序发送多个请求以查找其所需的所有数据。相反，您可能希望对数据进行非规范化并将相关信息组合到可以通过单个请求检索的更大资源中。但是，您需要平衡这种方法与获取客户端不需要的数据的开销。检索大对象会增加请求的延迟并产生额外的带宽成本。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-string">orders</span> // <span class="hljs-string">Good</span><br><br><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-built_in">create-order</span> // <span class="hljs-string">Avoid</span><br></code></pre></td></tr></table></figure></li><li><p>根据 HTTP 方法定义 API 操作</p><p>HTTP 协议定义了许多为请求分配语义的方法。大多数 RESTful Web API 使用的常见 HTTP 方法是：</p><ul><li><strong>GET</strong>在指定的 URI 处检索资源的表示。响应消息的正文包含所请求资源的详细信息。</li><li><strong>POST</strong>在指定的 URI 处创建一个新资源。请求消息的正文提供了新资源的详细信息。请注意，POST 还可用于触发实际上不创建资源的操作。</li><li><strong>PUT</strong>创建或替换指定 URI 处的资源。请求消息的正文指定要创建或更新的资源。</li><li><strong>PATCH</strong>执行资源的部分更新。请求正文指定要应用于资源的一组更改。</li><li><strong>DELETE</strong>删除指定 URI 处的资源。</li></ul><p>特定请求的效果应取决于资源是集合还是单个项目。</p><ul><li>POST 请求创建一个资源。服务器为新资源分配一个 URI，并将该 URI 返回给客户端。POST 请求还可用于将数据提交到现有资源进行处理，而无需创建任何新资源。</li><li>PUT 请求创建资源<em>或</em>更新现有资源。客户端指定资源的 URI。请求正文包含资源的完整表示。如果具有此 URI 的资源已存在，则会替换它。否则，如果服务器创建一个新资源。服务器可能支持更新，但不支持通过 PUT 创建。是否支持通过 PUT 创建取决于客户端是否可以在资源存在之前有意义地为其分配 URI。如果没有，则使用 POST 创建资源并使用 PUT 或 PATCH 进行更新。</li><li>PATCH 请求对现有资源执行<em>部分更新</em>。客户端指定资源的 URI。请求正文指定要应用于资源的一组<em>更改</em>。这比使用 PUT 更有效，因为客户端只发送更改，而不是资源的整个表示。从技术上讲，如果服务器支持，PATCH 还可以创建新资源（通过指定对“空”资源的一组更新）。</li></ul><p>PUT 请求必须是幂等的。如果客户端多次提交相同的 PUT 请求，结果应该始终相同（相同的资源将被修改为相同的值）。POST 和 PATCH 请求不保证是幂等的。</p></li><li><p>符合 HTTP 语义</p><p>JSON 合并补丁稍微简单一些。补丁文档与原始 JSON 资源具有相同的结构，但仅包含应更改或添加的字段子集。此外，可以通过<code>null</code>在补丁文档中指定字段值来删除字段。（这意味着如果原始资源可以具有显式空值，则合并补丁不适合。）JSON 合并补丁的媒体类型是<code>application/merge-patch+json</code>.如果原始资源可以包含显式空值，则不适合合并补丁，因为<code>null</code>补丁文档中的特殊含义。此外，补丁文档没有指定服务器应用更新的顺序。这可能重要也可能无关紧要，具体取决于数据和域。<a href="https://tools.ietf.org/html/rfc6902">RFC 6902 中</a>定义的 JSON 补丁更加灵活。它将更改指定为要应用的操作序列。操作包括添加、删除、替换、复制和测试（以验证值）。JSON 补丁的媒体类型是<code>application/json-patch+json</code>.</p><p>如果在向客户端发送响应之前等待完成，可能会导致无法接受的延迟。如果是这样，请考虑使操作异步。返回 HTTP 状态代码 202（已接受）以指示请求已被接受进行处理但尚未完成。您应该公开一个返回异步请求状态的端点，以便客户端可以通过轮询状态端点来监视状态。在 202 响应的 Location 标头中包含状态端点的 URI。如果客户端向此端点发送 GET 请求，则响应应包含请求的当前状态。或者，它还可以包括预计完成时间或取消操作的链接。</p></li><li><p>使用 HATEOAS 启用导航到相关资源</p><p>REST 背后的主要动机之一是应该可以在不需要 URI 方案的先验知识的情况下导航整个资源集。每个 HTTP GET 请求都应返回通过响应中包含的超链接查找与所请求对象直接相关的资源所必需的信息，并且还应提供描述对这些资源中的每一个可用的操作的信息。这一原则被称为 HATEOAS，或作为应用程序状态引擎的超文本。该系统实际上是一个有限状态机，对每个请求的响应都包含从一种状态转移到另一种状态所需的信息；不需要其他信息。</p><p>返回的链接集可能会更改，具体取决于资源的状态。这就是超文本作为“应用程序状态引擎”的含义。</p></li></ul><p>REST 要求客户端向服务器发出请求，以便检索或修改服务器上的数据。一个请求通常包括：</p><ul><li>一个 HTTP 动词，它定义了要执行的操作类型</li><li>一个<em>标头</em>，它允许客户端传递有关请求的信息</li><li>资源的路径</li><li>包含数据的可选消息正文</li></ul><p>我们在请求中使用了 4 个基本的 HTTP 动词来与 REST 系统中的资源进行交互：</p><ul><li>GET — 检索特定资源（通过 id）或资源集合</li><li>POST — 创建一个新资源</li><li>PUT — 更新特定资源（通过 id）</li><li>DELETE — 通过 id 删除特定资源</li></ul><p>请求必须包含指向应该对其执行操作的资源的路径。在 RESTful API 中，应该设计路径以帮助客户端了解正在发生的事情。路径的第一部分应该是资源的复数形式。<code>fashionboutique.com/customers/223/orders/12</code>即使您以前从未见过这条特定路径，like 路径也很清楚它指向的内容，因为它是分层的和描述性的。我们可以看到，我们正在<code>id</code>为<code>id</code>223的客户访问12的订单。路径应包含定位资源所需的特定程度所需的信息。在引用资源列表或集合时，并不总是需要添加<code>id</code>. 例如，对<code>fashionboutique.com/customers</code>路径的 POST 请求不需要额外的标识符，因为服务器将为<code>id</code>新对象生成一个。如果我们尝试访问单个资源，则需要<code>id</code>在路径后附加。例如： <code>GET fashionboutique.com/customers/:id</code>— 检索<code>customers</code>资源中<code>id</code>指定的项目。 <code>DELETE fashionboutique.com/customers/:id</code>— 删除<code>customers</code>资源中<code>id</code>指定的项目。</p><p>人类应该能够轻松阅读和构建 URL。这有助于发现并简化在没有良好支持的客户端库的平台上的采用。除了友好的 URL 之外，可以移动或重命名的资源应该公开一个包含唯一稳定标识符的 URL。可能需要与服务交互以从资源的友好名称中获取稳定的 URL，例如某些服务使用的“/my”快捷方式。稳定标识符不需要是 GUID。操作必须尽可能使用正确的 HTTP 方法，并且必须遵守操作幂等性。HTTP 方法通常称为 HTTP 动词。</p><p>随着数据的增长，集合也在增长。规划分页对于所有服务都很重要。因此，当有多个页面可用时，序列化有效负载必须包含下一个页面的不透明 URL。集合查询的结果可以根据属性值进行排序。该属性由*$orderBy<em>查询参数的值确定。如果服务不支持按</em>$orderBy*表达式中命名的属性进行排序，则服务必须以响应不支持的请求部分中定义的错误消息进行响应。</p><p>如果调用者请求在功能允许列表中发现不受支持的功能，服务必须提供错误响应。错误响应必须是来自 4xx 系列的 HTTP 状态代码，指示无法满足请求。</p><p>由于 REST 专门针对分布式信息系统，因此它将应用程序视为信息和控制替代方案的内聚结构，用户可以通过它来执行所需的任务。小粒度或中粒度消息用于控制语义，但大部分应用程序工作是通过包含完整资源表示的大粒度消息完成的。请求语义的最常见形式是检索资源的表示（例如，HTTP 中的“GET”方法），通常可以将其缓存以供以后重用。REST 将所有控制状态集中到响应交互而接收到的表示中。目标是通过消除服务器在当前请求之外保持对客户端状态的感知的任何需要来提高服务器可伸缩性。An application’s state is therefore defined by its pending requests, the topology of connected components (some of which may be filtering buffered data), the active requests on those connectors, the data flow of representations in response to those requests, and the processing of those representations as they are received by the user agent.只要没有未完成的请求，应用程序就会达到稳定状态；即，它没有未决请求，并且对其当前请求集的所有响应都已完全接收或接收到可以将它们视为表示数据流的程度。对于浏览器应用程序，此状态对应于“网页”，包括主要表示和辅助表示，例如内嵌图像、嵌入的小程序和样式表。应用稳态的重要性体现在它们对用户感知性能和网络请求流量突发性的影响中。浏览器应用程序的用户感知性能取决于稳态之间的延迟：在一个网页上选择超媒体链接和为下一个网页呈现可用信息之间的时间段。因此，浏览器性能的优化集中在减少这种通信延迟上。由于基于 REST 的架构主要通过资源表示的传输进行通信，因此延迟可能会受到通信协议设计和表示数据格式设计的影响。在接收到响应数据时增量呈现响应数据的能力取决于媒体类型的设计和每个表示中的布局信息（内嵌对象的视觉尺寸）的可用性。</p><p>一个有趣的观察是最有效的网络请求是不使用网络的请求。换句话说，重用缓存响应的能力可显着提高应用程序性能。尽管由于查找开销，使用缓存会为每个单独的请求增加一些延迟，但即使是一小部分请求导致可用缓存命中，平均请求延迟也会显着降低。应用程序的下一个控制状态驻留在第一个请求资源的表示中，因此获得第一个表示是一个优先事项。因此，REST 交互通过“先响应后思考”的协议得到改进。换句话说，一个需要每个用户操作多次交互的协议，以便在发送内容响应之前执行诸如协商功能功能之类的事情，将比 （一种协议，它首先发送最有可能是最佳的，然后在第一个响应不令人满意时为客户端提供一个可供选择的列表。） 感知速度更慢。应用程序状态由用户代理控制和存储，并且可以由来自多个服务器的表示组成。除了将服务器从存储状态的可扩展性问题中解放出来之外，这还允许用户直接操作状态（例如，Web 浏览器的历史记录），预测该状态的变化（例如，链接映射和表示的预取），并跳转从一个应用程序到另一个应用程序（例如，书签和 URI 条目对话框）。因此，模型应用程序是一个引擎，通过检查和选择当前表示集合中的替代状态转换，从一个状态移动到下一个状态。毫不奇怪，这与超媒体浏览器的用户界面完全匹配。但是，该样式并不假定所有应用程序都是浏览器。事实上，应用程序的详细信息通过通用连接器接口对服务器隐藏，因此用户代理同样可以是为索引服务执行信息检索的自动化机器人，寻找符合特定标准的数据的个人代理，或维护Spider 忙于在信息中查找损坏的引用或修改的内容 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_39">39</a> ]。</p><p>REST 确定的 HTTP 中的关键问题领域包括规划新协议版本的部署、将消息解析与 HTTP 语义和底层传输层 (TCP) 分开、区分权威和非权威响应、细粒度控制缓存，以及无法自我描述的协议的各个方面。REST 还被用于对基于 HTTP 的 Web 应用程序的性能进行建模，并预测诸如持久连接和内容协商等扩展的影响。最后，REST 已被用于将标准化 HTTP 扩展的范围限制在适合架构模型的范围内，而不是允许滥用 HTTP 的应用程序同样影响标准。</p><p>REST 的主要目标之一是支持在已经部署的架构中逐步和分散部署变更。通过引入版本控制要求和规则来扩展协议的每个语法元素，对 HTTP 进行了修改以支持该目标。HTTP 请求语义由请求方法名称表示。只要可以在客户端、服务器和它们之间的任何中介之间共享一组标准化的语义，就允许方法扩展。不幸的是，早期的 HTTP 扩展，特别是 HEAD 方法，使得 HTTP 响应消息的解析依赖于了解请求方法的语义。这导致了部署矛盾：如果接收方需要知道方法的语义才能被中介安全转发，那么在部署新方法之前必须更新所有中介。通过将解析和转发 HTTP 消息的规则与与新 HTTP 协议元素关联的语义分离，此部署问题已得到解决。例如，HEAD 是唯一一种方法，Content-Length 头字段除了表示消息体长度之外，还有其他意义，并且没有新的方法可以改变消息长度的计算。GET 和 HEAD 也是条件请求头字段具有缓存刷新语义的唯一方法，而对于所有其他方法，它们具有前提条件的含义。同样，HTTP 需要一个通用规则来解释新的响应状态代码，以便可以部署新的响应而不会显着损害旧客户端。因此，我们扩展了规则，即每个状态代码都属于由其三位十进制数的第一位表示的类别：100-199 表示消息包含临时信息响应，200-299 表示请求成功，300 -399 表示请求需要重定向到另一个资源， 400-499 表示客户端犯了一个不应重复的错误， 500-599 表示服务器遇到了错误，但客户端可能会得到更好的稍后（或通过其他服务器）响应。如果接收者不理解给定消息中状态代码的特定语义，那么他们必须像对待它的类中的 x00 代码一样对待它。</p><p>REST 将组件之间的消息限制为自描述的，以支持交互的中间处理。由于 REST 试图在对高效、低延迟行为的需求与对语义透明缓存行为的需求之间取得平衡，因此 HTTP 允许应用程序确定缓存要求而不是将其硬编码到协议本身中是至关重要的。协议要做的最重要的事情是完整准确地描述正在传输的数据，这样任何应用程序都不会被愚弄，认为它只有一件事，而实际上它有其他东西。HTTP/1.1 通过添加 Cache-Control、Age、Etag 和 Vary 标头字段来实现这一点。</p><p>所有资源都将请求（由方法、标识符、请求头字段，有时是表示）映射到响应（由状态代码、响应头字段，有时是表示）。</p><p>HTTP 不支持回写缓存。HTTP 缓存不能假设通过它写入的内容与从对该资源的后续请求中可检索的内容相同，因此它无法缓存 PUT 请求正文并将其重用于以后的 GET 响应。这条规则有两个原因：1) 元数据可能在幕后生成，2) 无法从 PUT 请求中确定对以后 GET 请求的访问控制。但是，由于使用 Web 的写入操作极为罕见，因此缺少回写缓存不会对性能产生重大影响。</p><p>Cookie 还违反了 REST，因为它们允许在没有充分识别其语义的情况下传递数据，从而成为安全和隐私方面的问题。cookie 与 Referer [sic] 标头字段的组合可以在用户在站点之间浏览时对其进行跟踪。因此，Web 上基于 cookie 的应用程序永远不会可靠。应该通过匿名身份验证和真正的客户端状态来完成相同的功能。使用上下文设置 URI 而不是 cookie 的明智使用可以更有效地实现涉及偏好的状态机制，其中明智意味着每个状态一个 URI，而不是由于嵌入了用户 ID 的无限数量的 URI。理想的 ReSTful 服务允许客户端（可能不在浏览器中）<em>在一个请求中</em>执行任何需要的任务；因为执行此操作所需的完整状态由客户端保存，而不是由服务器保存。由于客户端完全控制状态，它可以自己创建状态（如果这是合法的），并且只与 API 对话以“完成”。需要 cookie 会使这变得困难。对于浏览器以外的客户端，与查询参数、普通请求头或请求正文相比，管理 cookie 是一个相当大的不便。另一方面，在浏览器中，使用 cookie 可以让很多事情变得更简单。</p><h1 id="Web成熟度模型"><a href="#Web成熟度模型" class="headerlink" title="Web成熟度模型"></a>Web成熟度模型</h1><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img54.png" alt="img54"></p><p>万维网的技术形成了网络服务的技术栈。当人们设计 Web 服务时，他们倾向于从堆栈底部选择一些技术。您可以通过查看他们是选择零、一项、两项还是三项技术来粗略地判断他们。当我说您从堆栈中选择时，我并不是说您会找到根本不使用 HTTP 或没有 URI 的 Web 服务。我的意思是有一类 Web 服务并没有真正获得 URI 或没有真正获得 HTTP。该模型之所以有用，是因为这三种技术是 RESTful 约束的真实实现。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/overview.png" alt="overview"></p><p>我要强调的是，RMM 虽然是思考 REST 元素的好方法，但并不是 REST 本身级别的定义。Roy Fielding 已经明确表示，<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">级别 3 RMM 是 REST 的先决条件</a>。 RMM 的有用之处在于它提供了一个很好的逐步方式来理解rest背后的基本思想。因此，我认为它是帮助我们了解概念的工具，而不是应该在某种评估机制中使用的东西。我认为我们还没有足够的例子来真正确定 restful 方法是集成系统的正确方法，我确实认为这是一种非常有吸引力的方法，并且在大多数情况下我会推荐这种方法。</p><p>该模型的吸引力在于它与常见设计技术的关系。</p><ul><li>级别 1 通过使用分而治之，将大型服务端点分解为多个资源来解决处理复杂性的问题。</li><li>级别 2 引入了一组标准的动词，以便我们以相同的方式处理类似的情况，消除不必要的变化。</li><li>级别 3 引入了可发现性，提供了一种使协议更具自文档性的方法。</li></ul><hr><ul><li><p>0级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img55.png" alt="img55"></p><p>如果您查看 XML-RPC 服务或典型的 SOAP 服务（例如 Google 现已弃用的搜索服务），您会看到一些看起来很像 C 库的东西。有很多函数，有时用句点命名。所有这些功能都可以通过向一个 URI 发送 POST 请求来访问。这些网站很烦人，因为它们实际上并不在网络上。有一个小的基于网络的窥视孔进入其他宇宙，你只能通过窥视孔传递消息来与另一个宇宙交流。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level0.png" alt="level0"></p><p>该模型的出发点是使用 HTTP 作为远程交互的传输系统，但不使用任何网络机制。本质上，您在这里所做的是使用 HTTP 作为您自己的远程交互机制的隧道机制，通常基于<a href="http://www.eaipatterns.com/EncapsulatedSynchronousIntegration.html">Remote Procedure Invocation</a>。</p><p>它只是来回传递普通的旧 XML (POX)。如果您使用 SOAP 或 XML-RPC，它的机制基本相同，唯一的区别是您将 XML 消息包装在某种信封中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>The server then will return a document giving me this information<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">reason</span>&gt;</span>Slot not available<span class="hljs-tag">&lt;/<span class="hljs-name">reason</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>1级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img56.png" alt="img56"></p><p>为每个单独的事物提供了一个 URI。如果我们以一级思维回到 XML-RPC 示例，我们可以说它有什么问题。只有一种资源，这个黑匣子。我们看到了解决方案：将复杂性从黑匣子中取出并制造更多资源。将 Web 服务拆分为其分子组件，并为每个分子提供自己的 URI。</p><p>Web 的强大之处在于它为您提供了将任务的固有复杂性拆分为小块的工具。URI 允许您为系统中的每个对象命名。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level1.png" alt="level1"></p><p>在 RMM 中实现 Glory of Rest 的第一步是引入资源。因此，现在我们不再向单个服务端点发出所有请求，而是开始与单个资源进行对话。</p><p>回复携带相同的基本信息，但现在每个时隙都是可以单独寻址的资源。</p><p>使用特定资源预订约会意味着发布到特定时段。</p><p>对于像我这样的对象人来说，这就像特定对象的概念。我们不是在以太中调用某个函数并传递参数，而是在一个特定对象上调用一个方法，为其他信息提供参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /doctors/mjones HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span>/&gt;</span><br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img58.png" alt="img58"></p><p>在 HTTP 层面，Web 的主要进步在于，虽然它可以处理任何类型的操作，但它将读取操作、想要获取数据的操作分开，并对其进行特殊处理。</p><p>在 80 年代和 90 年代，“get”与 FTP、Gopher、WAIS、Archie 和 Comp-U-Store 的含义截然不同。取消引用 FTP URI 是一个巨大的音乐数字。当所有这些协议都转移到 Web 上，并且所有这些信息都获得了 URI 时，突然间“get”对所有这些协议都意味着同样的事情。URI 的意思是“那个”，HTTP 方法的意思是“给我”。这里是堆栈的 URI 部分与 HTTP 部分相遇的地方。RFC 2616 赋予 GET 特定含义。GET 请求必须是安全的和幂等的，等等。GET 的确切含义并不重要。重要的是 GET 对其含义有限制，当存在限制时，您可以围绕它们进行优化：条件 GET、部分 GET、可靠性、可缓存性等等。这就是统一接口的价值。一级服务不遵守这些限制。</p><p>您发出的每个 XML-RPC 请求都使用 POST。HTTP 标准对 POST 没有任何限制。您可能正在获取数据，您可能正在修改数据，但无法知道。HTTP POST 的意思是“随便！” 您无法对安全或幂等请求应用优化，因为无法知道哪些请求满足这些要求。</p><p>我们使用的 Web 仅使用 GET 和 POST，因为它们是 HTML 4 支持的唯一方法。但大多数 RESTful 更进一步，将 PUT 和 DELETE 从 POST 中分离出来。我想你可能对这场争论很熟悉。关于这些方法的价值存在争论，但这是关于成熟启发式的第二级争论，而不是关于谁更纯粹或更实用的争论。这些方法或任何方法的论据是，如果我们将它们从 POST 中分离出来，它们开始意味着除了“随便！”之外的其他内容。我们可以围绕它们进行优化。</p><p>缺点是，当您添加 HTTP 方法时，您会限制可以理解您的服务语义的客户端的范围</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level2.png" alt="level2"></p><p>我在 0 级和 1 级的所有交互中都使用了 HTTP POST 动词，但有些人使用 GET 代替或另外使用。在这些级别上并没有太大区别，它们都被用作隧道机制，允许您通过 HTTP 隧道进行交互。级别 2 远离此，使用 HTTP 动词尽可能接近它们在 HTTP 本身中的使用方式。</p><p>在第 2 级，对这样的请求使用 GET 是至关重要的。 HTTP 将 GET 定义为安全操作，即它不会对任何事物的状态进行任何重大更改。这使我们能够以任何顺序安全地多次调用 GET，并且每次都获得相同的结果。这样做的一个重要结果是，它允许请求路由中的任何参与者使用缓存，这是使 Web 表现良好的关键因素。HTTP 包括各种支持缓存的措施，可供通信中的所有参与者使用。通过遵循 HTTP 规则，我们能够利用该功能.</p><p>即使我使用与级别 1 相同的帖子，远程服务的响应方式也存在另一个显着差异。如果一切顺利，该服务将回复 201 的响应代码，以表明世界上有新资源。201 响应包含一个带有 URI 的位置属性，客户端可以使用该 URI 获取该资源在未来的当前状态。此处的响应还包括该资源的表示，以立即为客户端节省额外的调用。</p><p>此响应的重要部分是使用 HTTP 响应代码来指示出现问题。在这种情况下，409 似乎是一个不错的选择，表明其他人已经以不兼容的方式更新了资源。与使用 200 的返回码但包括错误响应不同，在级别 2 中，我们明确地使用了某种类似这样的错误响应。由协议设计者决定使用什么代码，但如果出现错误，应该有一个非 2xx 响应。级别 2 介绍使用 HTTP 动词和 HTTP 响应代码。</p><p>这里有一种矛盾。REST 倡导者谈论使用所有 HTTP 动词。他们还通过说 REST 试图从网络的实际成功中学习来证明他们的方法是合理的。但是万维网在实践中并没有太多地使用 PUT 或 DELETE。网络实践所支持的关键元素是安全（例如 GET）和非安全操作之间的强分离，以及使用状态代码来帮助传达您遇到的错误类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 409 Conflict<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>3级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img66.png" alt="img66"></p><p>如果您嵌入实际的 URI，您的客户可以更容易地从一种资源移动到另一种资源。撇开那些不仅可以使用它们的 URI 很烦人的事实，这种设计在客户端和这个特定的 Web 服务之间创建了耦合。您必须编写无法重用的自定义客户端代码。客户端行为由 Web 服务当前提供的文档编程，而不是由过去决定的内容编程。资源之间的连接是一种数据形式，它们应该与其余数据一起在文档中进行描述。让您的客户专注于查看该文档并决定下一步做什么。不是内化关于您将数据放在网络上的位置的特定规则。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level3.png" alt="level3"></p><p>每个时间片都有一个链接元素，其中包含一个 URI 来告诉我们如何预约。超媒体控制的重点在于它们告诉我们下一步可以做什么，以及我们需要操纵的资源的 URI 来完成它。我们不必知道在哪里发布我们的预约请求，响应中的超媒体控件告诉我们如何去做。</p><p>超媒体控制的一个明显好处是它允许服务器在不破坏客户端的情况下更改其 URI 方案。只要客户端查找“addTest”链接 URI，服务器团队就可以处理除初始入口点之外的所有 URI。</p><p>另一个好处是它可以帮助客户端开发人员探索协议。这些链接为客户开发人员提供了下一步可能的提示。它没有提供所有信息：“self”和“cancel”控件都指向同一个 URI——它们需要确定一个是 GET，另一个是 DELETE。但至少它为他们提供了一个起点，让他们了解更多信息并在协议文档中寻找类似的 URI。</p><p>同样，它允许服务器团队通过在响应中放置新链接来宣传新功能。如果客户端开发人员密切关注未知链接，这些链接可能会触发进一步探索。</p><p>关于如何表示超媒体控件没有绝对的标准。遵循 ATOM ( <a href="https://tools.ietf.org/html/rfc4287">RFC 4287</a> )指出，众所周知<a href="http://www.iana.org/assignments/link-relations.html">的链接关系</a>的定义是<a href="http://www.iana.org/assignments/link-relations.html">链接关系注册表</a>。这些仅限于 ATOM 所做的事情，它通常被视为 3 级的领导者。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br>But the response has a new element<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/5678&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: http://royalhope.nhs.uk/slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/addTest&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment/tests&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;self&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/changeTime&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/doctors/mjones/slots?date=20100104&amp;status=open&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/updateContactInfo&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/patients/jsmith/contactInfo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/help&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/help/appointment&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Thomas Fielding.Architectural Styles and the Design of Network-based Software Architectures.2000</a></p><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Wiki:Representational state transfer</a></p><p><a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html">Leonard Richardson.Justice Will Take Us Millions Of Intricate Moves.2008</a></p><p><a href="https://martinfowler.com/articles/richardsonMaturityModel.html#level0">Martin Fowler.Richardson Maturity Model.2010</a></p><p><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md">Microsoft REST API Guidelines</a></p><p><a href="https://cloud.google.com/apis/design">Google Cloud API 设计指南</a></p><p><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">Ed Price - MSFT.RESTful web API design.2018</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc5789">RFC5789</a></p><p><a href="https://zh.wikipedia.org/wiki/XML-RPC">Wiki:XML-RPC</a></p><p><a href="http://xmlrpc.com/">XML-RPC Home</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">Wiki:SOAP</a></p><p><a href="https://web.archive.org/web/20080915090248/http://webservices.xml.com/pub/a/ws/2001/04/04/soap.html">A Brief History of SOAP</a></p><p><a href="https://www.w3.org/TR/soap/">W3C:SOAP</a></p>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
