<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DDD-003-单元测试</title>
    <link href="/2021/09/16/DDD-003-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/09/16/DDD-003-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>TODO:</p><h2 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h2><p>​    在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p><p>​    程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><p>为什么要写单元测试？</p><p>​    \1. 单元测试可以有效的提高代码的质量，降低线上问题出现的概率。我有若干次在上线前通过单元测试的回归发现现有的改动对之前逻辑产生了影响，出现了bug。</p><p>​    \2. 单元测试可以通过 CI/CD 流水线自动执行，非常方便，在提交到master分支触发单元测试是一个不错的选择。</p><p>​    \3. 如果需要对一块逻辑进行调整，全部成功的单元测试可以让你的安全感大大提升，不用提心吊胆，默默祈祷了。</p><p>​    4 单元测试全部通过，看到一排Tests passed非常有成就感，工作满意度提升。</p><p>​    \5. 单元测试是一个程序员能力的体现，一个优秀的程序员单元测试水平应该是很高的。</p><h2 id="怎样写单元测试？"><a href="#怎样写单元测试？" class="headerlink" title="怎样写单元测试？"></a>怎样写单元测试？</h2><ol><li><p>mockito+powermock+spring-boot-test是个人认为的最佳组合，其中spring-boot-test是为了自动依赖注入，mockito是为了mock对象，powermock可以处理静态方法。</p><p>\2. 针对service层写单元测试，不建议针对storage层写单元测试，个人认为storage层的业务逻辑通常会比较简单，集成测试通过即可。</p><p>\3. 各个单元测试之间是相互独立的。</p><p>\4. 每个单元测试粒度要尽可能小，尽可能做到”单元“。</p><p>\5. 每个单元测试执行时间要尽可能短，所以不建议加载整个spring context，而是按需加载。如果我要测试A类，那么只加载A类以及A类的依赖即可。</p><p>\6. 单元测试要做到和环境无关，因此针对一些数据库操作，rpc调用等都需要mock掉。</p><p>\7. 不要为了单测而单测，每个单元测试应该是有意义的，不要为了代码覆盖率写一些无意义的单元测试。</p><p>\8. 每个单元测试都有保证质量，要有期望值，比如输出多少，报什么错，执行次数等等。</p><p>\9. 单元测试的维护也是需要成本的，尽量通俗易懂，宁缺毋滥。</p><p>\10. 单元测试中的数据构造是一个比较繁琐的过程，可以将数据构造定义为factory，便于以后的复用。</p></li></ol><h2 id="demo示例"><a href="#demo示例" class="headerlink" title="demo示例"></a>demo示例</h2><p>测试的类为MatchBySkillScoreFilter，测试的方法为execute()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以需要测试的类作为启动器</span><br><span class="hljs-meta">@ContextConfiguration(classes = MatchBySkillScoreFilter.class)</span><br><span class="hljs-comment">// 测试运行于Spring测试环境</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchBySkillScoreFilterTest</span> </span>&#123;<br><br>    <span class="hljs-comment">// 需要执行单元测试的类</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MatchBySkillScoreFilter matchBySkillScoreFilter;<br><br>    <span class="hljs-comment">// 使用@MockBean来mock代理类</span><br>    <span class="hljs-meta">@MockBean</span><br>    <span class="hljs-keyword">private</span> KidOtProxy kidOtProxy;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回优秀良好的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义stub</span><br>        Mockito.when(kidOtProxy.getTeacherTeachingScoreByOtIds(Matchers.any()))<br>                .thenReturn(TeacherRecommendFactory.buildTTeacherTeachingSKillScoreList());<br>        <span class="hljs-comment">// 定义测试输入内容</span><br>        TeacherRecommendContext teacherRecommendContext = TeacherRecommendFactory.buildTeacherRecommendContext();<br>        <span class="hljs-comment">// 执行service层逻辑</span><br>        List&lt;Long&gt; teacherIds = matchBySkillScoreFilter.execute(teacherRecommendContext, TeacherRecommendFactory.buildTeacherIdList()).getTeacherIdList();<br>        <span class="hljs-comment">// 验证输出结果与预期的是否一致</span><br>        Assert.assertEquals(<span class="hljs-number">2L</span>, (<span class="hljs-keyword">long</span>) teacherIds.get(<span class="hljs-number">0</span>));<br>        Assert.assertEquals(<span class="hljs-number">2</span>, teacherIds.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单元测试量化指标"><a href="#单元测试量化指标" class="headerlink" title="单元测试量化指标"></a>单元测试量化指标</h2><ol><li>覆盖率，即测试代码/全部代码，可以通过idea run with coverage查看，更专业的是使用jacoco，有两者的统计方式不完全相同，得出的覆盖率也有所差异。</li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li>直接使用mockito的@InjectMocks，@Mock和@Spy执行速度更快，为什么不使用？</li></ol><p>​     mockito原生的注解对依赖的支持不够友好，尤其是在依赖关系比较复杂的情况下。而spring作为依赖注入的专家，写起来还是很舒服的。</p><p>   \2. 为什么不使用@SpringBootTest(classes = MatchBySkillScoreFilter.class)而使用@ContextConfiguration?</p><p>​     “天下武功，唯快不破”，单元测试强调一个“快”字，@SpringBootTest注解功能强大，单元测试用不到，代价是在启动时加载内容会多一些，速度也会相应慢不少。</p><p>​     上面的例子，@SpringBootTest加载的bean有25个，applicationListeners为16个</p><p>​     <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_10-14-30.png?version=1&modificationDate=1621908871000&api=v2" alt="img"></p><p>​    <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_12-1-36.png?version=1&modificationDate=1621915297000&api=v2" alt="img"></p><p>​    @ContextConfiguration加载的bean只有20个,applicationListeners为0个</p><p>   <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_10-19-29.png?version=1&modificationDate=1621909170000&api=v2" alt="img"></p><p>  <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_11-58-48.png?version=1&modificationDate=1621915129000&api=v2" alt="img"></p><p>​    \3. 还有哪些单元测试例子可以参考？</p><p>​     试听课重构项目conan-zis-trial-class中写了若干单元测试，项目的单测覆盖率超过30%，可以参考，如果有疑问欢迎一起学习讨论。</p><p><img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-8-3_14-5-1.png?version=1&modificationDate=1627970706000&api=v2" alt="img"></p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol><li><a href="https://blog.csdn.net/weixin_33682719/article/details/93835689">阿里巴巴编码规范-单元测试</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">维基百科-单元测试</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Domain Driven Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-003-REST</title>
    <link href="/2021/09/08/SAC-003-REST/"/>
    <url>/2021/09/08/SAC-003-REST/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>架构级别的所有设计决策都应该在所设计系统的功能、行为和社会需求的背景下做出，这是一个同样适用于软件架构和传统建筑架构领域的原则。“形式追随功能”的准则来自数百年失败的构建项目的经验，但经常被软件从业者忽视。</p><p>改变应用程序的交互方式对性能的影响比所使用的通信协议更大。</p><p>一般而言，基于网络的体系结构和软件体系结构之间的主要区别在于，如果可以在运行时基于组件的位置选择更有效的机制，则组件之间的通信仅限于消息传递或等效于消息传递。</p><p>分布式系统在用户看来就像一个普通的集中式系统，但运行在多个独立的 CPU 上。相比之下，基于网络的系统是那些能够跨网络运行的系统，但不一定以对用户透明的方式运行。在某些情况下，用户需要了解需要网络请求的操作与可在其本地系统上满足的操作之间的区别，特别是当网络使用意味着额外的交易成本时 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。</p><p>应用程序软件架构是整个系统的抽象级别，其中用户操作的目标可表示为功能架构属性。</p><p>这与网络抽象形成对比，网络抽象的目标是将位从一个位置移动到另一个位置，而不考虑为什么移动这些位。只有在应用程序级别，我们才能根据每个用户操作的交互次数、应用程序状态的位置、所有数据流的有效吞吐量（相对于单个数据流的潜在吞吐量）来评估设计权衡)、每个用户操作执行的通信范围等。</p><p>基于网络的应用程序的性能首先受应用程序需求的约束，然后是选择的交互方式，其次是实现的架构，最后是每个组件的实现。</p><p>关于基于网络的应用程序的一个有趣观察是，最好的应用程序性能是通过不使用网络来获得的。这实质上意味着基于网络的应用程序最有效的架构风格是那些在可能的情况下可以有效地最大限度地减少网络使用的风格，通过重用先前的交互（缓存），减少网络交互的频率与用户操作（复制数据和断开连接的操作）相关，或者通过将数据处理移动到更靠近数据源（移动代码）来消除某些交互的需要。</p><p>可修改性是指对应用程序架构进行更改的难易程度。可修改性可以进一步分解为可进化性、可扩展性、可定制性、可配置性和可重用性，如下所述。基于网络的系统的一个特别关注点是动态可修改性，其中对已部署的应用程序进行修改而无需停止和重新启动整个系统。</p><p>即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。由于参与基于网络的应用程序的组件可能分布在多个组织边界，因此系统必须为渐进的、碎片化的变化做好准备，在这种变化中，新旧实现并存，同时又不妨碍新实现利用其扩展功能。</p><p>构建软件的目的不是创建特定的交互拓扑或使用特定的组件类型——而是创建一个满足或超过应用程序需求的系统。为系统设计选择的架构风格必须符合这些需求，而不是相反。因此，为了提供有用的设计指导，架构风格的分类应该基于这些风格所引发的架构特性。</p><p>Berners-Lee [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_20">20</a> ] 写道，“Web 的主要目标是成为一个共享的信息空间，通过它人和机器可以进行通信。” 人们需要一种方法来存储和构建他们自己的信息，无论是永久的还是短暂的，以便他们自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护本地副本。</p><p>该系统的预期最终用户位于世界各地，通过互联网连接的各个大学和政府高能物理研究实验室。他们的机器是终端、工作站、服务器和超级计算机的异构集合，需要操作系统软件和文件格式的大杂烩。信息范围从个人研究笔记到组织电话列表。面临的挑战是构建一个系统，该系统将为这种结构化信息提供普遍一致的接口，可在尽可能多的平台上使用，并且随着新人员和组织加入项目而逐步部署。</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此体系结构需要最大限度地减少网络交互（数据传输协议内的往返）。</p><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p><p>假设 I：WWW 体系结构背后的设计原理可以用一种体系结构风格来描述，该体系结构风格由应用于 Web 体系结构中元素的一组约束组成。</p><p>假设二：可以在 WWW 架构风格中添加约束，以推导出一种新的混合风格，更好地反映现代 Web 架构所需的属性。</p><p>假设 III：可以将修改 Web 架构的建议与更新的 WWW 架构风格进行比较，并在部署之前分析冲突。</p><h1 id="XML-RPC"><a href="#XML-RPC" class="headerlink" title="XML-RPC"></a>XML-RPC</h1><p><strong>XML-RPC</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a>（Remote Procedure Call，RPC）的<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算</a><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2%E5%8D%94%E8%AD%B0">协议</a>，通过<a href="https://zh.wikipedia.org/wiki/XML">XML</a>将调用函数封装，并使用<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>协议作为发送机制。</p><p>XML-RPC 消息是一个 HTTP-POST 请求。请求的正文采用 XML 格式。一个过程在服务器上执行，它返回的值也采用 XML 格式。</p><p>过程参数可以是标量、数字、字符串、日期等；也可以是复杂的记录和列表结构。</p><p>下面是一个 XML-RPC 请求的例子：</p><p>必须指定用户代理和主机。</p><p>内容类型是 text/xml。</p><p>必须指定 Content-Length 并且必须正确。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">POST /RPC2 HTTP/1.0<br>User-Agent: Frontier/5.1.2 (WinNT)<br>Host: betty.userland.com<br>Content-Type: text/xml<br>Content-length: 181<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodCall</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">methodName</span>&gt;</span>examples.getStateName<span class="hljs-tag">&lt;/<span class="hljs-name">methodName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i4</span>&gt;</span>41<span class="hljs-tag">&lt;/<span class="hljs-name">i4</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodCall</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是对 XML-RPC 请求的响应示例：</p><p>除非出现低级错误，否则总是返回 200 OK。</p><p>内容类型是 text/xml。Content-Length 必须存在且正确。</p><p>响应的主体是单个 XML 结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 158<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:08 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>South Dakota<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>故障示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 426<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:02 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">fault</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">struct</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultCode<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">int</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">int</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultString<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Too many parameters.<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">struct</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">fault</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>XML-RPC发表于1998年，由<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>（<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>）的<a href="https://zh.wikipedia.org/w/index.php?title=Dave_Winer&action=edit&redlink=1">Dave Winer</a>及<a href="https://zh.wikipedia.org/wiki/Microsoft">Microsoft</a>共同发表[<a href="https://zh.wikipedia.org/wiki/XML-RPC#cite_note-2">2]</a>。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的<a href="https://zh.wikipedia.org/wiki/SOAP">SOAP</a>协议。</p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>SOAP 的最初意图相当温和：编写如何发送 <em>瞬态</em>XML 文档以触发远程主机上的操作或响应的方法。OAP 1.2 版提供了基于 XML 的信息的定义，该信息可用于在分散的分布式环境中的对等点之间交换结构化和类型化信息。</p><p><strong>SOAP</strong>（原为<strong>Simple Object Access Protocol</strong>的<a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E5%86%99">首字母缩写</a>，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，使用在计算机网络<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1">Web服务</a>（web service）中，交换带结构的信息。SOAP为了简化网页服务器（Web Server）从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>通信协议，遵从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><p>目前SOAP 1.1版是业界共同的标准，属于第二代的XML协议（第一代具主要代表性的技术为XML-RPC以及WDDX）</p><p>用一个简单的例子来说明SOAP使用过程，一个SOAP消息可以发送到一个具有Web Service功能的Web站点，例如，一个含有房价信息的数据库，消息的参数中标明这是一个查询消息，此站点将返回一个XML格式的信息，其中包含了查询结果（价格，位置，特点，或者其他信息）。由于数据是用一种标准化的可分析的结构来传递的，所以可以直接被第三方站点所利用。</p><ul><li>SOAP封装（envelope）：定义了一个框架，描述消息中的内容是什么、是谁发送的、谁应当接受并处理它以及如何处理它们；</li><li>SOAP编码规则（encoding rules）：定义了一种<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的机制，用于表示应用程序需要使用的数据类型的实例；</li><li>SOAP RPC表示（RPC representation）：定义了一个协定，用于表示远程过程调用和应答；</li><li>SOAP绑定（binding），它定义了SOAP使用哪种协议交换信息。使用<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>/<a href="https://zh.wikipedia.org/wiki/TCP">TCP</a>/<a href="https://zh.wikipedia.org/wiki/UDP">UDP</a>协议都可以。</li></ul><p>把SOAP绑定到HTTP的方式，同时利用了SOAP的样式和分散的灵活性特点以及HTTP的丰富特征库的优点。在HTTP上传送SOAP并不意味着SOAP会覆盖现有的HTTP语义，而是HTTP上的SOAP语义会自然地映射到HTTP语义。在使用HTTP作为协议绑定的场合中，RPC请求映射到HTTP请求上，而RPC应答映射到HTTP应答。然而，在RPC上使用SOAP并不仅限于HTTP协议绑定。</p><p>SOAP使用因特网应用层协议作为其传输协议。<a href="https://zh.wikipedia.org/wiki/SMTP">SMTP</a>以及<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>协议都可以用来传输SOAP消息，但是由于HTTP在如今的因特网结构中工作得很好，特别是在网络防火墙下仍然正常工作，所以被广泛采纳。SOAP亦可以在<a href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>上传输。</p><p>SOAP的消息格式采用<a href="https://zh.wikipedia.org/wiki/XML">XML</a>。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>定义了 SOAP 信封，它是一种结构，它定义了一个整体框架，用于表示 SOAP 消息的内容，确定谁应该处理全部或部分消息，以及处理这些部分是可选的还是强制性的。它还定义了一个协议绑定框架，它描述了如何编写将 SOAP 绑定到另一个底层协议的规范。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a>定义了<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP</a>的数据模型，一种特定的数据类型编码方案，可用于传送远程过程调用 (RPC)，以及[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1] 中</a>定义的底层协议绑定框架的一个具体实现。此绑定允许将 SOAP 消息作为 HTTP POST 请求和响应的有效负载进行交换，或者作为对 HTTP GET 的响应中的 SOAP 消息进行交换。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>描述了一个抽象特性，用于优化特定类型内容的 SOAP 消息的有线格式，以及它在 HTTP 绑定中实现的具体实现，同时仍将 SOAP 消息建模为单个 XML 信息集.</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP]</a>定义了一种更有效地序列化具有二进制内容的 XML 信息集的约定。 [<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>利用 [ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP</a> ] 格式来优化 SOAP 消息的传输。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L4299">ResRep]</a>指定了一个 SOAP 头块，它携带 Web 资源的表示，这是处理 SOAP 消息所需要的，但接收者不愿意或不能通过取消引用消息中携带的资源的 URI 来获得。</p><p>SOAP 从根本上是一种无状态的单向消息交换范例，但应用程序可以通过将此类单向交换与底层协议提供的功能相结合来创建更复杂的交互模式（例如，请求/响应、请求/多响应等）和/或特定于应用程序的信息。SOAP 对它所传达的任何特定于应用程序的数据的语义保持沉默，因为它涉及诸如 SOAP 消息的路由、可靠的数据传输、防火墙穿越等问题。但是，SOAP 提供了一个框架，通过该框架，特定于应用程序的信息可以以可扩展的方式传达。此外，SOAP 提供了 SOAP 节点在接收 SOAP 消息时采取的所需操作的完整描述。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/primer-figure-1.png" alt="primer-figure-1"></p><p>SOAP标头元素是可选的，但它已被包括在示例来解释SOAP的某些特征。SOAP 标头是一种扩展机制，它提供了一种在 SOAP 消息中传递不是应用程序有效负载的信息的方法。这种“控制”信息包括例如与消息处理相关的传递指令或上下文信息。这允许以特定于应用程序的方式扩展 SOAP 消息。该元素的直接子元素<code>env:Header</code>称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#encapsulation"> 标头块</a>，代表数据的逻辑分组，如下所示，可以单独针对 SOAP 节点，这些节点在从发送方到最终接收方的消息路径中可能会遇到。SOAP 标头的设计考虑到 SOAP 的各种用途，其中许多将涉及其他 SOAP 处理节点（称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts"> SOAP 中介）</a>的参与，沿着从<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">初始 SOAP 发送方</a>到<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">最终 SOAP 接收</a><a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">方</a>的消息路径。这允许 SOAP 中介提供增值服务。标题，如后所示，可以被沿<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">SOAP 消息路径</a>遇到的 SOAP 节点检查、插入、删除或转发. （不过，应该记住，SOAP 规范不处理头元素的内容，或者 SOAP 消息如何在节点之间路由，或者确定路由的方式等等。这些是整个应用程序的一部分，并且可能是其他规范的主题。）</p><p>SOAP Version 1.2 是一个简单的消息传递框架，用于在初始 SOAP 发送方和最终 SOAP 接收方之间传输以 XML 信息集形式指定的信息。更有趣的场景通常涉及这两个节点之间的多个消息交换。最简单的这种交换是请求-响应模式。[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R11">SOAP 1.1</a> ] 的一些早期使用强调使用这种模式作为传送远程过程调用 (RPC) 的手段，但重要的是要注意并非所有 SOAP 请求-响应交换都可以或需要建模为 RPC。当需要对某个程序行为建模时使用后者，交换的消息符合远程调用及其返回的预定义描述。比请求-响应模式所涵盖的更多的使用场景集可以简单地建模为在 SOAP 消息中交换的基于 XML 的内容以形成来回“对话”，其中语义处于发送和接收应用程序。</p><p>SOAP 1.2 版的设计目标之一是使用 XML 的可扩展性和灵活性封装远程过程调用功能。尽管用于 RPC 的 SOAP 的大多数示例都使用 HTTP 协议绑定，但它并不仅限于这种方式。要调用 SOAP RPC，需要以下信息：</p><ol><li>目标 SOAP 节点的地址。</li><li>过程或方法名称。</li><li>要传递给过程或方法的任何参数的标识和值以及任何输出参数和返回值。</li><li>用于识别作为 RPC 实际目标的 Web 资源的参数的明确分离，与传送用于处理目标资源调用的数据或控制信息的参数形成对比。</li><li>将用于传达 RPC 的消息交换模式，以及要使用的所谓“Web 方法”（稍后将详细介绍）的标识。</li><li>可选地，可以作为 SOAP 头块的一部分携带的数据。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:reference</span>&gt;</span>uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:20:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">m:reservation</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itinerary</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-14<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>late afternoon<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>&gt;</span>aisle<span class="hljs-tag">&lt;/<span class="hljs-name">p:seatPreference</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-20<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>mid-morning<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itinerary</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">q:lodging</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:q</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/hotels&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">q:preference</span>&gt;</span>none<span class="hljs-tag">&lt;/<span class="hljs-name">q:preference</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">q:lodging</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span> =<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   &lt; m:reference&gt;uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:35:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span> <br>  &lt;/m:reservation &gt; <br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env</span> <span class="hljs-attr">:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itineraryClarification</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span> &gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>          JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span> <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span> <br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>         JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>     &lt;/p:arriving &gt; <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itineraryClarification</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">xmlns:rpc</span>=<span class="hljs-string">&#x27;http://www.w3.org/2003/05/soap-rpc&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">env:Fault</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Code</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>env:Sender<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Subcode</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>rpc:BadArguments<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">env:Subcode</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Code</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Reason</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span>Processing error<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;cs&quot;</span>&gt;</span>Chyba zpracování<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Reason</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Detail</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">e:myFaultDetails</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:e</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/faults&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:message</span>&gt;</span>Name does not match card number<span class="hljs-tag">&lt;/<span class="hljs-name">e:message</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:errorcode</span>&gt;</span>999<span class="hljs-tag">&lt;/<span class="hljs-name">e:errorcode</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">e:myFaultDetails</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Detail</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">env:Fault</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>头块和正文的进一步处理取决于SOAP 节点为处理给定消息所承担的<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts"> 角色</a>。SOAP 定义了（可选）<code>env:role</code>属性 - 在语法上， <code>xs:anyURI</code>- 可能出现在头块中，它标识该头块的预期目标所扮演的角色。如果 SOAP 节点承担由 URI 的值标识的角色，则它需要处理头块。</p><p>为了确保 SOAP 节点不会忽略对应用程序的总体目的很重要的头块，SOAP 头块还提供了附加的可选属性<code>env:mustUnderstand</code>，如果为“true”，则意味着目标 SOAP 节点<em>必须</em>根据该块的规范处理该块。</p><p>为了规避处理模型的默认规则，使用附加属性标记标题块<code>env:relay</code> 值为“true”时允许中介在它选择不处理它的情况下转发针对它自己的标头块。</p><p>SOAP 消息可以使用各种“底层”协议进行交换，包括其他应用层协议。SOAP 消息如何使用底层协议从一个 SOAP 节点传递到另一个节点的规范称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts">SOAP 绑定</a>。[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>以[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R12">XML Infoset</a> ]的形式定义了一个SOAP 消息，即，根据称为the <code>env:Envelope</code>（参见<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#soapenv">SOAP Part 1，第5 节</a>）的抽象“文档”的元素和属性信息项 。但是，SOAP 消息可能会在发送方和最终接收方之间经过几跳，其中每一跳可能是不同的协议绑定。换言之，在一个跳跃中由协议绑定支持的特征（例如，消息相关性、可靠性等）可能不被沿消息路径的另一个支持。SOAP 本身并没有提供任何机制来隐藏不同底层协议提供的特性差异。但是，特定应用程序需要的任何端到端或多跳特性，但在<em>预期</em>消息路径上的底层基础设施中可能不可用，可以通过作为 SOAP 的一部分携带来补偿消息信息集，即作为某个模块中指定的 SOAP 头块。应用程序设计者必须解决许多问题才能完成特定的应用程序语义，包括如何利用可用于所选环境的底层协议的本机特性</p><p>功能描述由 URI 标识，因此所有引用它的应用程序都确保具有相同的语义。特征由<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#bindprops">属性</a>限定，提供有助于实现该功能的附加信息。当 RPC 定义使得其方法描述的所有部分都可以描述为资源标识时，RPC 的整个目标可以由 URI 标识。如果应用程序需要使用只能在 SOAP 信息集中具有特定于绑定的表达式的功能，即使用 SOAP 标头块，则应用程序必须选择 HTTP POST 方法，并在请求正文中包含 SOAP 消息.如果 RPC 描述包含非资源识别的数据（参数），它还需要使用通过 HTTP POST 实现的<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>。即使在这种情况下，带有 SOAP 消息的 HTTP POST 也可以以 Web 友好的方式表示。与 GET 的使用一样，[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a> 建议在一般情况下，在 HTTP 请求 URI 中标识用于标识请求被 POST 到的资源的 SOAP 消息的任何部分。当然，相同的参数可以保留在 SOAP<code>env:Body</code>元素中。（在基于 SOAP 的 RPC 的情况下，参数必须保留在主体中，因为这些参数与接收应用程序期望的过程/方法描述相关。）</p><p>SOAP 规范中的建议是以 Web 架构兼容的方式使用 URI - 即作为资源标识符 - 无论使用的是 GET 还是 POST。</p><p>HTTP 具有众所周知的连接模型和消息交换模式。客户端通过 URI 识别服务器，使用底层 TCP/IP 网络连接到它，发出 HTTP 请求消息并通过相同的 TCP 连接接收 HTTP 响应消息。HTTP 隐式地将其请求消息与其响应消息相关联；因此，使用此绑定的应用程序可以选择推断 HTTP 请求消息正文中发送的 SOAP 消息与 HTTP 响应中返回的 SOAP 消息之间的相关性。类似地，HTTP 通过 URI 标识服务器端点，即<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2">Request-URI</a>，它也可以用作服务器上 SOAP 节点的标识。HTTP 允许在初始客户端和由 Request-URI 标识的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html#sec1.3">源服务器</a>之间存在多个中介 ，在这种情况下，请求/响应模型是一系列这样的对。但是请注意，HTTP 中介与 SOAP 中介不同。SOAP Part2中的 HTTP 绑定利用<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#WebMethodFeature">SOAP Web 方法特性</a>来允许应用程序选择所谓的 Web 方法——将其限制为 GET 或 POST 之一——以通过 HTTP 消息交换使用。此外，它还利用了两种消息交换模式，为应用程序提供了两种通过 HTTP 交换 SOAP 消息的方式：1) 使用 HTTP POST 方法在 HTTP 请求和响应消息的正文中传送 SOAP 消息，以及 2)在 HTTP 请求中使用 HTTP GET 方法在 HTTP 响应的正文中返回 SOAP 消息。第一种使用模式是称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>的绑定特性的 HTTP 特定实例，而第二种使用称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#soapresmep">SOAP 响应消息交换模式</a>。由于 HTTP SOAP GET 用法不允许请求中包含 SOAP 消息，因此在出站交互中需要功能的应用程序显然不能由 SOAP 信息集中的绑定特定表达式（即，作为 SOAP 标头块）支持利用这种消息交换模式。请注意，HTTP POST 绑定可用于所有情况。SOAP 使用 HTTP 传输，遵循 HTTP 状态代码的语义以在 HTTP 中传递状态信息。</p><p>万维网最核心的概念之一是作为资源标识符的 URI。使用 HTTP 绑定并希望与其他 Web 软件互操作的 SOAP 服务应该使用 URI 来寻址其服务中的所有重要资源。例如，万维网的一个非常重要（实际上占主导地位）的用途是纯信息检索，其中由 URI 标识的可用资源的表示是使用 HTTP GET 请求获取的，而不会以任何方式影响资源。（这在 HTTP 术语中称为<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1">安全且幂等的方法</a>。）关键点是资源的发布者提供其 URI，消费者可以“获取”该 URI。在许多情况下，SOAP 消息被设计用于纯粹用于信息检索的用途，例如请求某些资源（或对象，在编程术语中）的状态，而不是执行资源操作的用途。在这种情况下，使用 SOAP 主体来携带状态请求，主体的一个元素代表所讨论的对象，被视为与 Web 精神背道而驰，因为资源不是由请求标识的—— HTTP GET 的 URI。（在一些 SOAP/RPC 实现中，HTTP 请求 URI 通常不是资源本身的标识符，而是一些必须评估 SOAP 消息以识别资源的中间实体。）</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>为了方便后续讨论 REST 和 RESTful Api，我们先说 HTTP 协议的资源、请求方法与响应码的定义。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>HTTP 请求的目标称为<strong>资源</strong>。 每个资源都由统一资源标识符 URI 标识。人们很容易将 URI 视为远程文件系统路径名，并将该资源的表示视为此类文件的副本。但即使将 URI 映射机制绑定到文件系统，服务端也可能被配置为以请求作为输入执行文件，并将输出作为表示进行响应，而不是直接传输文件。无论如何，只有服务端需要知道它的每个 URI 如何对应于一个实现，以及每个实现如何管理、如何发送目标资源的当前表示以响应 GET 方法等工作。</p><p>HTTP 不限制资源的性质，资源可以是任何东西，例如一份文档，亦或是数据库中存储的数据，等等。HTTP 只是定义了一个与资源交互的统一接口。统一接口类似于一个窗口，只有通过向另一侧的某个独立参与者传递消息才能观察和处理资源。HTTP 没有定义资源是如何存储的，也没有定义这种存储如何响应资源状态变化，也没有定义服务端如何将资源转换为表示。</p><p>就 HTTP 而言，资源的表示（以下统称为<strong>表示</strong>）是旨在反映给定资源过去、当前或期望状态的信息（举例，若将订单视为一种资源，那么查询订单就是希望获取订单资源过去或者当前的信息，创建订单就是在传输订单的期望信息）。表示由元数据和数据流组成，可以轻松地通过 HTTP 进行传输。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>HTTP 的一个设计目标是将资源标识与请求方法分离，这是通过在请求方法和一些请求头字段中赋予语义来实现的：请求方法被设想为将语义应用于目标资源，这很类似于在已识别的对象上调用其定义好的方法，从而将方法语义应用到该对象上的方式。 如果请求方法语义与 URI 本身隐含的任何语义之间存在冲突，则请求方法语义优先。</p><p>与对象方法不同，HTTP 中的标准化请求方法不是特定于某类资源的。尽管每个资源自己确定这些语义是否被允许以及如何实现，但是应该确保标准化方法在应用于任何资源时具有相同的语义。统一的标准化方法在基于网络的系统中提供了更好的可见性和重用性。</p><p>下面根据请求方法的语义对方法进行分类：</p><ul><li><p>安全方法</p><p>如果请求方法所定义的语义本质上是只读的，则该请求方法被认为是安全的。客户端不会请求，也不期望将安全方法应用于目标资源，从而导致服务端上该资源的任何状态变更。同样，合理使用安全方法不会对服务端造成任何伤害、财产损失或异常负担。</p><p>安全方法的定义不会阻止服务端上的方法实现包含潜在有害的行为、并非完全只读的行为或调用时会导致副作用的行为。然而，重要的是客户端没有要求额外的行为，也不会为此负责。例如，大多数服务端在响应完成时会记录访问日志，无论使用何种方法，即使日志存储可能已满并导致服务端崩溃，该方法也被认为是安全的。同样，查看广告而发起的安全请求通常会产生向广告帐户收费的副作用，这也是安全的。</p><p>区分安全和不安全方法的目的是为了支持爬虫和缓存。此外，它允许用户代理在处理潜在不可信内容时对不安全方法应用适当的约束。</p></li><li><p>幂等方法</p><p>如果使用该请求方法的多个相同请求与使用单个此类请求对服务器的预期效果相同，则该请求方法被认为是幂等的。</p><p>与安全方法的定义一样，幂等性仅适用于客户端，服务端可以记录每次历史访问，或为每个幂等请求实现其他非幂等副作用。</p><p>客户端可以自动重复发送幂等请求。例如，如果客户端发送 PUT 请求，并且在收到任何响应之前网络底层连接已关闭，则客户端可以建立新连接并重试该幂等请求。</p></li><li><p>可缓存方法</p><p>请求方法若被定义为可缓存的，则表示允许中介存储对它们的响应以备将来重用。 通常，不依赖于当前或权威响应的安全方法被定义为可缓存的方法。</p><p>但即使规范定义为可缓存方法，但类似于 GET 方法，可以通过在请求头中设置 Cache-Control 字段，更改可缓存特性。</p></li></ul><table><thead><tr><th>方法名</th><th>介绍</th><th>是否安全</th><th>是否幂等</th><th>是否可缓存</th><th>是否有请求体</th></tr></thead><tbody><tr><td>GET</td><td>获取目标资源的当前选定表示</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>HEAD</td><td>与 GET 请求相同，但是只传输状态码和响应头</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>POST</td><td>请求目标资源根据资源自身的特定语义处理请求中包含的表示</td><td>否</td><td>否</td><td>否（规范上定义为可缓存，但大多数实现为不可缓存）</td><td>是</td></tr><tr><td>PUT</td><td>使用请求体中包含的表示替换目标资源当前所有表示，即请求目标资源的状态被<strong>创建</strong>或<strong>替换</strong>为由包含在请求消息有效负载中的表示所定义的状态</td><td>否</td><td>是</td><td>否</td><td>是</td></tr><tr><td>PATCH</td><td>请求创建新资源或对现有资源应用部分修改</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>DELETE</td><td>请求删除目标资源当前所有表示</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>CONNECT</td><td>建立到（被目标资源标识的）服务端的隧道</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>OPTIONS</td><td>请求有关可用于目标资源的通信选项，无论这些信息是存储在服务端还是中介</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>TRACE</td><td>沿着到目标资源的网络路径执行 HTTP 消息的环回测试</td><td>否</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><p>下面详细介绍各请求方法：</p><ul><li><p>GET</p><p>GET 方法是信息检索的主要机制，也是几乎所有性能优化的重点。客户端通过在请求头中设置 Range 字段，可以将 GET 方法的语义更改为“范围请求”，即请求仅传输所选表示的某些部分。注意，这不是类似于对订单信息的分页查询，而是请求对响应的部分获取。</p></li><li><p>HEAD</p><p>HEAD 方法可用于在不传输表示数据的情况下获取所选表示的元数据，通常用于测试超文本链接的有效性、可访问性和最近是否修改。HEAD方法的 响应可能对先前缓存的 GET 方法响应产生影响。</p></li><li><p>POST</p><p>POST 方法不可以被理解为仅代表<strong>创建</strong>。简单说，我们将请求分为读、写两类，那么自然 GET 方法代表读请求，POST 方法代表写请求。写请求自然包含很多语义，类似于创建、修改、删除、取消、预约等等。这是一开始 POST 方法的设计，也是过去（现在甚至还存在）很多系统对于 GET 和 POST 方法的使用方式。可以说，有了 GET 和 POST 方法就可以了。但是，为了更好的利用网络资源，对 HTTP 消息进行优化，比如缓存，以及规范客户端与服务端的交互，就逐渐需要更细化的方法定义，这也是 PUT、DELETE等方法的由来。</p></li><li><p>PUT</p><p>POST 和 PUT 方法之间的根本区别是： POST 方法旨在根据目标资源自己所定义的语义处理请求中的资源表示，而 PUT 方法被定义为替换目标资源的状态。</p><p>除了客户端请求的意图和服务端响应的语义可以表达的内容之外，HTTP 没有确切定义 PUT 方法如何影响服务端资源的状态。资源接口 URI 背后的所有实现细节都被服务端隐藏。</p><p>服务端应该保证 PUT 方法不会修改所定义的资源约束，并验证请求中的表示符合任何约束。当 PUT 方法请求中的表示与目标资源不一致时，服务端应该通过转换表示或更改资源配置来使它们一致，或者以包含足够信息的错误响应来解释表示为什么不合适。</p></li><li><p>PATCH</p><p>PATCH 方法将请求体中描述的一组更改应用于 URI 所标识的资源。更改的格式为补丁文档。如果 URI 未指向现有资源，则服务器可以创建新资源，具体取决于补丁文档类型是否可以在逻辑上修改空资源，以及权限等限制。</p><p>PUT 和 PATCH 方法之间的区别体现在服务端处理表示从而修改 URI 所标识的资源的方式上。PUT 方法请求所包含的表示被认为是存储在源服务器服务端上的资源的修改版本，客户端请求使用这个资源的修改版本替换现有的存储版本。但是 PATCH 方法请求所包含的表示是一组指令，它描述了当前服务端上的资源应如何修改以生成新版本。 服务端必须以原子方式应用整个更改指令，并且不会提供部分修改的表示。如果无法成功应用整个补丁文档，则服务端不得应用任何更改。原子性要求适用于所有直接受影响的文件和数据。如果补丁文档的大小大于 PUT 方法请求中的新资源的大小，那么更应该使用 PUT 方法。</p><p>POST 方法的使用方式多种多样，如果服务器愿意，可以将 POST 方法实现为类似 PUT 和 PATCH 的操作。如果操作没有以可预测的方式修改由 URI 标识的资源，则更应考虑 POST 方法。</p></li><li><p>DELETE</p><p>如果目标资源具有一个或多个表示，它们可能会或不会被服务端销毁，并且其存储可能会或不会被回收，这完全取决于资源的性质及其服务端的实现。</p></li><li><p>CONNECT</p><p>隧道通是通过一个或多个代理所创建的端到端的虚拟连接，可以使用 TLS 进行保护。除了成功响应之外的任何响应都表明隧道尚未连接成功，并且连接仍然由 HTTP 控制。如果隧道连接成功，则此后客户端与服务端的<strong>发送或者接受 TCP 消息流</strong>，直到隧道关闭。</p><p>建立通向任意服务端的隧道存在重大风险，特别是当目标服务端不是众所周知或保留的 TCP 端口时。</p></li><li><p>OPTIONS</p><p>客户端应该在向用户呈现通信选项时区分安全和不安全的方法。</p></li><li><p>TRACE</p></li></ul><h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><p>客户端必须理解任何状态代码类别（例如 3xx），并将无法识别的状态代码视为等同于该类别的 x00 状态码。</p><ul><li>1xx（信息）：请求已收到，继续处理。</li><li>2xx（成功）：请求被成功接收、理解和接受。</li><li>3xx（重定向）：需要采取进一步行动才能完成请求。</li><li>4xx（客户端错误）：请求包含错误的语法或无法完成。</li><li>5xx（服务器错误）：服务器未能满足有效的请求。</li></ul><h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><h2 id="World-Wide-Web-万维网特点及其需求"><a href="#World-Wide-Web-万维网特点及其需求" class="headerlink" title="World Wide Web 万维网特点及其需求"></a>World Wide Web 万维网特点及其需求</h2><p>在理解 REST 设计思想之前，我们需要先明确 Web 的特点，即 Web 系统架构的设计要求。</p><p>Web 的主要目标是成为一个人与机器互联互通的信息共享空间：人们需要一种方法来构建和存储他们自己的信息，无论这些信息是永久的还是短暂的，以便自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护信息的本地副本。Web 系统的最终预期是用户位于世界各地，并通过 Web 连接的。用户所使用的机器是终端、工作站、服务器和超级计算机的异构集合，有各式各样的操作系统软件和文件格式。信息范围从个人研究笔记到组织电话列表。Web 系统需要为这些异构信息提供普遍一致的接口，在尽可能多的平台上使用，并且随着新人员和组织加入而逐步部署整个 Web 系统。</p><p>尽管对它的成功感到欣喜若狂，但 Internet 开发人员社区开始担心 Web 使用的快速增长以及早期 HTTP 的一些不良网络特性会迅速超过 Internet 基础设施的容量并导致全面崩溃。Web 上应用程序交互性质的变化使情况变得更糟。最初的协议是为单个请求-响应对设计的，而新站点使用越来越多的内嵌图像作为网页内容的一部分，从而产生不同的浏览交互配置文件。部署的架构在支持可扩展性、共享缓存和中介方面存在重大限制，这使得针对日益增长的问题开发临时解决方案变得困难。同时，</p><p>Internet Engineering Taskforce 内的工作组成立以研究 Web 的三个主要标准：URI、HTTP 和 HTML。这些小组的章程是定义在早期 Web 架构中普遍和一致实现的现有架构通信的子集，识别该架构中的问题，然后指定一组标准来解决这些问题。这给我们带来了一个挑战：我们如何向已经广泛部署的架构引入一组新功能，以及我们如何确保它的引入不会对支持 Web 的架构属性产生不利影响甚至破坏成功？</p><p>Web 系统有以下特点：</p><ul><li><p>低门槛</p><p>由于参与信息的创建和构建是自愿的，因此需要低门槛才能充分采用。这适用于 Web 架构的所有用户：读者、作者和应用程序开发人员。</p><p>选择超媒体作为用户界面是因为它的简单性和通用性：无论信息来源如何，都可以使用相同的界面，超媒体关系（链接）的灵活性允许无限的结构化，链接的直接操作允许内部的复杂关系指导读者完成应用程序的信息。由于大型数据库中的信息通常更容易通过搜索界面而不是浏览来访问，因此 Web 还集成了通过向服务提供用户输入的数据并将结果呈现为超媒体来执行简单查询的能力。</p><p>对于作者而言，主要要求是整个系统的部分可用性不得妨碍内容的创作。超文本创作语言需要简单并且能够使用现有的编辑工具进行创建。作者希望以这种格式保存个人研究笔记等内容，无论是否直接连接到互联网，因此不能允许某些参考信息暂时或永久不可用的事实阻止阅读和创作可用的信息。出于类似的原因，必须能够在该引用的目标可用之前创建对信息的引用。由于鼓励作者合作开发信息源，参考文献需要易于交流，</p><p>简单性也是应用程序开发人员的目标。由于所有协议都定义为文本，因此可以使用现有网络工具查看和交互测试通信。尽管缺乏标准，这使得协议的早期采用得以实现。</p></li><li><p>可拓展性</p><p>虽然简单性使得部署分布式系统的初始实现成为可能，但可扩展性使我们能够避免永远陷入部署的限制。即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。一个想要像 Web 一样长期存在的系统必须准备好接受变化。</p></li><li><p>分布式超媒体</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此架构需要最小化网络交互（数据传输协议内的往返）。</p></li><li><p>互联网规模</p><p>万维网旨在成为一个<em>互联网规模的</em>分布式超媒体系统，这意味着不仅仅是地理上的分散。互联网是关于跨越多个组织边界的互连信息网络。信息服务供应商必须能够应对无政府可扩展性和软件组件独立部署的需求。</p><h4 id="4-1-4-1-无政府可扩展性"><a href="#4-1-4-1-无政府可扩展性" class="headerlink" title="4.1.4.1 无政府可扩展性"></a>4.1.4.1 无政府可扩展性</h4><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>架构元素及其运行平台的安全性也成为一个重要的问题。多个组织边界意味着在任何通信中都可能存在多个信任边界。中间应用程序（例如防火墙）应该能够检查应用程序交互并防止组织安全策略之外的应用程序被执行。应用程序交互中的参与者应该假设收到的任何信息都是不可信的，或者在给予信任之前需要一些额外的身份验证。这要求架构能够传达身份验证数据和授权控制。但是，由于身份验证会降低可扩展性，因此架构的</p><h4 id="4-1-4-2-独立部署"><a href="#4-1-4-2-独立部署" class="headerlink" title="4.1.4.2 独立部署"></a>4.1.4.2 独立部署</h4><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>具象状态传输（REST）</strong>是一种软件架构风格，旨在指导万维网架构的设计和开发，特别是客户端-服务端应用程序。但更重要的是，REST 为互联网规模的分布式超媒体系统的架构定义了一组约束条件，因此客户端和服务端之间的耦合必须尽可能松散以促进大规模使用。这是通过定义<strong>资源</strong>作为抽象层，从而隐藏了底层实现细节。这种方法允许在跨组织（信任）边界的大规模分布式环境中的客户端和服务端之间实现最大的互操作性。</p><p>REST 的目标是提高性能、可扩展性、简单性、可修改性、可见性、可移植性和可靠性。这是通过遵循 REST 原则来实现的，例如客户端 - 服务器架构、无状态、可缓存性、分层系统的使用、按需代码支持以及使用统一接口。要对系统进行分类，必须遵循这些原则。REST架构风格强调组件间交互的可扩展性、统一接口、组件独立部署、分层架构、方便缓存组件、减少用户感知延迟、加强安全性和封装遗留系统。</p><p>就其本质而言，架构风格独立于任何特定的实现，虽然 REST 是作为 Web 标准开发的一部分创建的，但 Web 的实现并不遵守 REST 架构风格中的每一个约束。不匹配可能由于无知或疏忽而发生，但 REST 架构风格的存在意味着它们可以在标准化之前被识别出来。例如，Fielding 将会话信息嵌入 URI 确定为违反 REST 的约束，这会对共享缓存和服务器可扩展性产生负面影响。<a href="https://en.wikipedia.org/wiki/HTTP_cookies">HTTP cookie</a>也违反了 REST 约束，因为它们可能与浏览器的应用程序状态不同步，从而使它们不可靠；它们还包含可能涉及隐私和安全的不透明数据。</p><p>REST 已被整个软件行业采用，并且是一套被广泛接受的用于创建无状态、可靠的<a href="https://en.wikipedia.org/wiki/Web_API">Web API 的指南</a>。遵守<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints">REST 约束的</a>Web API被非正式地描述为<strong>RESTful</strong>。RESTful Web API 通常松散地基于<a href="https://en.wikipedia.org/wiki/HTTP_method">HTTP 方法</a>，通过<a href="https://en.wikipedia.org/wiki/URL-encoding">URL 编码的</a>参数访问<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_concepts">资源</a>，并使用<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或<a href="https://en.wikipedia.org/wiki/XML">XML</a>传输数据。</p><p>为了创建 REST 架构风格，Fielding 确定了在创建基于全球网络的应用程序时适用的要求，例如需要低进入壁垒以实现全球采用。他还调查了基于网络的应用程序的许多现有架构风格，确定了哪些功能与其他风格共享，例如缓存和客户端-服务器功能，以及 REST 独有的功能，例如资源概念。Fielding 试图对当前实现的现有架构进行分类，并确定哪些方面应该被视为 Web 的行为和性能要求的核心。</p><p>其核心原则是定义可以用少量方法控制的命名资源。这些资源和方法被称为 API 的“名词”和“动词”。使用 HTTP 协议时，资源名称自然映射到网址，方法自然映射到 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>。这使得要学习的内容减少了很多，因为开发人员可以专注于资源及其关系，并假定它们拥有的标准方法同样很少。</p><p>一个万维网应该如何工作的模型。</p><p>REST 最初被称为“HTTP 对象模型”，但该名称通常会导致将其误解为 HTTP 服务器的实现模型。“具象状态转移”这个名称旨在唤起一个精心设计的 Web 应用程序行为的图像：网页网络（虚拟状态机），用户通过选择链接（状态转换）在应用程序中前进。REST 提供了一组架构约束，当作为一个整体应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署和中间组件，以减少交互延迟、加强安全性和封装遗留系统。</p><p>Representational State Transfer (REST) 风格是分布式超媒体系统中架构元素的抽象。REST 忽略了组件实现和协议语法的细节，以便专注于组件的角色、它们与其他组件交互的约束以及它们对重要数据元素的解释。它包含对组件、连接器和数据的基本约束，这些约束定义了 Web 体系结构的基础，从而定义了其作为基于网络的应用程序的行为的本质。</p><p>REST 定义了一个预期应用程序行为模型，该模型支持简单而健壮的应用程序，这些应用程序在很大程度上不受困扰大多数基于网络的应用程序的部分故障条件的影响。</p><p>通过将延迟减少作为架构目标，REST 可以根据用户感知的性能区分媒体类型（表示的数据格式）。</p><p>REST 是一组协调的架构约束，它试图最大限度地减少延迟和网络通信，同时最大限度地提高组件实现的独立性和可扩展性。这是通过对连接器语义施加约束来实现的，而其他样式则专注于组件语义。REST 实现了交互的缓存和重用、组件的动态可替代性以及中介对动作的处理，从而满足了互联网规模的分布式超媒体系统的需求。</p><p>REST 仅详细阐述了被认为对互联网规模的分布式超媒体交互必不可少的架构部分。对于基于网络的应用程序，系统性能取决于网络通信。对于分布式超媒体系统，组件交互由大粒度数据传输而不是计算密集型任务组成。REST 风格是为响应这些需求而开发的。它对资源和表示的通用连接器接口的关注启用了组件的中间处理、缓存和可替换性，这反过来又允许基于 Web 的应用程序从 1994 年的 100,000 个请求/天扩展到 1999 年的 600,000,000 个请求/天。</p><p>REST 或 REpresentational State Transfer 是一种架构风格，用于在网络上的计算机系统之间提供标准，使系统更容易相互通信。符合 REST 的系统，通常称为 RESTful 系统，其特点是它们是无状态的，并且将客户端和服务器的关注点分开。</p><p>2000 年，Roy Fielding 提出了表征状态转移 (REST) 作为设计 Web 服务的架构方法。REST 是一种基于超媒体构建分布式系统的架构风格。REST 独立于任何底层协议，不一定与 HTTP 绑定。但是，最常见的 REST API 实现使用 HTTP 作为应用程序协议。REST 相对于 HTTP 的主要优势在于它使用开放标准，并且不会将 API 或客户端应用程序的实现绑定到任何特定实现。</p><ul><li>REST API 是围绕<em>资源</em>设计的，<em>资源</em>是客户端可以访问的任何类型的对象、数据或服务。</li><li>资源有一个<em>identifier</em>，它是唯一标识该资源的 URI。</li><li>客户端通过交换资源<em>表示</em>与服务交互。</li><li>REST API 使用统一的接口，这有助于将客户端和服务实现解耦。对于基于 HTTP 构建的 REST API，统一接口包括使用标准 HTTP 动词对资源执行操作。最常见的操作是 GET、POST、PUT、PATCH 和 DELETE。</li><li>REST API 使用无状态请求模型。HTTP 请求应该是独立的并且可以以任何顺序发生，因此在请求之间保持瞬态信息是不可行的。唯一存储信息的地方是资源本身，每个请求都应该是一个原子操作。此约束使 Web 服务具有高度可扩展性，因为无需在客户端和特定服务器之间保留任何关联。任何服务器都可以处理来自任何客户端的任何请求。也就是说，其他因素可能会限制可扩展性。</li><li>REST API 由表示中包含的超媒体链接驱动。</li></ul><h2 id="架构约束"><a href="#架构约束" class="headerlink" title="架构约束"></a>架构约束</h2><p>六个指导性约束定义了一个 RESTful 系统。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-SOA_with_REST-6">6] </a>[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Richardson_2007-8">8]</a>这些约束限制了服务器处理和响应客户端请求的方式，因此，通过在这些约束内运行，系统可以获得理想的<a href="https://en.wikipedia.org/wiki/Non-functional_requirement">非功能特性</a>，例如性能、可伸缩性、简单性、可修改性、可见性、便携性和可靠性。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a>如果系统违反了任何必需的约束，则不能将其视为 RESTful。</p><p>正式的 REST 约束如下：</p><h3 id="客户端-服务端架构"><a href="#客户端-服务端架构" class="headerlink" title="客户端-服务端架构"></a>客户端-服务端架构</h3><p>关注点分离是客户端-服务器约束背后的原则。通过将用户界面问题与数据存储问题分开，我们提高了用户界面跨多个平台的可移植性，并通过简化服务器组件提高了可扩展性。然而，也许对 Web 最重要的是分离允许组件独立发展，从而支持多个组织域的 Internet 规模需求。</p><p>在 REST 架构风格中，客户端的实现和服务器的实现可以独立完成，彼此互不了解。只要每一方都知道要向另一方发送什么格式的消息，它们就可以保持模块化和分离。将用户界面问题与数据存储问题分开，我们提高了跨平台界面的灵活性，并通过简化服务器组件来提高可扩展性。此外，分离允许每个组件独立发展的能力。通过使用 REST 接口，不同的客户端访问相同的 REST 端点，执行相同的操作，并接收相同的响应。</p><p>一个或多个客户端必须能够同时监视和操作同一资源。</p><p>大多数现代 Web 应用程序都公开了客户端可用于与应用程序交互的 API。一个设计良好的 Web API 应该旨在支持：</p><ul><li><strong>平台独立性</strong>。无论 API 在内部如何实现，任何客户端都应该能够调用 API。这需要使用标准协议，并具有一种机制，使客户端和 Web 服务可以就要交换的数据格式达成一致。</li><li><strong>服务进化</strong>。Web API 应该能够独立于客户端应用程序发展和添加功能。随着 API 的发展，现有的客户端应用程序应该无需修改即可继续运行。所有功能都应该是可发现的，以便客户端应用程序可以充分使用它。</li></ul><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>在计算中，无状态协议是一种<a href="https://en.wikipedia.org/wiki/Communications_protocol">通信协议</a>，其中接收方（通常是服务器）不保留会话信息。客户端将相关会话数据发送到接收器，这样传输的每个信息包都可以被孤立地理解，而无需会话中先前数据包的上下文信息。无状态协议的这一特性使它们成为高容量应用程序的理想选择，通过消除由保留会话信息引起的服务器负载来提高性能。</p><p>我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_3">第 3.4.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_3">图 5-3</a>）的客户端-无状态-服务器 (CSS) 风格，这样从客户端到服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。这种约束导致了可见性、可靠性和可伸缩性的特性。可见性得到改善，因为监控系统不必查看单个请求数据之外的内容来确定请求的全部性质。可靠性得到提高，因为它简化了从部分故障中恢复的任务 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。可扩展性得到改进，因为不必在请求之间存储状态允许服务器组件快速释放资源，并进一步简化实现，因为服务器不必管理跨请求的资源使用。与大多数架构选择一样，无状态约束反映了设计权衡。缺点是它可能会通过增加一系列请求中发送的重复数据（每次交互开销）来降低网络性能，因为这些数据不能在共享上下文中留在服务器上。此外，将应用程序状态置于客户端会减少服务器对一致应用程序行为的控制，因为应用程序变得依赖于跨多个客户端版本的正确语义实现。</p><p>遵循 REST 范式的系统是无状态的，这意味着服务器不需要知道客户端处于什么状态，反之亦然。这样，服务器和客户端都可以理解收到的任何消息，即使没有看到以前的消息。这种无状态约束是通过使用<em>资源</em>而不是<em>命令</em>来强制执行的。资源是 Web 的名词——它们描述您可能需要存储或发送到其他服务的任何对象、文档或 <em>事物</em>。由于 REST 系统通过对资源的标准操作进行交互，因此它们不依赖于接口的实现。这些约束帮助 RESTful 应用程序实现可靠性、快速性能和可扩展性，作为可以管理、更新和重用的组件，即使在系统运行期间也不影响整个系统。</p><p>系统状态应该始终是可发现和可测试的。即使操作跟踪资源不再处于活动状态，客户端也应该能够确定系统状态。查询长时间运行的操作状态的行为本身应该利用网络的原则。即具有统一接口语义的明确定义的资源。客户端可以对某些资源发出 GET 请求以确定长时间运行的操作的状态</p><p>长期运行的操作应该适用于希望“即发即忘”的客户以及希望积极监控结果并采取行动的客户。</p><p>取消并不明确意味着回滚。在每个 API 定义的情况下，它可能意味着回滚、补偿、完成或部分完成等。在取消操作之后，客户不应该负责将服务返回到允许继续服务的一致状态。</p><h3 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h3><p>在万维网上，客户端和中介可以缓存响应。响应必须隐式或显式地将自己定义为可缓存或不可缓存，以防止客户端提供陈旧或不适当的数据以响应进一步的请求。管理良好的缓存部分或完全消除了一些客户端-服务器交互，进一步提高了可扩展性和性能。</p><p>为了提高网络效率，我们添加缓存约束，形成<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_4">3.4.4节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_4">图5-4</a>）的client-cache-stateless-server样式。缓存约束要求对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权为以后的等效请求重用该响应数据。添加缓存约束的优势在于它们有可能通过减少一系列交互的平均延迟来部分或完全消除某些交互，从而提高效率、可扩展性和用户感知性能。然而，权衡是，如果缓存中的陈旧数据与将请求直接发送到服务器时获得的数据显着不同，则缓存会降低可靠性。</p><h3 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h3><p>统一接口约束是任何 RESTful 系统设计的基础。它简化和解耦了架构，使每个部分都可以独立演进。这个统一接口的四个约束是：</p><ul><li>请求中的资源标识 - 单个资源在请求中标识，例如在 RESTful Web 服务中使用URI。资源本身在概念上与返回给客户端的表示分开。例如，服务器可以以HTML、XML或JSON格式从其数据库发送数据——这些都不是服务器的内部表示。</li><li>通过表示进行资源操作 - 当客户端持有资源的表示（包括附加的任何<a href="https://en.wikipedia.org/wiki/Metadata">元数据）时</a>，它有足够的信息来修改或删除资源的状态。</li><li>自描述消息 - 每条消息都包含足够的信息来描述如何处理消息。例如，要调用的解析器可以由<a href="https://en.wikipedia.org/wiki/Media_type">媒体类型</a>指定。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a></li><li>超媒体作为应用状态（发动机<a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>） -已经进入一个初始的URI REST应用类似于人类的Web用户访问该<a href="https://en.wikipedia.org/wiki/Home_page">主页</a>网站-REST客户端的话应该能够动态地使用服务器提供的链接发现它需要的所有可用资源。随着访问的进行，服务器以包含指向当前可用的其他资源的<a href="https://en.wikipedia.org/wiki/Hyperlink">超链接的</a>文本进行响应。客户端无需使用有关应用程序结构或动态的信息进行硬编码。</li></ul><p>将 REST 架构风格与其他基于网络的风格区分开来的核心特征是它强调组件之间的统一接口（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_6">图 5-6</a>）。通过将通用性的软件工程原理应用于组件接口，简化了整个系统架构并提高了交互的可见性。实现与它们提供的服务分离，这鼓励了独立的可进化性。然而，代价是统一的接口会降低效率，因为信息是以标准化的形式传输的，而不是特定于应用程序需求的形式。REST 接口被设计为高效的大粒度超媒体数据传输，针对 Web 的常见情况进行优化，但导致接口对于其他形式的架构交互不是最佳的。为了获得统一的接口，需要多个架构约束来指导组件的行为。REST 由四个接口约束定义：资源识别、通过表征操纵资源、自我描述信息、超媒体作为应用程序状态的引擎。</p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>客户端通常无法判断它是直接连接到终端服务器还是沿途的中介。如果在客户端和服务器之间放置代理或负载均衡器，则不会影响它们的通信，也不需要更新客户端或服务器代码。中间服务器可以通过启用负载平衡和提供共享缓存来提高系统可扩展性。此外，安全性可以添加为 Web 服务之上的一个层，将业务逻辑与安全逻辑分开。将安全添加为一个单独的层会强制执行安全策略。最后，中间服务器可以调用多个其他服务器来生成对客户端的响应。</p><p>为了进一步改善 Internet 规模需求的行为，我们添加了分层系统约束（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_7">图 5-7</a>）。如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_2">第 3.4.2 节</a>所述，分层系统风格允许架构通过约束组件行为而由分层层组成，使得每个组件不能“看到”超出与其交互的直接层。通过将系统的知识限制在单个层，我们对整个系统的复杂性进行了限制，并促进了基板的独立性。层可用于封装遗留服务并保护来自遗留客户端的新服务，通过将不常用的功能移动到共享中介来简化组件。中介还可用于通过跨多个网络和处理器实现服务负载平衡来提高系统可扩展性。分层系统的主要缺点是它们增加了数据处理的开销和延迟，降低了用户感知的性能 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_32">32</a> ]。对于支持缓存约束的基于网络的系统，这可以被中介共享缓存的好处所抵消。在组织域的边界放置共享缓存可以带来显着的性能优势 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_136">136</a> ]。这些层还允许对跨越组织边界的数据实施安全策略，这是防火墙的要求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_79">79</a> ]。分层系统和统一接口约束的组合产生类似于统一管道和过滤器风格（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_2_2">第 3.2.2 节</a>）的架构特性。尽管 REST 交互是双向的，但超媒体交互的大粒度数据流都可以像数据流网络一样进行处理，过滤器组件有选择地应用于数据流，以便在内容通过时对其进行转换 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_26">26</a> ]。在 REST 中，中介组件可以主动转换消息的内容，因为消息是自描述的，并且它们的语义对中介是可见的。</p><h3 id="按需代码（可选）"><a href="#按需代码（可选）" class="headerlink" title="按需代码（可选）"></a>按需代码（可选）</h3><p>服务器可以通过传输可执行代码来临时扩展或自定义客户端的功能：例如，已编译的组件（如Java 小程序）或客户端脚本（如JavaScript）。</p><p>我们为 REST 设置的最后一项约束来自<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_5_3">第 3.5.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_8">图 5-8</a>）的按需代码风格。REST 允许通过下载和执行小程序或脚本形式的代码来扩展客户端功能。这通过减少需要预先实现的功能数量来简化客户端。允许在部署后下载功能提高了系统可扩展性。但是，它也会降低可见性，因此它只是 REST 中的一个可选约束。可选约束的概念似乎是矛盾的。但是，它在包含多个组织边界的系统的架构设计中确实有其用途。这意味着体系结构只有在已知可选约束对整个系统的某些领域有效时才能获得它们的好处（并遭受缺点）。可选约束允许我们设计一个架构，在一般情况下支持所需的行为，但要理解它可能在某些上下文中被禁用。</p><h2 id="架构元素"><a href="#架构元素" class="headerlink" title="架构元素"></a>架构元素</h2><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p><img src="/images/SAC/REST/data_element.png"></p><p>数据元素的性质和状态是 REST 架构的一个重要方面。</p><p>许多分布式处理范式将处理逻辑（例如代码、存储过程、搜索表达式等，MapReduce 即是此思想的代表）移动到数据端，而不是将数据移动到处理组件中，这些分布式对象的所有数据都封装在处理组件中并由处理组件隐藏。在 REST 架构中，用户选择链接后，数据需要从其存储位置移动到用户的位置。有如下三种基本的数据移动方式：</p><ol><li><strong>在数据所在的位置渲染数据并将固定格式的渲染结果发送给接收者。</strong>传统的客户端 - 服务器风格，允许所有关于数据真实性质的信息隐藏在发送者中，防止对数据结构做出假设并使客户端实现更容易。但是，它也严重限制了接收方的功能，并将大部分处理负载置于发送方，从而导致可扩展性问题。    </li><li><strong>用渲染引擎封装数据并发送给接收者。</strong>移动对象样式 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_50">50</a>]，提供信息隐藏，同时通过其独特的渲染引擎对数据进行专门处理，但将接收方的功能限制在该引擎中的预期范围内，并可能大大增加传输的数据量。</li><li><strong>将原始数据连同描述数据类型的元数据一起发送给接收者，以便接收者可以选择自己的渲染引擎。</strong>允许发送方在最小化传输的字节数的同时保持简单和可扩展，但失去了信息隐藏的优势，并且要求发送方和接收方都理解相同的数据类型。</li></ol><p>REST 通过关注对数据类型与元数据的共同理解，提供了所有三个选项的混合，但限制了向标准化接口显示的内容的范围。REST 组件通过以与一组不断发展的标准数据类型之一匹配的格式传输资源的表示来进行通信，根据接收者的能力或愿望以及资源的性质动态选择。无论表示形式与原始源的格式相同，还是源自源，都隐藏在界面后面。通过发送由封装渲染引擎的标准数据格式中的指令组成的表示，可以近似移动对象样式的好处。因此，REST 获得了客户端-服务器风格的关注点分离，而没有服务器可扩展性问题，允许通过通用接口隐藏信息以实现服务的封装和演变，并通过可下载的功能引擎提供多样化的功能集。</p><p>REST 中信息的关键抽象是<em>资源</em>。任何可以命名的信息都可以是资源：文档或图像、时间服务（例如“洛杉矶今天的天气”）、其他资源的集合、非虚拟对象（例如人）等. 换句话说，任何可能成为作者超文本引用目标的概念都必须符合资源的定义。资源是到一组实体的概念映射，而不是在任何特定时间点对应于映射的实体。更准确地说，资源<em>R</em>是随时间变化的隶属函数<em>M</em> R <em>(t)<em>，它在时间</em>t</em>映射到一组等效的实体或值。集合中的值可以是<em>资源表示</em>和/或<em>资源标识符</em>。资源可以映射到空集，这允许在该概念的任何实现存在之前对其进行引用——这个概念对于 Web 之前的大多数超文本系统来说是陌生的 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_61">61]</a>]。某些资源在某种意义上是静态的，即在它们创建后的任何时间进行检查时，它们始终对应于相同的值集。其他人的价值随着时间的推移有很大程度的变化。资源唯一需要静态的是映射的语义，因为语义是区分一种资源与另一种资源的原因。资源的这种抽象定义启用了 Web 架构的关键特性。首先，它通过包含许多信息源而没有人为地按类型或实现来区分它们来提供通用性。其次，它允许对表示的引用进行后期绑定，从而能够根据请求的特征进行内容协商。最后，它允许作者引用该概念而不是该概念的某些单一表示，从而无需在表示更改时更改所有现有链接（假设作者使用了正确的标识符）。REST 使用资源标识符来标识组件之间交互中涉及的特定资源。REST 连接器提供了一个通用接口，用于访问和操作资源的值集，而不管成员函数是如何定义的或处理请求的软件类型如何。分配资源标识符的命名机构，使引用资源成为可能，负责随着时间的推移维护映射的语义有效性（即，确保成员函数不会改变）。</p><p>REST 组件通过使用表示来捕获该资源的当前或预期状态并在组件之间传输该表示来对资源执行操作。表示是一个字节序列，加上描述这些字节的表示元数据。表示的其他常用但不太精确的名称包括：文档、文件和 HTTP 消息实体、实例或变体。表示包括数据、描述数据的元数据，有时还包括描述元数据的元数据（通常用于验证消息完整性）。元数据采用名称-值对的形式，其中名称对应于定义值结构和语义的标准。响应消息可能包括表示元数据和资源元数据：关于资源的信息，不是特定于所提供的表示。控制数据定义了组件之间消息的目的，例如请求的操作或响应的含义。它还用于参数化请求并覆盖某些连接元素的默认行为。例如，缓存行为可以通过包含在请求或响应消息中的控制数据进行修改。根据消息控制数据，给定的表示可以指示所请求资源的当前状态、所请求资源的期望状态或某些其他资源的值，例如客户端查询表单中输入数据的表示，或响应的某些错误条件的表示。例如，资源的远程创作要求创作者向服务器发送一个表示，从而为该资源建立一个值，该值可以由以后的请求检索。如果给定时间资源的值集由多个表示组成，则可以使用内容协商来选择最佳表示以包含在给定消息中。</p><p>但定义比这更普遍：任何可以命名的信息都可以是资源：图像、数据库查询、时间服务（例如“伦敦今天的天气”），甚至是其他资源的集合</p><p>面向资源的 API 通常被构建为资源层次结构，其中每个节点是一个“简单资源”或“集合资源”。为方便起见，它们通常被分别称为资源和集合。</p><ul><li>一个集合包含<strong>相同类型</strong>的资源列表。 例如，一个用户拥有一组联系人。</li><li>资源具有一些状态和零个或多个子资源。 每个子资源可以是一个简单资源或一个集合资源。</li></ul><p>例如，Gmail API 有一组用户，每个用户都有一组消息、一组线程、一组标签、一个个人资料资源和若干设置资源。</p><p>虽然存储系统和 REST API 之间存在一些概念上的对应，但具有面向资源 API 的服务不一定是数据库，并且在解释资源和方法方面具有极大的灵活性。例如，创建日历事件（资源）可以为参与者创建附加事件、向参与者发送电子邮件邀请、预约会议室以及更新视频会议时间安排。</p><p>虽然完整的资源名称类似于普通网址，但两者并不相同。单个资源可以由不同的 API 版本、API 协议或 API 网络端点公开。完整资源名称未指明此类信息，因此在实际使用中必须将其映射到特定的 API 版本和 API 协议。</p><p>“Web 资源”首先在万维网上定义为由其URL标识的文档或文件。今天，该定义更加通用和抽象，包括可以在 Web 上以任何方式识别、命名、寻址、处理或执行的所有事物、实体或操作。在 RESTful Web 服务中，对资源的<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>发出的请求会引发响应，其<a href="https://en.wikipedia.org/wiki/Payload_(computing)">有效负载</a>格式为<a href="https://en.wikipedia.org/wiki/HTML">HTML</a>、<a href="https://en.wikipedia.org/wiki/XML">XML</a>、<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或某种其他格式。例如，响应可以确认资源状态已更改。响应还可以包含<a href="https://en.wikipedia.org/wiki/Hypertext">超文本</a>相关资源的链接。这些请求和响应最常见的协议是 HTTP。它提供操作（<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP 方法</a>），例如 GET、POST、PUT 和 DELETE。通过使用无状态协议和标准操作，RESTful 系统旨在通过重用可以管理和更新的组件来实现快速性能、可靠性和增长能力，即使在系统运行时也不影响整个系统。</p><p>客户端只能使用<strong>URI</strong>访问资源。换句话说，客户端使用 URI 请求资源，服务器使用资源的<strong>表示</strong>进行响应。资源的表示是 REST 中的另一个重要概念。为了确保响应可以被尽可能多的客户端<strong>应用程序</strong>解释，资源的表示以超文本格式发送。因此，通过在客户端和服务器之间的<strong>消息中</strong>传输的超文本表示来操纵资源。客户端和服务器的强解耦以及使用统一寻址协议的基于文本的信息传输为满足 Web 的要求提供了基础：健壮性（无政府可扩展性）、组件的独立部署、大粒度数据传输和内容读者、内容作者和开发人员的低准入门槛。</p><p>REST 架构风格的约束影响以下架构属性：</p><ul><li>组件交互中的性能，这可能是用户感知性能和网络效率的主导因素；[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch2-7">7]</a></li><li><a href="https://en.wikipedia.org/wiki/Scalability">可扩展性</a>允许支持大量组件和组件之间的交互；</li><li>统一界面的简单性；</li><li>组件的可修改性以满足不断变化的需求（即使在应用程序运行时）；</li><li>服务代理组件之间通信的可见性；</li><li>通过随数据移动程序代码来实现组件的可移植性；</li><li>在组件、连接器或数据中存在故障时，系统级抗故障的可靠性。</li></ul><p>REST 用于定义 URI 标准的术语资源 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_21">21</a>]，以及通过其表示来操作资源的通用接口的整体语义。早期的 Web 架构将 URI 定义为文档标识符。作者被指示根据文档在网络上的位置来定义标识符。然后可以使用 Web 协议来检索该文档。然而，由于多种原因，这个定义被证明是不令人满意的。首先，它表明作者正在识别传输的内容，这意味着只要内容发生变化，标识符就应该改变。其次，存在许多对应于服务而不是文档的地址——作者可能打算将读者引导至该服务，而不是先前访问该服务的任何特定结果。最后，在某些时间段存在与文档不对应的地址，REST 中资源的定义基于一个简单的前提：标识符应尽可能不经常更改。因为 Web 使用嵌入式标识符而不是链接服务器，作者需要一个与他们想要的超媒体引用语义密切匹配的标识符，允许引用保持静态，即使访问该引用的结果可能会随着时间的推移而改变。REST 通过将资源定义为作者想要识别的语义，而不是在创建引用时对应于这些语义的值来实现这一点。然后由作者确保为引用选择的标识符确实标识了预期的语义。</p><p>定义资源以便 URI 标识概念而不是文档给我们留下了另一个问题：用户如何访问、操作或传输概念，以便在选择超文本链接时他们可以获得有用的东西？REST 通过将被操作的事物定义为已识别资源的表示而不是资源本身来回答这个问题。源服务器维护从资源标识符到对应于每个资源的一组表示的映射。因此，通过资源标识符定义的通用接口传输表示来操纵资源。REST 对资源的定义源自 Web 的核心需求：跨多个信任域独立创作互连的超文本。强制接口定义与接口要求相匹配会导致协议看起来模糊，但这只是因为被操作的接口只是一个接口而不是一个实现。协议特定于应用程序操作的意图，但接口背后的机制必须决定该意图如何影响资源映射到表示的底层实现。信息隐藏是推动 REST 统一接口的关键软件工程原则之一。由于客户端仅限于对表示的操作而不是直接访问资源的实现，因此可以以命名机构所需的任何形式构造实现，而不会影响可能使用其表示的客户端。此外，如果在访问资源时存在多个资源表示，则可以使用内容选择算法来动态选择最适合该客户端能力的表示。当然，缺点是资源的远程创作不像文件的远程创作那么简单。</p><p>通过 Web 的统一接口进行远程创作的挑战是由于客户端可以检索的表示与服务器上可能用于存储、生成或检索该表示的内容的机制之间的分离。单个服务器可以将其命名空间的某些部分映射到文件系统，文件系统又映射到可以映射到磁盘位置的 inode 的等价物，但是这些底层机制提供了一种将资源与一组表示相关联的方法，而不是而不是识别资源本身。许多不同的资源可以映射到相同的表示，而其他资源可能根本没有映射。资源不是存储对象。资源不是服务器用来处理存储对象的机制。资源是一个概念映射——服务器接收标识符（标识映射）并将其应用于其当前的映射实现（通常是特定于集合的深度树遍历和/或哈希表的组合）以查找当前负责的处理程序实现和处理程序实现然后根据请求内容选择适当的操作+响应。所有这些特定于实现的问题都隐藏在 Web 界面后面；只能通过 Web 界面访问的客户端无法假定它们的性质。</p><p>如上所述，一个资源可以有许多标识符。换句话说，当用于访问服务器时，可能存在两个或多个具有等效语义的不同 URI。也可能有两个 URI 导致在访问服务器时使用相同的机制，但这些 URI 标识两个不同的资源，因为它们的含义不同。语义是分配资源标识符和用表示填充这些资源的行为的副产品。服务器或客户端软件在任何时候都不需要知道或理解 URI 的含义——它们只是作为一个渠道，资源的创建者（人类命名机构）通过它可以将表示与由 URI 标识的语义相关联。 URI。换句话说，服务器上没有资源；只是通过资源定义的抽象接口提供答案的机制。这可能看起来很奇怪，但这就是使 Web 能够跨许多不同实现工作的本质。</p><p>尽管 URI 设计符合 REST 的标识符架构概念，但仅靠语法不足以强制命名机构根据资源模型定义自己的 URI。一种滥用形式是在超媒体响应表示引用的所有 URI 中包含标识当前用户的信息。当软件试图将 Web 视为分布式文件系统时，会发生与 REST 资源接口的另一个冲突。由于文件系统公开其信息的实现，因此存在将这些信息“镜像”到多个站点的工具，作为负载平衡和重新分配更接近用户的内容的一种手段。但是，它们之所以能够这样做，只是因为文件具有一组固定的语义（命名的字节序列），可以轻松复制。相比之下，尝试将 Web 服务器的内容镜像为文件将失败，因为资源接口并不总是与文件系统的语义匹配，并且因为数据和元数据都包含在表示的语义中并且对表示的语义很重要. 可以在远程站点复制 Web 服务器内容，但只能通过复制整个服务器机制和配置，或选择性地仅复制那些具有已知静态表示的资源。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>![image-20210913181829225](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913181829225.png)</p><p>REST 使用各种连接器类型（在<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#tab_5_2">表 5-2</a>中进行了总结）来封装访问资源和传输资源表示的活动。连接器为组件通信提供了一个抽象接口，通过提供清晰的关注点分离和隐藏资源和通信机制的底层实现来增强简单性。接口的通用性还实现了可替换性：如果用户只能通过抽象接口访问系统，则可以在不影响用户的情况下替换实现。由于连接器管理组件的网络通信，因此可以在多个交互之间共享信息，以提高效率和响应能力。所有 REST 交互都是无状态的。也就是说，每个请求都包含连接器理解请求所需的所有信息，独立于可能在它之前的任何请求。这种限制实现了四个功能：1）它消除了连接器在请求之间保留应用程序状态的任何需要，从而减少了物理资源的消耗并提高了可扩展性；2）它允许并行处理交互，而不需要处理机制理解交互语义；3）它允许中介孤立地查看和理解请求，这在服务动态重新排列时可能是必要的；并且，4) 它强制所有可能影响缓存响应可重用性的信息出现在每个请求中。主要的连接器类型是客户端和服务器。第三种连接器类型，缓存连接器，可以位于客户端或服务器连接器的接口上，以便保存对当前交互的可缓存响应，以便它们可以重用于以后请求的交互。REST 试图在缓存行为的透明性需求与高效使用网络的需求之间取得平衡，而不是假设始终需要绝对透明性。缓存能够确定响应的可缓存性，因为接口是通用的而不是特定于每个资源的。默认情况下，对检索请求的响应是可缓存的，而对其他请求的响应是不可缓存的。如果某种形式的用户身份验证是请求的一部分，或者如果响应指示不应共享它，则该响应只能由非共享缓存进行缓存。组件可以通过包含将交互标记为可缓存、不可缓存或仅在有限时间内可缓存的控制数据来覆盖这些默认值。解析器将部分或完整的资源标识符转换为建立组件间连接所需的网络地址信息。连接器类型的最后一种形式是隧道，它只是跨连接边界中继通信，例如防火墙或较低级别的网络网关。它被建模为 REST 的一部分而不是作为网络基础设施的一部分抽象出来的唯一原因是某些 REST 组件可能会从活动组件行为动态切换到隧道行为。主要示例是 HTTP 代理，它响应 CONNECT 方法请求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_71">71</a> ]切换到隧道，从而允许其客户端使用不允许代理的不同协议（例如 TLS）直接与远程服务器通信。当两端终止通信时，隧道消失。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>![image-20210913182732672](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913182732672.png)</p><p>用户代理使用客户端连接器发起请求并成为响应的最终接收者。最常见的示例是 Web 浏览器，它提供对信息服务的访问并根据应用程序需要呈现服务响应。源服务器使用服务器连接器来管理所请求资源的命名空间。它是其资源表示的最终来源，并且必须是旨在修改其资源值的任何请求的最终接收者。每个源服务器为其服务提供一个通用接口作为资源层次结构。资源实现细节隐藏在接口后面。中间组件既充当客户端又充当服务器，以便在可能的翻译、请求和响应的情况下进行转发。</p><p>![image-20210913183608285](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913183608285.png)</p><p>REST 的客户端-服务器关注点分离简化了组件实现，降低了连接器语义的复杂性，提高了性能调优的有效性，并增加了纯服务器组件的可扩展性。分层系统约束允许在通信中的各个点引入中介——代理、网关和防火墙——而不改变组件之间的接口，从而允许它们通过大规模共享缓存来协助通信转换或提高性能。REST 通过将消息约束为自描述性来实现中间处理：请求之间的交互是无状态的，标准方法和媒体类型用于指示语义和交换信息，响应明确指示可缓存性。由于组件是动态连接的，它们的排列和功能对于特定的应用程序操作具有类似于管道和过滤器样式的特性。尽管 REST 组件通过双向流进行通信，但每个方向的处理都是独立的，因此容易受到流转换器（过滤器）的影响。通用连接器接口允许基于每个请求或响应的属性将组件放置在流上。服务可以使用复杂的中介层次结构和多个分布式源服务器来实现。REST 的无状态特性允许每个交互独立于其他交互，无需了解整体组件拓扑，这是 Internet 规模架构不可能完成的任务，并允许组件充当目的地或中介，动态确定通过每个请求的目标。连接器只需要在其通信范围内知道彼此的存在，尽管出于性能原因，它们可能会缓存其他组件的存在和功能。</p><p>客户端连接器检查资源标识符，以便为每个请求选择适当的通信机制。例如，当标识符指示它是本地资源时，客户端可以被配置为连接到特定代理组件，可能充当注释过滤器的代理组件。同样，客户端可以配置为拒绝对某些标识符子集的请求。REST 不限制特定协议的通信，但它确实限制了组件之间的接口，因此限制了组件之间可能以其他方式进行的交互和实现假设的范围。</p><p>REST 组件交互以分层的客户端-服务器风格构建，但通用资源接口的附加约束为中介提供了可替代性和检查的机会。请求和响应具有远程调用风格的外观，但 REST 消息针对的是概念资源而不是实现标识符。已经进行了多次尝试将 Web 体系结构建模为分布式文件系统（例如 WebNFS）的形式或分布式对象系统 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_83">83</a> ]。然而，他们将各种 Web 资源类型或实现策略排除为“不有趣”，而实际上它们的存在使这些模型的假设无效。REST 运行良好，因为它不会将资源的实现限制为某些预定义的模型，允许每个应用程序选择最符合其自身需求的实现，并能够在不影响用户的情况下替换实现。向消费组件发送资源表示的交互方法与基于事件的集成 (EBI) 风格有一些相似之处。主要区别在于 EBI 样式是基于推送的。包含状态的组件（相当于 REST 中的源服务器）在状态更改时发出事件，无论是否有任何组件实际上对此类事件感兴趣或侦听此类事件。在 REST 风格中，消费组件通常会提取表示。尽管将其视为希望监控单个资源的单个客户端时效率较低，但 Web 的规模使得不受监管的推送模型不可行。</p><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><ul><li><p>围绕资源组织 API 设计</p><p>关注 Web API 公开的业务实体。如果可能，资源 URI 应基于名词（资源）而不是动词（对资源的操作）。资源不必基于单个物理数据项。避免创建简单地反映数据库内部结构的 API。REST 的目的是对实体以及应用程序可以对这些实体执行的操作进行建模。客户端不应暴露于内部实现。实体通常被组合成集合（订单、客户）。集合是与集合中的项目不同的资源，应该有自己的 URI。如有必要，在数据库和 Web API 之间引入一个映射层。这样，客户端应用程序就与底层数据库方案的更改隔离开来。</p><p>在 URI 中采用一致的命名约定。一般来说，对引用集合的 URI 使用复数名词会有所帮助。将集合和项目的 URI 组织成层次结构是一种很好的做法。这种方法有助于保持 Web API 的直观性。</p><p>还要考虑不同类型资源之间的关系以及如何公开这些关联。更好的解决方案是在 HTTP 响应消息的正文中提供指向相关资源的可导航链接。在更复杂的系统中，提供 URI 使客户端能够浏览多个级别的关系可能很诱人，例如<code>/customers/1/orders/99/products</code>. 但是，如果资源之间的关系在未来发生变化，这种复杂程度可能难以维护并且不灵活。相反，尽量保持 URI 相对简单。一旦应用程序拥有对资源的引用，就应该可以使用此引用来查找与该资源相关的项目。可以将前面的查询替换为 URI<code>/customers/1/orders</code>来查找客户 1 的所有订单，然后<code>/orders/99/products</code>查找该订单中的产品。</p><p>另一个因素是所有 Web 请求都会对 Web 服务器施加负载。请求越多，负载越大。因此，尽量避免暴露大量小资源的“健谈”Web API。此类 API 可能需要客户端应用程序发送多个请求以查找其所需的所有数据。相反，您可能希望对数据进行非规范化并将相关信息组合到可以通过单个请求检索的更大资源中。但是，您需要平衡这种方法与获取客户端不需要的数据的开销。检索大对象会增加请求的延迟并产生额外的带宽成本。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-string">orders</span> // <span class="hljs-string">Good</span><br><br><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-built_in">create-order</span> // <span class="hljs-string">Avoid</span><br></code></pre></td></tr></table></figure></li><li><p>根据 HTTP 方法定义 API 操作</p><p>HTTP 协议定义了许多为请求分配语义的方法。大多数 RESTful Web API 使用的常见 HTTP 方法是：</p><ul><li><strong>GET</strong>在指定的 URI 处检索资源的表示。响应消息的正文包含所请求资源的详细信息。</li><li><strong>POST</strong>在指定的 URI 处创建一个新资源。请求消息的正文提供了新资源的详细信息。请注意，POST 还可用于触发实际上不创建资源的操作。</li><li><strong>PUT</strong>创建或替换指定 URI 处的资源。请求消息的正文指定要创建或更新的资源。</li><li><strong>PATCH</strong>执行资源的部分更新。请求正文指定要应用于资源的一组更改。</li><li><strong>DELETE</strong>删除指定 URI 处的资源。</li></ul><p>特定请求的效果应取决于资源是集合还是单个项目。</p><ul><li>POST 请求创建一个资源。服务器为新资源分配一个 URI，并将该 URI 返回给客户端。POST 请求还可用于将数据提交到现有资源进行处理，而无需创建任何新资源。</li><li>PUT 请求创建资源<em>或</em>更新现有资源。客户端指定资源的 URI。请求正文包含资源的完整表示。如果具有此 URI 的资源已存在，则会替换它。否则，如果服务器创建一个新资源。服务器可能支持更新，但不支持通过 PUT 创建。是否支持通过 PUT 创建取决于客户端是否可以在资源存在之前有意义地为其分配 URI。如果没有，则使用 POST 创建资源并使用 PUT 或 PATCH 进行更新。</li><li>PATCH 请求对现有资源执行<em>部分更新</em>。客户端指定资源的 URI。请求正文指定要应用于资源的一组<em>更改</em>。这比使用 PUT 更有效，因为客户端只发送更改，而不是资源的整个表示。从技术上讲，如果服务器支持，PATCH 还可以创建新资源（通过指定对“空”资源的一组更新）。</li></ul><p>PUT 请求必须是幂等的。如果客户端多次提交相同的 PUT 请求，结果应该始终相同（相同的资源将被修改为相同的值）。POST 和 PATCH 请求不保证是幂等的。</p></li><li><p>符合 HTTP 语义</p><p>JSON 合并补丁稍微简单一些。补丁文档与原始 JSON 资源具有相同的结构，但仅包含应更改或添加的字段子集。此外，可以通过<code>null</code>在补丁文档中指定字段值来删除字段。（这意味着如果原始资源可以具有显式空值，则合并补丁不适合。）JSON 合并补丁的媒体类型是<code>application/merge-patch+json</code>.如果原始资源可以包含显式空值，则不适合合并补丁，因为<code>null</code>补丁文档中的特殊含义。此外，补丁文档没有指定服务器应用更新的顺序。这可能重要也可能无关紧要，具体取决于数据和域。<a href="https://tools.ietf.org/html/rfc6902">RFC 6902 中</a>定义的 JSON 补丁更加灵活。它将更改指定为要应用的操作序列。操作包括添加、删除、替换、复制和测试（以验证值）。JSON 补丁的媒体类型是<code>application/json-patch+json</code>.</p><p>如果在向客户端发送响应之前等待完成，可能会导致无法接受的延迟。如果是这样，请考虑使操作异步。返回 HTTP 状态代码 202（已接受）以指示请求已被接受进行处理但尚未完成。您应该公开一个返回异步请求状态的端点，以便客户端可以通过轮询状态端点来监视状态。在 202 响应的 Location 标头中包含状态端点的 URI。如果客户端向此端点发送 GET 请求，则响应应包含请求的当前状态。或者，它还可以包括预计完成时间或取消操作的链接。</p></li><li><p>使用 HATEOAS 启用导航到相关资源</p><p>REST 背后的主要动机之一是应该可以在不需要 URI 方案的先验知识的情况下导航整个资源集。每个 HTTP GET 请求都应返回通过响应中包含的超链接查找与所请求对象直接相关的资源所必需的信息，并且还应提供描述对这些资源中的每一个可用的操作的信息。这一原则被称为 HATEOAS，或作为应用程序状态引擎的超文本。该系统实际上是一个有限状态机，对每个请求的响应都包含从一种状态转移到另一种状态所需的信息；不需要其他信息。</p><p>返回的链接集可能会更改，具体取决于资源的状态。这就是超文本作为“应用程序状态引擎”的含义。</p></li></ul><p>REST 要求客户端向服务器发出请求，以便检索或修改服务器上的数据。一个请求通常包括：</p><ul><li>一个 HTTP 动词，它定义了要执行的操作类型</li><li>一个<em>标头</em>，它允许客户端传递有关请求的信息</li><li>资源的路径</li><li>包含数据的可选消息正文</li></ul><p>我们在请求中使用了 4 个基本的 HTTP 动词来与 REST 系统中的资源进行交互：</p><ul><li>GET — 检索特定资源（通过 id）或资源集合</li><li>POST — 创建一个新资源</li><li>PUT — 更新特定资源（通过 id）</li><li>DELETE — 通过 id 删除特定资源</li></ul><p>请求必须包含指向应该对其执行操作的资源的路径。在 RESTful API 中，应该设计路径以帮助客户端了解正在发生的事情。路径的第一部分应该是资源的复数形式。<code>fashionboutique.com/customers/223/orders/12</code>即使您以前从未见过这条特定路径，like 路径也很清楚它指向的内容，因为它是分层的和描述性的。我们可以看到，我们正在<code>id</code>为<code>id</code>223的客户访问12的订单。路径应包含定位资源所需的特定程度所需的信息。在引用资源列表或集合时，并不总是需要添加<code>id</code>. 例如，对<code>fashionboutique.com/customers</code>路径的 POST 请求不需要额外的标识符，因为服务器将为<code>id</code>新对象生成一个。如果我们尝试访问单个资源，则需要<code>id</code>在路径后附加。例如： <code>GET fashionboutique.com/customers/:id</code>— 检索<code>customers</code>资源中<code>id</code>指定的项目。 <code>DELETE fashionboutique.com/customers/:id</code>— 删除<code>customers</code>资源中<code>id</code>指定的项目。</p><p>人类应该能够轻松阅读和构建 URL。这有助于发现并简化在没有良好支持的客户端库的平台上的采用。除了友好的 URL 之外，可以移动或重命名的资源应该公开一个包含唯一稳定标识符的 URL。可能需要与服务交互以从资源的友好名称中获取稳定的 URL，例如某些服务使用的“/my”快捷方式。稳定标识符不需要是 GUID。操作必须尽可能使用正确的 HTTP 方法，并且必须遵守操作幂等性。HTTP 方法通常称为 HTTP 动词。</p><p>随着数据的增长，集合也在增长。规划分页对于所有服务都很重要。因此，当有多个页面可用时，序列化有效负载必须包含下一个页面的不透明 URL。集合查询的结果可以根据属性值进行排序。该属性由*$orderBy<em>查询参数的值确定。如果服务不支持按</em>$orderBy*表达式中命名的属性进行排序，则服务必须以响应不支持的请求部分中定义的错误消息进行响应。</p><p>如果调用者请求在功能允许列表中发现不受支持的功能，服务必须提供错误响应。错误响应必须是来自 4xx 系列的 HTTP 状态代码，指示无法满足请求。</p><p>由于 REST 专门针对分布式信息系统，因此它将应用程序视为信息和控制替代方案的内聚结构，用户可以通过它来执行所需的任务。小粒度或中粒度消息用于控制语义，但大部分应用程序工作是通过包含完整资源表示的大粒度消息完成的。请求语义的最常见形式是检索资源的表示（例如，HTTP 中的“GET”方法），通常可以将其缓存以供以后重用。REST 将所有控制状态集中到响应交互而接收到的表示中。目标是通过消除服务器在当前请求之外保持对客户端状态的感知的任何需要来提高服务器可伸缩性。An application’s state is therefore defined by its pending requests, the topology of connected components (some of which may be filtering buffered data), the active requests on those connectors, the data flow of representations in response to those requests, and the processing of those representations as they are received by the user agent.只要没有未完成的请求，应用程序就会达到稳定状态；即，它没有未决请求，并且对其当前请求集的所有响应都已完全接收或接收到可以将它们视为表示数据流的程度。对于浏览器应用程序，此状态对应于“网页”，包括主要表示和辅助表示，例如内嵌图像、嵌入的小程序和样式表。应用稳态的重要性体现在它们对用户感知性能和网络请求流量突发性的影响中。浏览器应用程序的用户感知性能取决于稳态之间的延迟：在一个网页上选择超媒体链接和为下一个网页呈现可用信息之间的时间段。因此，浏览器性能的优化集中在减少这种通信延迟上。由于基于 REST 的架构主要通过资源表示的传输进行通信，因此延迟可能会受到通信协议设计和表示数据格式设计的影响。在接收到响应数据时增量呈现响应数据的能力取决于媒体类型的设计和每个表示中的布局信息（内嵌对象的视觉尺寸）的可用性。</p><p>一个有趣的观察是最有效的网络请求是不使用网络的请求。换句话说，重用缓存响应的能力可显着提高应用程序性能。尽管由于查找开销，使用缓存会为每个单独的请求增加一些延迟，但即使是一小部分请求导致可用缓存命中，平均请求延迟也会显着降低。应用程序的下一个控制状态驻留在第一个请求资源的表示中，因此获得第一个表示是一个优先事项。因此，REST 交互通过“先响应后思考”的协议得到改进。换句话说，一个需要每个用户操作多次交互的协议，以便在发送内容响应之前执行诸如协商功能功能之类的事情，将比 （一种协议，它首先发送最有可能是最佳的，然后在第一个响应不令人满意时为客户端提供一个可供选择的列表。） 感知速度更慢。应用程序状态由用户代理控制和存储，并且可以由来自多个服务器的表示组成。除了将服务器从存储状态的可扩展性问题中解放出来之外，这还允许用户直接操作状态（例如，Web 浏览器的历史记录），预测该状态的变化（例如，链接映射和表示的预取），并跳转从一个应用程序到另一个应用程序（例如，书签和 URI 条目对话框）。因此，模型应用程序是一个引擎，通过检查和选择当前表示集合中的替代状态转换，从一个状态移动到下一个状态。毫不奇怪，这与超媒体浏览器的用户界面完全匹配。但是，该样式并不假定所有应用程序都是浏览器。事实上，应用程序的详细信息通过通用连接器接口对服务器隐藏，因此用户代理同样可以是为索引服务执行信息检索的自动化机器人，寻找符合特定标准的数据的个人代理，或维护Spider 忙于在信息中查找损坏的引用或修改的内容 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_39">39</a> ]。</p><p>REST 确定的 HTTP 中的关键问题领域包括规划新协议版本的部署、将消息解析与 HTTP 语义和底层传输层 (TCP) 分开、区分权威和非权威响应、细粒度控制缓存，以及无法自我描述的协议的各个方面。REST 还被用于对基于 HTTP 的 Web 应用程序的性能进行建模，并预测诸如持久连接和内容协商等扩展的影响。最后，REST 已被用于将标准化 HTTP 扩展的范围限制在适合架构模型的范围内，而不是允许滥用 HTTP 的应用程序同样影响标准。</p><p>REST 的主要目标之一是支持在已经部署的架构中逐步和分散部署变更。通过引入版本控制要求和规则来扩展协议的每个语法元素，对 HTTP 进行了修改以支持该目标。HTTP 请求语义由请求方法名称表示。只要可以在客户端、服务器和它们之间的任何中介之间共享一组标准化的语义，就允许方法扩展。不幸的是，早期的 HTTP 扩展，特别是 HEAD 方法，使得 HTTP 响应消息的解析依赖于了解请求方法的语义。这导致了部署矛盾：如果接收方需要知道方法的语义才能被中介安全转发，那么在部署新方法之前必须更新所有中介。通过将解析和转发 HTTP 消息的规则与与新 HTTP 协议元素关联的语义分离，此部署问题已得到解决。例如，HEAD 是唯一一种方法，Content-Length 头字段除了表示消息体长度之外，还有其他意义，并且没有新的方法可以改变消息长度的计算。GET 和 HEAD 也是条件请求头字段具有缓存刷新语义的唯一方法，而对于所有其他方法，它们具有前提条件的含义。同样，HTTP 需要一个通用规则来解释新的响应状态代码，以便可以部署新的响应而不会显着损害旧客户端。因此，我们扩展了规则，即每个状态代码都属于由其三位十进制数的第一位表示的类别：100-199 表示消息包含临时信息响应，200-299 表示请求成功，300 -399 表示请求需要重定向到另一个资源， 400-499 表示客户端犯了一个不应重复的错误， 500-599 表示服务器遇到了错误，但客户端可能会得到更好的稍后（或通过其他服务器）响应。如果接收者不理解给定消息中状态代码的特定语义，那么他们必须像对待它的类中的 x00 代码一样对待它。</p><p>REST 将组件之间的消息限制为自描述的，以支持交互的中间处理。由于 REST 试图在对高效、低延迟行为的需求与对语义透明缓存行为的需求之间取得平衡，因此 HTTP 允许应用程序确定缓存要求而不是将其硬编码到协议本身中是至关重要的。协议要做的最重要的事情是完整准确地描述正在传输的数据，这样任何应用程序都不会被愚弄，认为它只有一件事，而实际上它有其他东西。HTTP/1.1 通过添加 Cache-Control、Age、Etag 和 Vary 标头字段来实现这一点。</p><p>所有资源都将请求（由方法、标识符、请求头字段，有时是表示）映射到响应（由状态代码、响应头字段，有时是表示）。</p><p>HTTP 不支持回写缓存。HTTP 缓存不能假设通过它写入的内容与从对该资源的后续请求中可检索的内容相同，因此它无法缓存 PUT 请求正文并将其重用于以后的 GET 响应。这条规则有两个原因：1) 元数据可能在幕后生成，2) 无法从 PUT 请求中确定对以后 GET 请求的访问控制。但是，由于使用 Web 的写入操作极为罕见，因此缺少回写缓存不会对性能产生重大影响。</p><p>Cookie 还违反了 REST，因为它们允许在没有充分识别其语义的情况下传递数据，从而成为安全和隐私方面的问题。cookie 与 Referer [sic] 标头字段的组合可以在用户在站点之间浏览时对其进行跟踪。因此，Web 上基于 cookie 的应用程序永远不会可靠。应该通过匿名身份验证和真正的客户端状态来完成相同的功能。使用上下文设置 URI 而不是 cookie 的明智使用可以更有效地实现涉及偏好的状态机制，其中明智意味着每个状态一个 URI，而不是由于嵌入了用户 ID 的无限数量的 URI。理想的 ReSTful 服务允许客户端（可能不在浏览器中）<em>在一个请求中</em>执行任何需要的任务；因为执行此操作所需的完整状态由客户端保存，而不是由服务器保存。由于客户端完全控制状态，它可以自己创建状态（如果这是合法的），并且只与 API 对话以“完成”。需要 cookie 会使这变得困难。对于浏览器以外的客户端，与查询参数、普通请求头或请求正文相比，管理 cookie 是一个相当大的不便。另一方面，在浏览器中，使用 cookie 可以让很多事情变得更简单。</p><h1 id="Web成熟度模型"><a href="#Web成熟度模型" class="headerlink" title="Web成熟度模型"></a>Web成熟度模型</h1><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img54.png" alt="img54"></p><p>万维网的技术形成了网络服务的技术栈。当人们设计 Web 服务时，他们倾向于从堆栈底部选择一些技术。您可以通过查看他们是选择零、一项、两项还是三项技术来粗略地判断他们。当我说您从堆栈中选择时，我并不是说您会找到根本不使用 HTTP 或没有 URI 的 Web 服务。我的意思是有一类 Web 服务并没有真正获得 URI 或没有真正获得 HTTP。该模型之所以有用，是因为这三种技术是 RESTful 约束的真实实现。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/overview.png" alt="overview"></p><p>我要强调的是，RMM 虽然是思考 REST 元素的好方法，但并不是 REST 本身级别的定义。Roy Fielding 已经明确表示，<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">级别 3 RMM 是 REST 的先决条件</a>。 RMM 的有用之处在于它提供了一个很好的逐步方式来理解rest背后的基本思想。因此，我认为它是帮助我们了解概念的工具，而不是应该在某种评估机制中使用的东西。我认为我们还没有足够的例子来真正确定 restful 方法是集成系统的正确方法，我确实认为这是一种非常有吸引力的方法，并且在大多数情况下我会推荐这种方法。</p><p>该模型的吸引力在于它与常见设计技术的关系。</p><ul><li>级别 1 通过使用分而治之，将大型服务端点分解为多个资源来解决处理复杂性的问题。</li><li>级别 2 引入了一组标准的动词，以便我们以相同的方式处理类似的情况，消除不必要的变化。</li><li>级别 3 引入了可发现性，提供了一种使协议更具自文档性的方法。</li></ul><hr><ul><li><p>0级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img55.png" alt="img55"></p><p>如果您查看 XML-RPC 服务或典型的 SOAP 服务（例如 Google 现已弃用的搜索服务），您会看到一些看起来很像 C 库的东西。有很多函数，有时用句点命名。所有这些功能都可以通过向一个 URI 发送 POST 请求来访问。这些网站很烦人，因为它们实际上并不在网络上。有一个小的基于网络的窥视孔进入其他宇宙，你只能通过窥视孔传递消息来与另一个宇宙交流。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level0.png" alt="level0"></p><p>该模型的出发点是使用 HTTP 作为远程交互的传输系统，但不使用任何网络机制。本质上，您在这里所做的是使用 HTTP 作为您自己的远程交互机制的隧道机制，通常基于<a href="http://www.eaipatterns.com/EncapsulatedSynchronousIntegration.html">Remote Procedure Invocation</a>。</p><p>它只是来回传递普通的旧 XML (POX)。如果您使用 SOAP 或 XML-RPC，它的机制基本相同，唯一的区别是您将 XML 消息包装在某种信封中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>The server then will return a document giving me this information<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">reason</span>&gt;</span>Slot not available<span class="hljs-tag">&lt;/<span class="hljs-name">reason</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>1级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img56.png" alt="img56"></p><p>为每个单独的事物提供了一个 URI。如果我们以一级思维回到 XML-RPC 示例，我们可以说它有什么问题。只有一种资源，这个黑匣子。我们看到了解决方案：将复杂性从黑匣子中取出并制造更多资源。将 Web 服务拆分为其分子组件，并为每个分子提供自己的 URI。</p><p>Web 的强大之处在于它为您提供了将任务的固有复杂性拆分为小块的工具。URI 允许您为系统中的每个对象命名。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level1.png" alt="level1"></p><p>在 RMM 中实现 Glory of Rest 的第一步是引入资源。因此，现在我们不再向单个服务端点发出所有请求，而是开始与单个资源进行对话。</p><p>回复携带相同的基本信息，但现在每个时隙都是可以单独寻址的资源。</p><p>使用特定资源预订约会意味着发布到特定时段。</p><p>对于像我这样的对象人来说，这就像特定对象的概念。我们不是在以太中调用某个函数并传递参数，而是在一个特定对象上调用一个方法，为其他信息提供参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /doctors/mjones HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span>/&gt;</span><br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img58.png" alt="img58"></p><p>在 HTTP 层面，Web 的主要进步在于，虽然它可以处理任何类型的操作，但它将读取操作、想要获取数据的操作分开，并对其进行特殊处理。</p><p>在 80 年代和 90 年代，“get”与 FTP、Gopher、WAIS、Archie 和 Comp-U-Store 的含义截然不同。取消引用 FTP URI 是一个巨大的音乐数字。当所有这些协议都转移到 Web 上，并且所有这些信息都获得了 URI 时，突然间“get”对所有这些协议都意味着同样的事情。URI 的意思是“那个”，HTTP 方法的意思是“给我”。这里是堆栈的 URI 部分与 HTTP 部分相遇的地方。RFC 2616 赋予 GET 特定含义。GET 请求必须是安全的和幂等的，等等。GET 的确切含义并不重要。重要的是 GET 对其含义有限制，当存在限制时，您可以围绕它们进行优化：条件 GET、部分 GET、可靠性、可缓存性等等。这就是统一接口的价值。一级服务不遵守这些限制。</p><p>您发出的每个 XML-RPC 请求都使用 POST。HTTP 标准对 POST 没有任何限制。您可能正在获取数据，您可能正在修改数据，但无法知道。HTTP POST 的意思是“随便！” 您无法对安全或幂等请求应用优化，因为无法知道哪些请求满足这些要求。</p><p>我们使用的 Web 仅使用 GET 和 POST，因为它们是 HTML 4 支持的唯一方法。但大多数 RESTful 更进一步，将 PUT 和 DELETE 从 POST 中分离出来。我想你可能对这场争论很熟悉。关于这些方法的价值存在争论，但这是关于成熟启发式的第二级争论，而不是关于谁更纯粹或更实用的争论。这些方法或任何方法的论据是，如果我们将它们从 POST 中分离出来，它们开始意味着除了“随便！”之外的其他内容。我们可以围绕它们进行优化。</p><p>缺点是，当您添加 HTTP 方法时，您会限制可以理解您的服务语义的客户端的范围</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level2.png" alt="level2"></p><p>我在 0 级和 1 级的所有交互中都使用了 HTTP POST 动词，但有些人使用 GET 代替或另外使用。在这些级别上并没有太大区别，它们都被用作隧道机制，允许您通过 HTTP 隧道进行交互。级别 2 远离此，使用 HTTP 动词尽可能接近它们在 HTTP 本身中的使用方式。</p><p>在第 2 级，对这样的请求使用 GET 是至关重要的。 HTTP 将 GET 定义为安全操作，即它不会对任何事物的状态进行任何重大更改。这使我们能够以任何顺序安全地多次调用 GET，并且每次都获得相同的结果。这样做的一个重要结果是，它允许请求路由中的任何参与者使用缓存，这是使 Web 表现良好的关键因素。HTTP 包括各种支持缓存的措施，可供通信中的所有参与者使用。通过遵循 HTTP 规则，我们能够利用该功能.</p><p>即使我使用与级别 1 相同的帖子，远程服务的响应方式也存在另一个显着差异。如果一切顺利，该服务将回复 201 的响应代码，以表明世界上有新资源。201 响应包含一个带有 URI 的位置属性，客户端可以使用该 URI 获取该资源在未来的当前状态。此处的响应还包括该资源的表示，以立即为客户端节省额外的调用。</p><p>此响应的重要部分是使用 HTTP 响应代码来指示出现问题。在这种情况下，409 似乎是一个不错的选择，表明其他人已经以不兼容的方式更新了资源。与使用 200 的返回码但包括错误响应不同，在级别 2 中，我们明确地使用了某种类似这样的错误响应。由协议设计者决定使用什么代码，但如果出现错误，应该有一个非 2xx 响应。级别 2 介绍使用 HTTP 动词和 HTTP 响应代码。</p><p>这里有一种矛盾。REST 倡导者谈论使用所有 HTTP 动词。他们还通过说 REST 试图从网络的实际成功中学习来证明他们的方法是合理的。但是万维网在实践中并没有太多地使用 PUT 或 DELETE。网络实践所支持的关键元素是安全（例如 GET）和非安全操作之间的强分离，以及使用状态代码来帮助传达您遇到的错误类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 409 Conflict<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>3级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img66.png" alt="img66"></p><p>如果您嵌入实际的 URI，您的客户可以更容易地从一种资源移动到另一种资源。撇开那些不仅可以使用它们的 URI 很烦人的事实，这种设计在客户端和这个特定的 Web 服务之间创建了耦合。您必须编写无法重用的自定义客户端代码。客户端行为由 Web 服务当前提供的文档编程，而不是由过去决定的内容编程。资源之间的连接是一种数据形式，它们应该与其余数据一起在文档中进行描述。让您的客户专注于查看该文档并决定下一步做什么。不是内化关于您将数据放在网络上的位置的特定规则。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level3.png" alt="level3"></p><p>每个时间片都有一个链接元素，其中包含一个 URI 来告诉我们如何预约。超媒体控制的重点在于它们告诉我们下一步可以做什么，以及我们需要操纵的资源的 URI 来完成它。我们不必知道在哪里发布我们的预约请求，响应中的超媒体控件告诉我们如何去做。</p><p>超媒体控制的一个明显好处是它允许服务器在不破坏客户端的情况下更改其 URI 方案。只要客户端查找“addTest”链接 URI，服务器团队就可以处理除初始入口点之外的所有 URI。</p><p>另一个好处是它可以帮助客户端开发人员探索协议。这些链接为客户开发人员提供了下一步可能的提示。它没有提供所有信息：“self”和“cancel”控件都指向同一个 URI——它们需要确定一个是 GET，另一个是 DELETE。但至少它为他们提供了一个起点，让他们了解更多信息并在协议文档中寻找类似的 URI。</p><p>同样，它允许服务器团队通过在响应中放置新链接来宣传新功能。如果客户端开发人员密切关注未知链接，这些链接可能会触发进一步探索。</p><p>关于如何表示超媒体控件没有绝对的标准。遵循 ATOM ( <a href="https://tools.ietf.org/html/rfc4287">RFC 4287</a> )指出，众所周知<a href="http://www.iana.org/assignments/link-relations.html">的链接关系</a>的定义是<a href="http://www.iana.org/assignments/link-relations.html">链接关系注册表</a>。这些仅限于 ATOM 所做的事情，它通常被视为 3 级的领导者。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br>But the response has a new element<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/5678&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: http://royalhope.nhs.uk/slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/addTest&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment/tests&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;self&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/changeTime&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/doctors/mjones/slots?date=20100104&amp;status=open&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/updateContactInfo&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/patients/jsmith/contactInfo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/help&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/help/appointment&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Thomas Fielding.Architectural Styles and the Design of Network-based Software Architectures.2000</a></p><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Wiki:Representational state transfer</a></p><p><a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html">Leonard Richardson.Justice Will Take Us Millions Of Intricate Moves.2008</a></p><p><a href="https://martinfowler.com/articles/richardsonMaturityModel.html#level0">Martin Fowler.Richardson Maturity Model.2010</a></p><p><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md">Microsoft REST API Guidelines</a></p><p><a href="https://cloud.google.com/apis/design">Google Cloud API 设计指南</a></p><p><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">Ed Price - MSFT.RESTful web API design.2018</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc5789">RFC5789</a></p><p><a href="https://zh.wikipedia.org/wiki/XML-RPC">Wiki:XML-RPC</a></p><p><a href="http://xmlrpc.com/">XML-RPC Home</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">Wiki:SOAP</a></p><p><a href="https://web.archive.org/web/20080915090248/http://webservices.xml.com/pub/a/ws/2001/04/04/soap.html">A Brief History of SOAP</a></p><p><a href="https://www.w3.org/TR/soap/">W3C:SOAP</a></p>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD-002-日志实践总结</title>
    <link href="/2021/09/08/DDD-002-%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <url>/2021/09/08/DDD-002-%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Domain Driven Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-002-MVC</title>
    <link href="/2021/08/26/SAC-002-MVC/"/>
    <url>/2021/08/26/SAC-002-MVC/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本科在校期间（不确定现在是否也是这样，更不确定是否所有学校都是如此），虽然学生通过操作系统、计算机网络等等科目接触到了许许多多的软件架构，例如期末考试一定会去背的7层 OSI 网络协议，结果老师一开始就告诉你事实协议是4层的 TCP/IP 协议，最后学的是5层协议。这巨大的分层架构摆在眼前，仍然会有很多学生被“架构”二字劝退。</p><p>之所以以 MVC 架构开头，是因为当时出去面试，很多面试官都会问一句：“什么是 MVC？”（怀念面试还没有那么内卷的时代）。大多数人是怎么回答的呢？或者说，甚至连面试官都是怎么看待 MVC 架构的呢？下面是摘抄自<a href="https://www.ruanyifeng.com/blog/2007/11/mvc.html">阮一峰</a>老师微博的内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。<br><br><span class="hljs-bullet">*</span> 最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。<br><br><span class="hljs-bullet">*</span> 中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。<br></code></pre></td></tr></table></figure><p>这是正确的吗？下面是维基百科关于 MVC 架构的介绍：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。<br><br><span class="hljs-bullet">*</span> 模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。“Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比如：观察者模式）<br><br><span class="hljs-bullet">*</span> 视图（View）能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。<br><br><span class="hljs-bullet">*</span> 控制器（Controller）起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。<br></code></pre></td></tr></table></figure><p>好像看起来这两个定义不是那么相同。那么，我想问的是，为什么会有这些差异？究竟什么是业务？维基百科所提到的刷新机制是什么？凡此种种，让我尝试给出 MVC 的严谨定义，再着眼于繁杂的工程领域实现。</p><h2 id="1979-THING-MODEL-VIEW-EDITOR"><a href="#1979-THING-MODEL-VIEW-EDITOR" class="headerlink" title="1979 THING-MODEL-VIEW-EDITOR"></a>1979 THING-MODEL-VIEW-EDITOR</h2><p>我们从 wiki 公认的最早提出 MVC 概念的文章《THING-MODEL-VIEW-EDITOR》，以及同一时期的书籍《Smalltalk-80: The Interactive Programming Environment》出发。</p><p>在 Smalltalk-80 系统早期版本的用户界面往往由四种元素组成：文本、文本列表（菜单）、按钮和图形（位图或像素图）。这些元素具有三种基本的用户交互方式：浏览、查看和编辑。故由 Smalltalk-80 系统提出的 MVC ，其核心目标就是定义可共享的用户界面组件。换句话说，MVC 架构就是一种系统模块化，它具有模块化的好处：将功能模块相互隔离，使其应用程序设计人员更容易了解和修改每个特定模块，而无需了解其他模块的一切。</p><p>MVC 将系统分解为三部分：</p><ul><li><p>model</p><p>model 是对现实世界中的事物以数据形式在计算机系统中的抽象表示，包括数据集合以及处理这些数据所需的方法，不包含信息在屏幕上显示的信息。model 是系统中实际完成工作的那些组件（<a href="#model_work">什么工作？</a>）。model 提供一种机制，使 view/controller 可以注册其中，当此 model 的状态发生变化时，可以根据注册信息广播消息（观察者模式）。</p></li><li><p>view</p><p>view 是 model 的视觉展示，它突出 model 的某些属性并抑制其他属性。view 通过请求从 model 中获取展示所需的数据，或者更新 model 中的数据。所有这些请求都包含在 model 所表示的抽象含义中，因此 view 必须知道它所代表的 model 的属性语义（这里虽然表明 model 具有业务含义，但一是 MVC 并没有将业务与技术区分开，二是 MVC 并没有从业务上做过模块划分，它只按照技术领域去做模块划分）。 </p></li><li><p>editor/controller</p><p>controller 是用户和系统之间的链接。它为用户提供<strong>输入入口</strong>，包含其关联 model 和 view 与输入设备（键盘、鼠标、时间等）之间的接口，controller 的工作就是处理 model 的控制或操作（编辑）功能。<strong>注意，controller 不是 view 的补充，view 永远不知道用户输入，例如鼠标操作</strong>。可以通过 controller 将消息发送到 view，用来再现用户命令序列。 controller 还处理与其他 controller 的调度交互。</p><p>editor 是一种特殊的 controller，它允许用户修改视图显示的信息。</p></li></ul><p>view 与 controller 一一对应，每个 controller 只对应一个 model，但一个 model 可能与许多 view/controller 对应。view 和 controller 需要明确地了解它们对应的 model，但 model 不应该知道他们的 view 和 controller。其实从技术的角度讲，model、view、controller 在划分清晰的前提下，是具有可插拔特性的。但是，这里之所以要强调 model 与 view/controller 之间的这种对应关系，是因为 model 承载着业务上的逻辑。</p><p><img src="/images/SAC/MVC/mvc_flow_chart1.png"></p><p>MVC 有以下几种交互场景：</p><ul><li><p>显示数据：view 直接向 model 查询最新数据，经过过滤后以适当的形式向用户展示。</p></li><li><p>用户输入：用户采取一些输入动作，通过 controller 通知 model 执行相应的操作，这有可能会改变 model 的状态。当 model 状态改变时，会向在该 model 中注册的 view/controller 广播它已经改变状态的通知。 然后，收到通知的 view 可以查询 model 有关其新状态的数据，并向用户显示。 </p></li></ul><p>这产生了几个重要问题：</p><ul><li><p>消息广播</p><p>一个 model 绑定了多组 view/controller，但是每次用户的输入动作，都只可能通过一个 controller 传递到 model，所以，当 model 的状态改变时，所涉及的所有 view/controller 都需要感知到这些变化，以及时应对。</p></li><li><p>读写分离</p><p>很显然，MVC 天生就带着读写分离的味道。参考 CQRS，view 直接访问 model 获取最新数据，以用来显示，并且，view 是永远不关心用户具体输入行为的。controller 负责用户输入行为，即增加、删除、修改等操作，在某些场景下，用户的输入在到达了 controller 后，不需要更新 model，就会直接返回给 view 用于展示。</p></li></ul><p>可以看出，MVC 是一种解决用户控制复杂大型数据集问题的通用方案，让用户可以从多个角度控制他们的数据。MVC 有利于数据封装和代码复用。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>随着软件不断发展，UI设计、交互方式、网络协议的不断创新，web 的普及等等事件的发生，传统的 MVC 架构已经不能很好的支持应用的发展，故出现了各种 MVC 变种。</p><p><img src="/images/SAC/MVC/mvc1.png"></p><p><img src="/images/SAC/MVC/mvc2.png"></p><p><img src="/images/SAC/MVC/mvc_flow_chart2.png"></p><p>每个版本的 MVC 结构，虽稍有不同，但都遵循其核心思想–分治。</p><p>从数据访问模式的角度，MVC 进行了读写分离。其中 view 负责数据展示。controller 通过连接 view 与 model 处理用户请求。view 从 model 初获取最新数据（无论是否经过 controller）。</p><p>从功能职责的角度，MVC 明确了数据访问与处理的一般流程，从数据存储、数据处理、请求处理、数据展示这一链路出发，将系统划分为 model、view、controller 三块。这不仅简化了项目结构，使得后续开发类似项目（如 CRUD 类型的管理平台）有迹可循，而且明确了团队分工，降低企业成本，增加沟通效率。</p><p>我们再一次对 MVC 进行定义：</p><ul><li><p><strong>model–领域逻辑</strong></p><p>与之前基本一致，model 是利用面向对象方法，将现实世界问题域中的对象抽象为应用程序对象。在这些抽象对象中封装了业务属性和业务逻辑（需要注意的是，这里并不是说一定要用充血模型甚至胀血模型，因为可以将数据和方法封装在不同的对象中）。<a name="model_work">model 管理与数据相关的所有任务：数据验证、控制会话状态、控制数据源结构（数据库）。</a>  model 拥有与不同数据源交互的方法。</p><p>与之对应的，负责应用程序逻辑的开发人员定义为开发角色，他们负责数据查询、验证、处理等。</p></li><li><p><strong>view–展示逻辑</strong></p><p>与之前基本一致，view 是 model 的外在表现。view 控制数据的显示方式。具体地说，view 负责用户图形界面管理，包括所有表单、按钮、图形元素和所有其他 HTML 元素。通过将应用程序的设计与应用程序的实现相分离，当设计人员决定通过更改表格来更改应用程序界面时，将大大降低出错的风险。 同时，开发人员的工作也大大减少，因为他不再需要查看 HTML 代码元素、设计元素和图形元素。一个 model 可以对应一个或者多个 view。</p><p><strong>与之前不同的是，部分系统的实现中，view 还负责与用户的交互方式。</strong>在这些系统中，view 具有与外界交互的功能，管理着应用系统与外界的接口。一方面，view 为外界提供输入功能，并触发业务逻辑运行（这里若是换一种理解方式，仅仅将 view 视为用户行为事件的触发器或低级事件，在做出简单处理后向 controller 发送高级事件；而 controller 则提供了处理该高级事件的接口，并作出响应，这样就没有了所带来的职责混淆的问题，但无论如何，对于 view 和 controller 职责的定义在此没有发生变化）；另一方面，view 又将业务逻辑运行的结果以某种形式显示给外界。</p><p>与之对应的，负责应用程序外观和展示的开发人员定义为设计角色，他们负责显示从开发角色处获取的数据。</p></li><li><p><strong>controller–应用程序逻辑</strong></p><p>与之前基本一致，controller 管理 view 和 model 之间的关系。controller 负责响应用户请求，与 model 交互并决定应该由哪个 view 显示结果，即将 view 传递的事件转换为对 model 的操作。controller 还负责为用户提供输入入口。</p><p><strong>与之前不同的是，部分系统的实现中，controller 使用 view 传输进来的外部信息，对 model 进行更新；同时，model 的更新与修改也将通过 controller 来通知 view，从而保持 view 与 model 的一致。</strong></p><p>与之对应的，负责前两个角色的工作粘合起来的开发人员定义为集成角色。</p></li></ul><p>有几个重要问题探讨一下。</p><ul><li><p>为什么有些系统的 view 模块，即负责数据展示，又负责提供用户输入入口？按照一开始的设计，这本应该由 view 和 controller 分别负责。</p><p>以 java web 项目为例，无论是前后端分离的项目，还是由 jsp 这类框架动态生成的 html 页面的项目，用户在这种 B/S 架构（留坑）下，读写操作所交互的对象都是浏览器页面。用户没有与后端系统直接交互的手段，用户的所有操作都需要经由浏览器页面，向后端系统发送 http 请求，再由后端系统返回给浏览器的 http 响应，向用户展示最新数据。这样一来，view 和 controller 的职责范围，就有了微妙变化：</p><ul><li>view 不仅负责之前所讲的数据展示，还负责向用户提供输入接口。</li><li>controller 依然提供输入接口，但这是与 view 提供的相关机制结合起来一起向用户提供服务的。此时的 controller 的职责更准确的定义应该是“协调 view 与 model 的工作”，controller 更多负责 http 请求、数据转换、路径映射等工作。其实这与初始版本中的 controller 定义并不冲突，甚至一开始就有 model 中的数据更新之后通知 controller，再由 controller 告知 view 的途径。但是，区别就在于，现在只剩下了 controller 与 model 的交流，而没有了 view 与 model 的交流。</li></ul><p>上述观点都是基于 B/S 架构的，推广一下，部分 C/S 依然适用这样的交互方式。但这并不代表所有系统的交互方式都是如此，极端点的例子，很多数据分析平台，写数据的路径与读数据的路径完全分离，要是结合到 MVC 上，这完全就是 view 与 controller 的职责所在，当然了，每个系统所要解决的问题都不一样，落到实现细节上，并不能刻板的去和理论知识对照（这里要挖坑，需要找时间研究总结下典型场景和相应的交互方式）。</p></li><li><p>为什么 model 的更新消息不像之前一样，直接传递给 view，而是要经过 controller？</p><p>如前所述，有些系统中 view 缺乏与 model 直接交流的路径，所以必须要经过 controller。但是，这并不代表无法实现，还以之前的 java web 项目为例，可以将 web socket 技术看作 model 进行消息通知的手段（当然，model 通知 controller 可以由其他方式实现），那么就可以结合观察者之类的设计模式，达到数据更新时主动告知 view 的目的。</p></li><li><p>读写分离机制还存在吗？</p><p><em><strong>为方便理解，下述将使用具体的技术语言 html、spring mvc controller 以用于区别 view、controller</strong></em></p><p>若是像  java web 这样的系统，即使在不使用类似 web socket 单独开辟出 view 与 model 交流通道的前提下，依然可以对 spring mvc controller 的类型进行分类，即专门负责读请求的 spring mvc controller 与专门负责写请求的 spring mvc controller，这样一来，本质上可以认为，负责读请求的 html/spring mvc controller 是 MVC 中的 view + controller，因为他们是负责数据展示的，此时的 spring mvc controller 实现只是一种技术手段，而 controller 也只是协助 view，向其提供数据；负责写请求的 html/spring mvc controller 是 MVC 中的 controller，因为他们是向用户暴露输入接口的。</p><p>若是抛开这样的具体系统不谈，更加不影响我们去理解读、写两类请求拥有自己的访问模式了。</p></li><li><p>为什么没有了消息广播机制？</p><p>不是所有业务都需要这样的消息通知机制去实时的同步数据，而且考虑到实现这种机制所带来的成本增加，放弃也就不难理解了。</p></li></ul><p>总结一下，MVC 结构具有设计清晰、易于扩展、模块分离的特点，适用于多用户、可扩展、可维护、高交互性的系统，因此在构建 Web 应用中具有显著的优势。MVC 结构很好地表达了用户与系统的交互模式，以及整个系统的程序架构模式。MVC 结构可以很方便的用多个 view 来显示数据，从而可以使系统能方便的支持其它新的客户端类型。对于开发人员来讲，由于 MVC 分离了系统中的数据控制和数据表现 ,从而可以分清开发者的责任，后台开发人员可以专注业务的处理，前台开发人员专注于用户交互界面的设计，从而加快产品开发及推向市场的速度。</p><p><strong>我认为，消息广播机制并不影响 MVC 核心思想–分治在具体系统上的应用，故对这种机制可做取舍。但是，读写分离是 view 与 controller 天生定义所带来的职责区别，所以，若是没有了读写分离，那就不应该是传统 MVC 架构，而应该是拓展 MVC 架构。</strong></p><p><strong>MVC 的核心是通过“分治”的思想划分出职责明确的各个模块，并确定数据在模块间的通信、同步过程。</strong></p><h2 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h2><p>本节我们讨论 MVCS 架构，网上关于此架构的讨论较少。MVCS 中的 S 指的是 service 层。我们先不关注到底是 MVC 中分离出了 Service 还是 MVP 中分离出了 Service，从而形成了 MVCS 的架构（虽然看名字是 MVC 细分演化出来的 S），我们先来探讨下 service 的职责，以及细分出 service 的原因。</p><p>我们模拟一个“茶柜”展示的业务，所要做的事就是在 html 页面上展示一个茶产品的列表。自然，“茶”就是我们抽象出来的业务对象，数据库也有一张 tea table。</p><p>下面是以 spring mvc 为框架的 java web 常见的项目结构。简单介绍一下：</p><ul><li><p>controller</p><p>这部分是 spring mvc 框架中 controller 的实现，下图是 spring mvc 框架的 http 请求处理流程图（读者可以简要感受其原理，深入探讨需学习 servlet + spring mvc 相关知识，本文不过多涉及）。</p><p><img src="/images/SAC/MVC/spring_mvc1.png"></p><p><img src="/images/SAC/MVC/spring_mvc2.jpeg"></p><p>spring mvc 流程简单说就是当 http 请求到达时，由 dispatcherServlet 根据 url、请求类型等条件选择由哪个 handler （例如 TeaController）处理请求，handler中调用实际的业务处理方（即本例中的 service）。业务处理方处理完成后，返回结果，由 handler 将结果封装为 modelAndView 对象，交由 viewResolver 处理，生出渲染对象返回给前端 web 浏览器显示。</p><p>可以看出，整个 spring mvc 框架的职责对应 MVC 架构中的 controler 模块，负责协调 view 与 model 之间的关系，进行调度。</p></li><li><p>service + storage</p><p>service 与 storage 其实是职责细分的结果。</p><ul><li><p>service 负责定义业务领域上的数据行为。</p></li><li><p>storage 负责数据存储访问。数据存储并不特定于具体的数据库，诸如 MySQL、Redis、HDFS，甚至是本地文件系统、第三方应用都可以。ORM 框架只是我们在编写服务端访问数据库代码的语法糖，即 ORM 框架不是数据存储模块本身，而是实现数据存储的工具之一。我们的“数据”仍然存储在各类数据库中，storage 负责服务端与数据库端的交互。</p></li></ul><p>一方面，在细分了 service 与 storage 后，entity 与 PO（persistant object）的关系是清晰的，即 entity 负责数据的业务逻辑抽象，PO 表示数据的逻辑格式。在没有细分 service 与 storage 的 MVC 架构中，可以区分 entity 与 PO 并给予他们上述职责，但更多的可能是将entity 与 PO 混为一谈，即一个类负责了这两块职责，使得业务代码与数据库细节耦合在一起。但是无论怎么说，这些实现都依然属于 model 模块的定义，即负责数据与数据行为。</p><p>另一方面，贫血模型将数据与数据行为分开，充血模型将数据与部分数据行为放在一起。总言之，无论是使用贫血模型还是充血模型的 entity，整个 service + storage + entity + PO 依然属于 model 模块的职责范围。</p><p>总结，service + entity 的组合定义了业务领域的数据与数据行为，storage + PO 定义了底层存储（当然不是指硬盘这样的底层）层面的数据格式和访问方式。数据与访问数据都是 model 模块的一部分。需要注意的是，按照这样的职责划分，service/entity 不应该依赖于 storage/PO，storage/PO 应该依赖于 service/entity。即 service/entity 是业务领域的概念，并不关心底层实现细节。</p></li><li><p>html + css + js</p><p>这部分负责控制数据的显示方式，以及与用户的交互方式。故对应 MVC 中的 view 模块与 conrtoller 模块的部分职责。与之前所讲并无区别。</p><p>目前流行的前后端分离框架中，使用较多的 vue、react 等语言，自有其官方推荐的文件组织结构，与此处所举例并无本质区别。在讲到 MVVM 架构之前，对这部分我们不做过多延展。但是，需要注意的是，正如之前所讲，可以看到，controller 模块的职责是协调 view 与 model 之间的关系，其实现是涉及到 B/S 架构中前后端两部分的，并不独立存在。</p><p>像 jsp 这样的动态网页开发技术，其本质是使用 java 语言封装了 html 页面的生成过程。换言之，jsp 的作用就是生成 html 页面，但真正负责数据显示的仍然是 html + css + js 这些技术，故 jsp 应该视为 MVC 架构中的 controller 模块。</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> controller<br>---- TeaController<br>---- QueryTeaController<br><span class="hljs-bullet">-</span> service<br>---- TeaService<br>---- impl<br>-------- TeaServiceImpl<br><span class="hljs-bullet">-</span> storage<br>---- TeaStorage<br>-------- TeaStorageImpl<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> html<br>---- teaList.html<br><span class="hljs-bullet">-</span> css<br>---- teaList.css<br><span class="hljs-bullet">-</span> js<br>---- teaList.js<br></code></pre></td></tr></table></figure><p>经过探讨，笔者认为 MVCS 架构的核心是<strong>将数据的业务表达与存储表达区分开</strong>。即业务表达负责定义并实现业务领域上的数据与数据行为，向上提供接口。存储表达负责管理数据存储，与业务脱钩。</p><p>在基于这个定义的基础上，可以反思很多。例如，很多项目将部分业务逻辑实现在了 sql 语句上，这是错误的。正确做法是，首先思考 service 是否要提供该数据行为，在 service 需要提供的基础上，何种数据访问方式（可能是写 sql）能实现这一行为。</p><h2 id="1996-MVP"><a href="#1996-MVP" class="headerlink" title="1996 MVP"></a>1996 MVP</h2><p>TODO:</p><p><em>确保任何操作演示文稿的代码只操作演示文稿，将所有域和数据源逻辑推送到程序的明确分开的区域。</em></p><p>这种模式是一种分层形式，我们将表示代码和域代码保存在单独的层中，域代码不知道表示代码。</p><p>表示代码将操纵富客户端应用程序中的 GUI 小部件和结构、Web 应用程序中的 HTTP 标头和 HTML，或命令行应用程序中的命令行参数和打印语句。然后我们将应用程序划分为两个逻辑模块，所有表示代码在一个模块中，其余的在另一个模块中。</p><p>进一步分层通常用于将数据源代码与域（业务逻辑）分开，并使用<a href="https://www.martinfowler.com/eaaCatalog/serviceLayer.html">服务层</a>将域分开。出于分离表示的目的， 我们可以忽略这些进一步的层，将所有这些都称为“领域层”。请记住，域层的进一步分层是可能的。</p><p>除了分隔之外，还有一个严格的可见性规则。演示文稿能够调用域，但反之则不行。这可以作为构建的一部分使用依赖项检查工具进行检查。这里的重点是域应该完全不知道可以使用哪些演示文稿。这既有助于将关注点分开，也支持使用具有相同域代码的多个演示文稿。</p><p>尽管域无法调用演示文稿，但如果发生任何更改，域通常需要通知演示文稿。<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201633612">Observer</a>是解决这个问题的常用方法。域触发一个事件，通过演示观察到该事件，然后演示根据需要从域中重新读取数据。</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://folk.universitetetioslo.no/trygver/2007/MVC_Originals.pdf">Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.388.2266&rep=rep1&type=pdf">Adele Goldberg.Smalltalk-80: The Interactive Programming Environment, 1984.</a></p><p><a href="https://pdf.sciencedirectassets.com/278653/1-s2.0-S1877705814X00020/1-s2.0-S187770581400352X/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEH4aCXVzLWVhc3QtMSJGMEQCIHc8mQO8Xz3tRDpHYqSrP/Ry9jGIQ34lFez/rSuVfoseAiBlCNu+KUYZoXw0S1GL3pSQnxV02UzwETl0RXq/0nv1ASqDBAi2//////////8BEAQaDDA1OTAwMzU0Njg2NSIMDxrH7laEvfWEj51EKtcD1pVPGdkhPhPfFhxJxrIUDkQCkABfA1k97pShjs5vjQ1Mxzxjc+ikAAgzcw+17pF1HkVVrQcqWR7+Rl8WL0HDuLp8NfyQUmpxyD2gZsa8KkU/QovaQUGuMRAJCWlODemCspy7CHyhJXSxsbfRqO1Gnk6VklR1DwEP1lEOn3Oq1CRhI+PlJj2T/efZCJO+SwADMhtU9REQ5z8len68ckwKwdVSaMSVnH8cJ1lwpH5o8UKTZB9h9a7YZyZaxI24vrrCQQ1fhcjz58sx5Z8KDRIOYyLRoqlqk+vRx7H+cnndWI3vN63iK1qFrTXnFzJlvJF0TKULP63iFPZ6bgu3IXyzPqzZ83q646Xxw3IJMKEjgX8oFbqVu7w5THXnbtjxlVjxmyNWuAO/+9YUAgLOlNzP84+b1ZWUmj3d06cb2gUUEKnIF5kLpt/8zeFk+aYRZJgZzy4MYlHynbdMa4u9n93ETAi+jaxXvBzRMss1Z46t4tiSCQGx59rP6reT54SMaCkEiUdfqETLhq52abZ66GKwpoR5ci9aaW57wGRNq/NhTRl2J3xCprbQ8BOjMi9qbZVFpfZwMfXdwmf4WCnZP5OEQB3TCt13VkyL6gG6QoCnqVWRy1t3l9x5MLLVsYkGOqYBj36DquA2msyX9hmkNp9YdnEGxl9C3yVVNU+8qbgjxDBaQsPrG/0fiMupNzlNUvXFjcsuvFHyokR96xItOweKYbGOcc14H+KVp9U1wvkr9dAQ5IeNMgLosyS9JfQVy3VdWRF9G1AdWGtonkumFnrDhPnnGlhlrQcnIUXTZNUyXRTsdlG9zLdMGaRtDGqhOk1CYYeW1E1F4OF+TYLtvV5EpmAI7ZsUwA==&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210830T061856Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWWRCNY73/20210830/us-east-1/s3/aws4_request&X-Amz-Signature=a14fbae4f5014af539585b0a560486fb97c5630a5ab72987b254ab5fb18ac730&hash=5902936a72d87db3275f4fe2aaa2a34bfa8a5f0a15cb91f81f8b039318205651&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S187770581400352X&tid=spdf-9afc5b5d-6a90-40cc-a1e0-743a3a825bb8&sid=9315aae8544ba24f036a61d42bd1116b0a42gxrqa&type=client">Dragos-Paul Pop.Designing an MVC Model for Rapid Web Application Development, 2013.</a></p><p><a href="https://stefanoborini.com/book-modelviewcontroller/">Stefano Borini.Understanding Model-View-Controller.2019</a></p>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-001-概述</title>
    <link href="/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>暂时不知道说啥，但是要感谢 hgraca 的博客专栏<a href="https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/">《The Software Architecture Chronicles》</a>给予我灵感。</p><p>暂定目标是：前期总结自己经历学习的架构知识，对一些模棱两可的概念深挖到底，尽力丰富自己的见识，并沉淀下来一些属于自己的感悟。</p><p>TODO:</p><p>A software architecture is an abstraction of the run-time elements of a software system during some phase of its operation.A system may be composed of many levels of abstraction and many phases of operation, each with its own software architecture.</p><p><strong>软件体系结构</strong>是一个软件系统的运行时间的元素在其操作期间的某些阶段的抽象。一个系统可能由许多抽象层次和许多操作阶段组成，每个阶段都有自己的软件架构。</p><p>软件架构的核心是抽象原则：通过封装隐藏系统的一些细节，以便更好地识别和维持其属性 。一个复杂的系统将包含许多抽象层次，每个层次都有自己的架构。架构代表该级别系统行为的抽象，因此架构元素由它们提供给该级别其他元素的抽象接口来描述 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_9">9</a>]。在每个元素中可以找到另一个体系结构，定义子元素系统，这些子元素实现由父元素的抽象接口表示的行为。架构的这种递归一直延续到最基本的系统元素：那些不能分解为较不抽象的元素的元素。</p><p>除了架构的层次，一个软件系统通常会有多个操作阶段，如启动、初始化、正常处理、重新初始化和关闭。系统架构的整体描述不仅必须能够描述系统架构在每个阶段的操作行为，还必须能够描述阶段之间转换的架构。</p><p>我们将软件架构的视图与源代码的视图分开，以便专注于独立于给定组件实现的软件运行时特性。因此，架构设计和源代码结构设计虽然密切相关，但却是独立的设计活动。</p><p>A software architecture is defined by a configuration of architectural elements–components, connectors, and data–constrained in their relationships in order to achieve a desired set of architectural properties.</p><p>软件架构是由架构元素（组件、连接器和数据）的配置定义的，这些元素在它们的关系中受到约束，以实现一组所需的架构属性。架构元素包括处理、数据和连接元素。形式是由元素的属性和元素之间的关系——即对元素的约束来定义的。通过捕捉选择建筑风格、选择元素和形式的动机，基本原理为建筑提供了潜在的基础。</p><p>我对软件架构的定义是 Perry 和 Wolf [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_105">105</a> ] 模型中定义的详细版本，除了我排除了基本原理。尽管基本原理是软件架构研究和架构描述的一个重要方面，但将其包含在软件架构的定义中将意味着设计文档是运行时系统的一部分。基本原理的存在与否可以影响架构的演变，但是，一旦构成，架构就独立于其存在的原因。反射系统 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_80">80</a>] 可以使用过去表现的特征来改变未来的行为，但这样做是用另一个较低级别的架构替换一个较低级别的架构，而不是在这些架构中包含基本原理。因此，我们对软件架构的定义包括架构属性，而不是基本原理。基本原理解释了这些属性，缺乏基本原理可能会导致架构随着时间的推移逐渐衰败或退化，但基本原理本身并不是架构的一部分。</p><p>The architecture of a software system defines that system in terms of components and of interactions among those components.</p><p>软件系统的体系结构根据组件和这些组件之间的交互来定义该系统。除了指定系统的结构和拓扑外，体系结构还显示了系统需求和所构建系统的元素之间的预期对应关系。这种模型无法充分描述基于网络的软件架构，因为系统内数据元素的性质、位置和移动通常是系统行为的最重要决定因素</p><p>A component is an abstract unit of software instructions and internal state that provides a transformation of data via its interface.</p><p>组件是软件指令和内部状态的抽象单元，通过其接口提供数据转换。每个组件的行为都是架构的一部分，只要该行为可以从另一个组件的角度观察或辨别 。换句话说，一个组件是由它的接口和它提供给其他组件的服务定义的，而不是由它在接口后面的实现来定义的</p><p>A connector is an abstract mechanism that mediates communication, coordination, or cooperation among components.</p><p>连接器是一种抽象机制，用于调解组件之间的通信、协调或合作。连接器通过将数据元素从一个接口传输到另一个接口而不更改数据来实现组件之间的通信。相比之下，组件可能（但并非总是）从外部角度转换数据。</p><p>A datum is an element of information that is transferred from a component, or received by a component, via a connector.</p><p>数据是通过连接器从组件传输或由组件接收的信息元素。示例包括字节序列、消息、编组参数和序列化对象，但不包括永久驻留或隐藏在组件中的信息。组件还可以生成数据，例如时钟或传感器的软件封装。</p><p>A configuration is the structure of architectural relationships among components, connectors, and data during a period of system run-time.</p><p>配置是系统运行期间组件、连接器和数据之间架构关系的结构。组件，它是计算的位置。连接器，定义组件之间的交互。配置，它们是交互组件和连接器的集合。</p><p>An architectural style is a coordinated set of architectural constraints that restricts the roles/features of architectural elements and the allowed relationships among those elements within any architecture that conforms to that style.</p><p>架构风格是一组协调的架构约束，它限制架构元素的角色/特征以及在符合该风格的任何架构中这些元素之间允许的关系。由于架构体现了功能性和非功能性属性，因此很难直接比较不同类型系统的架构，甚至是不同环境中设置的相同类型系统的架构。样式是一种对架构进行分类并定义其共同特征的机制 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_38">38</a> ]。每种风格都为组件的交互提供了一个抽象，通过忽略架构其余部分的附带细节来捕捉交互模式的本质 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_117">117</a> ]。架构风格封装了有关架构元素的重要决策，并强调了对元素及其关系的重要约束。此定义允许仅关注架构的连接器或组件接口的特定方面的样式。</p><p>具体来说，架构风格决定了可在该风格实例中使用的组件和连接器的词汇，以及关于如何组合它们的一组约束 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_53">53</a> ]。这种对架构风格的限制性观点是他们对软件架构定义的直接结果——将架构视为一种正式的描述，而不是一个正在运行的系统，这导致了仅基于方框图和线图的共享模式的抽象。</p><p>由于将一组命名的约束称为样式可以更容易地传达常见约束的特征，因此我们使用架构样式作为一种抽象方法，而不是作为个性化设计的指标。</p><p>事实上，亚历山大的模式概念并不以建筑元素的重复排列为中心，而是以发生在空间内的事件的重复模式——人类活动和情感——为中心，并理解事件模式不能与它发生的空间[ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_3">3</a> ]。</p><p><em>作为世界中的一个元素，每一种模式都是特定语境、在该语境中反复出现的特定力量系统以及允许这些力量自行解决的特定空间配置之间的关系。</em></p><p><em>作为语言的一种元素，模式是一种指令，它展示了如何一遍又一遍地使用这种空间配置来解决给定的力系统，无论上下文是否相关。</em></p><p><em>简而言之，模式同时也是一个发生在世界上的事情，以及告诉我们如何创建该事物以及何时必须创建它的规则。它既是一个过程，也是一件事；既是对活着的事物的描述，也是对产生该事物的过程的描述。</em></p><style>    .cd-timeline.svelte-1t2uafz .svelte-1t2uafz,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::after,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::before{-webkit-box-sizing:border-box;box-sizing:border-box}.cd-timeline.svelte-1t2uafz{font-size:1.6rem;font-family:"Droid Serif", serif;color:#7f8c97;background-color:#e9f0f5}.cd-timeline.svelte-1t2uafz a{color:#acb7c0;text-decoration:none}.cd-timeline.svelte-1t2uafz img{max-width:100%}.cd-timeline.svelte-1t2uafz h1,h2{font-family:"Open Sans", sans-serif;font-weight:bold}.cd-timeline.svelte-1t2uafz{overflow:hidden;margin:2em auto}.cd-timeline__container.svelte-1t2uafz{position:relative;width:90%;max-width:1170px;margin:0 auto;padding:2em 0}.cd-timeline__container.svelte-1t2uafz::before{content:'';position:absolute;top:0;left:18px;height:100%;width:4px;background:#d7e4ed}@media only screen and (min-width: 1170px){.cd-timeline.svelte-1t2uafz{margin-top:3em;margin-bottom:3em}.cd-timeline__container.svelte-1t2uafz::before{left:50%;margin-left:-2px}}.cd-timeline__block.svelte-1t2uafz{position:relative;margin:2em 0}.cd-timeline__block.svelte-1t2uafz:after{content:"";display:table;clear:both}.cd-timeline__block.svelte-1t2uafz:first-child{margin-top:0}.cd-timeline__block.svelte-1t2uafz:last-child{margin-bottom:0}@media only screen and (min-width: 1170px){.cd-timeline__block.svelte-1t2uafz{margin:4em 0}}.cd-timeline__img.svelte-1t2uafz{position:absolute;top:0;left:0;width:40px;height:40px;border-radius:50%;-webkit-box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05);box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05)}.cd-timeline__img.svelte-1t2uafz{background:#75ce66}@media only screen and (min-width: 1170px){.cd-timeline__img.svelte-1t2uafz{width:60px;height:60px;left:50%;margin-left:-30px;-webkit-transform:translateZ(0);transform:translateZ(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}.cd-timeline__content.svelte-1t2uafz{position:relative;margin-left:60px;background:white;border-radius:0.25em;padding:1em;-webkit-box-shadow:0 3px 0 #d7e4ed;box-shadow:0 3px 0 #d7e4ed}.cd-timeline__content.svelte-1t2uafz:after{content:"";display:table;clear:both}.cd-timeline__content.svelte-1t2uafz::before{content:'';position:absolute;top:16px;right:100%;height:0;width:0;border:7px solid transparent;border-right:7px solid white}.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{color:#303e49}.cd-timeline__content.svelte-1t2uafz p,.cd-timeline__date.svelte-1t2uafz{font-size:1.3rem}.cd-timeline__content.svelte-1t2uafz p{margin:1em 0;line-height:1.6}.cd-timeline__date.svelte-1t2uafz{display:inline-block}.cd-timeline__date.svelte-1t2uafz{float:left;padding:.8em 0;opacity:.7}@media only screen and (min-width: 768px){.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{font-size:2rem}.cd-timeline__content.svelte-1t2uafz p{font-size:1.6rem}.cd-timeline__date.svelte-1t2uafz{font-size:1.4rem}}@media only screen and (min-width: 1170px){.cd-timeline__content.svelte-1t2uafz{margin-left:0;padding:1.6em;width:45%;-webkit-transform:translateZ(0);transform:translateZ(0)}.cd-timeline__content.svelte-1t2uafz::before{top:24px;left:100%;border-color:transparent;border-left-color:white}.cd-timeline__date.svelte-1t2uafz{position:absolute;width:100%;left:122%;top:6px;font-size:1.6rem}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz{float:right}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz::before{top:24px;left:auto;right:100%;border-color:transparent;border-right-color:white}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__date.svelte-1t2uafz{left:auto;right:122%;text-align:right}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}    </style><section class="cd-timeline js-cd-timeline svelte-1t2uafz">    <div class="cd-timeline__container svelte-1t2uafz">            </div></section>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD-001-对一个未完成项目的总结</title>
    <link href="/2021/08/19/DDD-001-%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/19/DDD-001-%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容为ZXJY公司内部系统架构、代码、文章、讨论的归纳总结，以及本人对各问题的思考。因保密相关，涉及到敏感内容，会以网络普遍讨论的模型为例。</p><h2 id="ZXJY公司系统架构所面临的问题"><a href="#ZXJY公司系统架构所面临的问题" class="headerlink" title="ZXJY公司系统架构所面临的问题"></a>ZXJY公司系统架构所面临的问题</h2><p><strong>核心问题：微服务数量过多。</strong></p><p>ZXJY从2015年开始全面使用微服务架构后，服务的数量就开始飞涨。某些研发组甚至发展到了，一个业务功能一个微服务的程度（往往是按照数据库表来划分的，这里要埋一个坑，即微服务如何划分的实践问题）。在一开始感受到微服务带来的分工和模块化的优点之后，团队很快就碰到如何管理数量庞大的微服务的棘手问题–<strong>系统复杂程度指数级上升</strong>。</p><ul><li><p>理解困难。</p><ul><li>新人对业务逻辑与代码逻辑的映射、系统架构、代码细节、技术实现理解困难。</li></ul></li><li><p>开发困难。</p><ul><li>难以判断新功能放在哪个微服务更合适（或者说都可以）。</li><li>抽象泄漏。微服务作为SOA的一种类型，其初衷就是希望能够通过对外部提供一个合理抽象的接口，从而屏蔽内部的实现。只要接口定义不变，内部可以独立迭代，从而实现开发流程的扩展性。然而我们很难保证服务拆分和接口设计是合理的，尤其在业务快速迭代的过程中，整个系统的各种基础假设都会被持续迭代。然而一旦某个逻辑被暴露为微服务接口，其抽象就泄露到了整个系统，后续要修改或者下线这个接口的成本是极高的。这就导致了后续即使业务逻辑发生变化，我们也只能捏着鼻子在沿着错误的抽象来修修补补。</li></ul></li><li><p>部署困难。</p><ul><li>一个功能的上线可能涉及到多个微服务，那么怎么打包、上线顺序等等都是问题，当团队开发节奏加快后，频繁的部署使研发、运维人员苦不堪言，很多简单的修改都需要同时更新多个微服务，不但使得工作量大大增加，也使得部署的依赖更加复杂。</li><li>DevOps、敏捷等技术的运用遭受挑战。</li></ul></li><li><p>测试困难。</p><ul><li>本地代码调试困难。</li><li>Bug溯源、定位、追踪复杂。</li></ul></li><li><p>维护困难。</p><ul><li>网络波动对服务性能影响巨大。</li><li>对基础设施迭代不友好。数量庞大的微服务大大拖慢了基础设施迭代和推广的速度，又进一步使得微服务无法得到有效支撑。一个惨痛的现实就是，每次有紧急的基础设施升级，都必须手动升级数量庞大的微服务，带来了巨大的人力浪费。</li></ul></li></ul><h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h2><p>在讨论解决方案之前，应先定义清楚衡量系统架构的指标都有哪些（此处不由得联想到《演进式架构》，或者更广义的说，在讨论任何科学问题时，先行定义清楚问题域边界是至关重要的）。</p><p>在介绍最终衡量指标前，先对陶文的博客<a href="https://github.com/taowen/modularization-examples">《代码防腐》</a>做简要陈述。代码腐败也叫软件熵，是指软件性能随着时间而逐渐恶化或反应性的递减，导致软件出错、不稳定。这并不是一个物理现象，因为软件实际上并不会衰变，而是缺乏敏捷反应、未能随环境变化而修改。显然，正如《没有银弹》一文所说，由于<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">软件本质性</a>所引发出的 complexity、invisibility、conformity、changeability，再加上许多人为因素：软件开发者本人所处时空限制、能力限制导致其并不能做出现在看来“完美”的设计；商业软件本身需要去衡量各种成本，包括资金、人力、时间等等；缺乏完善的测试等。以上因素，导致开发者不得不在本就困难的问题基础上，缺乏思考、设计的情况下赶工开发，致使问题影响范围扩大，又由于没有严格的测试拦截，导致问题得不到有效的反映和遏制，再加之缺乏复盘性的总结学习，导致问题越来越难以解决，即腐败的味道愈加浓重。</p><p>什么样的系统是我们所希望的，我们又要如何去发现代码腐败。</p><p>首先陶文指出了系统应该具备的三点特性，现做出总结。</p><ul><li><p>Autonomy 独立性。</p><p>开发团队担心出现这样的症状：</p><ul><li>沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。</li><li>需求下线困难：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。</li></ul><p>独立性的愿景就是尽量减轻上述的症状，让拆分出来的代码更独立。用以下指标衡量系统的独立性：</p><ul><li>会议时间。</li><li>接口改动次数 / 接口实现改动次数 比率：我们期望大部分时候就可以只改接口实现，而不改接口本身。</li></ul></li><li><p>Consistency 一致性。</p><p>一致性是对可复用 git 仓库的要求，是为了防御常见的设计错误。用以下指标衡量系统的一致性：</p><ul><li>必要参数总量 / 参数总量 比率：把可复用 git 仓库对外提供的函数的参数分为两类，必要参数和非必要参数。非必要参数是指只有 10% 的调用方传递了的参数。</li><li>咨询量：可复用的 git 仓库，应该努力降低使用者的成本。 使用者的最大成本来自于沟通问询。如果文档不清楚，接入方式是手工的，必然会体现在咨询量上。</li><li>接入次数：使用次数只有1次或者2次，就不应该被抽取成可复用的 git 仓库。至少要被使用3次。</li><li>接入率：如果要抽出可复用的代码，出发点应该是一致性，是在团队关键成员达成了一致之后的有意识行为。</li><li>阻断率：阻断率指所有可接入的地方，有多少处上了强制检查，确保了违规行为会被阻断。</li></ul></li><li><p>Feedback 反馈性。</p><p>业务逻辑无论如何做拆分，最终仍然是要集成到一起跑起来的。 无论是编辑时拆分成文件、文件夹、git 仓库，还是运行时拆分成进程，拆分无可避免地引入了“降低反馈速度”的副作用。 一旦产生了分工，就会有你不了解的部分。这也是分工的本意所在，控制知识边界，让普通人也可以参与劳动。 但是软件是要整体集成到一起才能发挥其全部价值。这种“整体”与“部分”的矛盾，造成了反馈性问题。</p><p>开发团队担心出现这样的症状：</p><ul><li>故障定位慢。</li><li>获得真实反馈慢：代码写完了要等审核发版，错过了这个版本又要等一个月公司才会发下个版本。</li><li>本地测试难：稍微有点价值的测试都不是本地可以用 JUnit 写出来的。</li><li>与用户脱轨。</li></ul><p>反馈性的愿景是尽量减少获得反馈的摩檫力。业务逻辑拆分为什么会影响到反馈性呢？这仍然是要归结为人的沟通效率问题（《人月神话》）。能用标准化的方式解决的，就可以减少沟通。能尽量减少信息传递次数的，就可以有效减少传递过程中的信息衰减。用以下指标衡量系统的反馈性：</p><ul><li>工单流转时长。</li><li>故障定位时长。</li><li>代码集成时长。</li></ul></li></ul><p>其次陶文给出了应对代码腐败的策略。</p><ul><li><p>信息隐藏：封装、抽象、依赖倒置。</p><p>在依赖倒置的前提下，需要显式地提炼出最小化接口， 从而让更多的需求改动封闭在更上层的依赖关系里，更多去改实现代码，而不是改接口代码。</p><p>还有一个问题是，如何做到独立性？这里不能依赖人力的 code review，而应该依赖代码结构，限制改动范围。如此一来，模块的 git 仓库是不会造成全局影响。我们就可以放心的把新人分配去写一个独立的模块，而不用担心其设计选择造成大面积的代码腐化。code review 仅需要集中关照主板。并且评价“高内聚低耦合”的标准也可以用主板的代码改动行数进行量化（在完成需求的前提下，主板的代码改动行数越少越好）。</p></li><li><p>分层</p></li><li><p>持续改进</p><p>只对自己写的代码负责要体现在发布变更，告警定位这两个环节里。做好了这两点，就有了持续改进系统的基础保障。</p><ul><li><p>发布变更。单体应用最大的原罪就是变更的粒度太大了。而大粒度变更是稳定性的最大敌人。 切分变更有三种主要的做法：</p><ul><li><p>多进程：把单体进程切分成多进程，控制的是代码的变更。一次只变更其中的一个。因为大部分线上故障都是由变更引起的，所以 SRE 会非常强调部署流程的小心谨慎。 一旦发现有问题，就会被要求立即回滚。这也就导致了搭车上线是非常讨厌的事情，谁知道你搭车进来的改动会不会翻车。 所以拆分成多进程，各上各的就会变成非常强烈的需求。</p><p>但是用拆分进程的方式来解决上线慢的问题也会有一些缺点：</p><ul><li>反馈不集中：小流量的时候，引起的小规模的故障可能观察不出来。</li></ul></li><li><p>灰度数有限：集群规模比较小的时候，总共就几个进程，灰度的刻度就会很大。</p><ul><li>回滚慢：进程替换需要时间。</li></ul></li><li><p>灰度时间有限：上线观察一天已经很夸张了，要更长时间的观察是不好用上线的方式来实现的。</p><ul><li>上线顺序：进程之间经常有数据依赖，并不能总是保持向后兼容。</li></ul></li><li><p>多租户：把所有的业务数据分成租户，控制的是数据的变更。一次只升级一个租户的数据和代码。</p></li><li><p>多变种：分租户还是粒度太粗了，比如说挂掉一个城市也是不可接受的。那么可以在线上同时运行多个版本的代码，然后逐步的切流量，这其实控制的是配置的变更。在不改变进程的情况下，通过配置等方式更灵活地进行装配组合。这样发布和上线就可以解开为两个操作了。上线就是上线，改变进程里的可执行代码。 上线可以不把 feature flag 打开，而是保持原有的行为。 然后再慢慢地打开 feature flag 的流量开关。</p></li></ul><p>当然更极致的做法是同时分租户，也在租户升级的时候切流量。</p></li><li><p>告警定位</p><p>要减轻分工带来的负面影响，最重要的是做好“隔离”。虽然我们把所有的部件都集成到了一起了，但是我们仍然要在“运行时”通过各种手段人为制造出边界，把责任隔离出来。 把责任隔离出来，就是把运行时的行为，与背后负责的团队与个人对应起来。</p><ul><li><p>进程边界</p><p>把不同的 git 仓库跑在不同的进程里。这样只要看是哪个进程出的问题，就可以知道问题是由哪个 git 仓库引起的了。</p><p>进程边界的优点如下：</p><ul><li>完善的跨进程调用监控：相比进程内调用，跨进程调用的监控基础设施要完善得多。</li></ul></li><li><p>操作系统强制的配额和安全性：基础设施更好。</p><ul><li>隔离的内存状态：进程之间不会共享内存，从而产生监控逃逸的影响。</li></ul><p>进程边界的缺点如下：</p><ul><li>适用场景：在前端里启动独立的进程不是常规的做法。</li></ul></li><li><p>性能优化会漏掉依赖：经常我们会把配置等数据读取一次之后就缓存在进程内。这部分依赖就很容易逃逸出监控的范围。</p><ul><li>远离用户：拆分出来的进程往往是越来越靠后台，离用户越远，就越难以倾听到用户的声音。</li></ul><p>我们的目标是在出问题之后，能从运行时的现象找到对应的 git 仓库。</p></li><li><p>函数边界</p><p>无论是编程语言原生支持的同步调用栈，还是需要自研的异步调用栈，其目的都是隔离，从而给 caller/callee 关系建索引。</p></li><li><p>模块边界</p><p>如果有强制的模块规范，那甚至可以做到“内存状态”的隔离，用编译检查等手段禁止全局变量，禁止偷偷地访问另外一个模块的内部状态。 一个进程要读取一份配置，只有第一次RPC的时候我们才能监控到，后续缓存在内存里的访问就是不可见的了。 而模块则不用担心跨模块调用的开销，我们可以把配置缓存在另外一个模块里，这样每次读取配置都是跨模块的调用，从而可以被监控到。</p><p>模块和进程的核心区别就是模块可以适用于更多的运行时（比如iOS，微信小程序），可以用于拆分运行时调用关系更频繁更紧密的界面和流程。 进程边界的优势来自于社区共识，提前提供了大量开源的优秀基础设施。 但是并不意味着，除了进程边界，我们不能在进程内再为每个 git 仓库划出边界来，只是要付出一些自研代价罢了。 社区共识是不够的，在函数边界（特别是同步调用栈之外的其他调用关系），以及模块边界上都没有足够强的规范。 只要能在公司或者部门级别建立好共识，函数边界和模块边界完全可以满足问题定位的需求，甚至比进程边界做得更好。</p></li></ul></li></ul></li></ul><p><strong>现给出ZXJY公司对于系统的衡量指标。</strong></p><ul><li>rpc 接口总数量。</li><li>接口改动次数 / 接口实现改动次数 比率。</li><li>微服务调用链上依赖关系的数量。</li><li>一次需求平均所需修改的 git 仓库数量</li><li>一个需求上线所需的时间。</li><li>没有循环依赖。依赖和耦合的最大区别在于，当我们说“A和B耦合”时，在字面含义中，A和B二者平等。然而，正确的模块关系根本不应该平等，而应该是单向依赖才对。所以我们应该说“A依赖B”，这样含义要清楚得多。A依赖B意味着，A模块可以调用B模块暴露的API，但B模块绝不允许调用A模块的API。单向依赖是红线，好的设计一定不会违反这条红线。</li><li>正交性：指一个模块提供的API中，多个方法之间是否有重复的功能。</li><li>紧凑性：指一个模块提供的API中，公有方法总数必须很少，每个方法的参数也必须很少。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>核心思路：降低微服务数量。</strong></p><p>为了更好的管理系统的复杂度，减缓系统的腐化，我们的架构目标主要是：</p><ul><li><p>服务接口的合理与简单高于具体功能实现的优雅。系统复杂度主要来自于服务对外的接口，因此我们的架构重点关注接口设计，而内部实现可以相对灵活。</p></li><li><p>易于迭代高于强大的预先设计。当前业务灵活多变而团队经验较为欠缺，很难做好太多预先设计，但系统必须具备快速迭代的能力。</p></li><li><p>团队和系统的自治高于功能复用。功能复用很容易带来沟通成本上升、抽象泄露、以及功能分化的风险。</p></li><li><p>风格的简单一致高于追求技术完美。</p></li><li><p>工具和自动化高于灵活与精确。我们希望尽可能的利用工具和自动化来阻断不合理的设计，降低对人的依赖。</p></li></ul><p><strong>核心方案：区分“项目”和“服务”。一个项目对应一个代码仓库（git repo），规模可以适当大一些，应当包含一个领域内的大部分逻辑。一个服务对应一个进程，可以是项目中的一个 module 或者是一个单独的 entrypoint。基础架构的部署系统提供了便于部署项目的能力，即项目中的代码修改之后，可以自动部署所有关联的服务。</strong></p><p>微服务架构最大的好处是给出了非常清晰的模块边界。以前我们会让一个微服务来对应一个功能模块，导致粒度非常细。问题在于随着业务的变化，边界也是会随之变化的，如果我们过早通过微服务来实现边界，后续修改的成本是极高的。因此我们不应该再轻易独立出微服务，而是尽量在服务内部划分清晰的功能边界。</p><p>目前我们的服务架构都是遵照三层架构，基本分为展示层、逻辑层、存储层，每一层内没有更多划分模块的规范。因为我们把系统功能拆分成为多个微服务，而且之前实践中往往把微服务拆的过小，因此一般逻辑都比较简单，每一层内不隔离问题也不大。不过之后每个微服务要处理相对完整的业务逻辑，粒度会变大，单个服务的复杂度会上升。因此简单的按层次来划分已经不够，此时的最佳实践应当是根据功能来划分。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面剖析电商项目。</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/images/DDD/001/logic_view.png"></p><p><img src="/images/DDD/001/code_struct.png"></p><p>项目整体结构参考六边形架构，将业务逻辑隐藏在 backend 模块内，即六边形的内部。</p><p><img src="/images/DDD/001/code_struct_admin.png"></p><p><img src="/images/DDD/001/code_struct_consumer.png"></p><p><img src="/images/DDD/001/code_struct_job.png"></p><p><img src="/images/DDD/001/code_struct_rpc.png"></p><p><img src="/images/DDD/001/code_struct_web.png"></p><p>admin、consumer、job、rpc、web 都属于接口，分别对应了web（B端与C端）、mq、定时任务、rpc这些系统可能的调用方，满足其需求。可以看出，接口相互之间互不影响，当需要满足新的调用方式时，只需要添加对应的模块，处理对应的请求即可，真正的业务逻辑永远保持在领域内。</p><p><img src="/images/DDD/001/code_struct_client.png"></p><p><img src="/images/DDD/001/code_struct_common.png"></p><p>由于使用 thrift 作为 rpc 协议，故在 common 模块内定义 thrift schema，在 client 封装对于 thrift 借口的调用，方便调用方使用。而 rpc 请求真正的处理者，是前文所讲的 rpc 模块内的 rpc handler。</p><p><img src="/images/DDD/001/code_struct_backend.png"></p><ul><li><p>application</p><p>application 层是对对外所暴露接口的实现，属于主适配器，有编排多个领域以及防腐层的职责。</p><p>usecase 实现了上层所有接口，通过编排各个领域中 service 所提供的基本能力，实现业务动作。如创建订单，我们需要查询商品、修改库存、使用优惠券、创建订单实体等一系列复杂行为，但是他们按照我们之前的领域划分，很有可能分属于不同领域，那么这时候就可以通过 usecase 将他们融合在一起。</p><p>commond/query CQRS模式中的 command 和 query。简单介绍，CQRS是一种读写分离模式，command 代表了对数据产生变化的操作，一般是新增、删除、更新，query 代表了不对数据产生变化的操作，一般是查询。在没有 CQRS 的系统中，不论是何种类型的请求分别经过 controller、service、storage 查询到数据库，再分别经过 storage、service、controller 返回给前端显示。但是从数据层面我们就知道，不同系统对于读写两类请求的需求与支持是不同的。故在 CQRS 模式中，读/写两类请求分别走不同的接口与路径，甚至可以实现为读/写访问不同的数据存储。</p><p>dto 是防腐层数据接口，将外部数据类型与领域内实体解耦。举例来说，thrift 接口使用的数据类型是在 thrift 文件中定义的 struct 通过 thrift 命令行命令生成的，rpc 接口的调用方和提供方都使用此数据结构，但是，领域中肯定使用 entity 实体与 model 值对象作为数据结构，这就需要 dto 作为中间层的数据结构，首先解耦了两边数据结构的直接关联，其次在整个 application 层都可以使用 dto 代表编排聚合后的数据结构。</p></li><li><p>component</p><p>严格来说，component 是真正的领域层，component 包下的每个子包，即对应了 DDD 中的一个子域（对于该项目，仍然是一个限界上下文对于一个子域）。其中 trade 属于核心域，负责交易相关内容，如查询订单、创建订单、预支付（创建支付订单与第三方支付单）、退款订单等。product 负责查询商品、查询优惠券、发送优惠券、使用优惠券、查询礼包等。</p><p>entity 实体是拥有 id（可能是多主键） 的对象。深入的说，抛开具体存储的技术不谈（不管是什么类型的数据库，还是文件等等），实体是可以被它的 id 唯一标识的，除了 id 以外的所有属性，都只是为了描述该实体，不能通过这些属性去判断两个实体是否相等。</p><p>model 值对象是没有 id 的对象。同理，一个值对象就是根据其属性所决定的，但是这里并没有说所有属性，具体判断两个值对象是否相等，由具体业务决定。</p><p>举个例子：社会上有很多人都叫王浩，但是他们的身份证 id 不同，从社会角度来说，他们就是两个完全独立的人。但是，市场上有很多同样品牌、同样款式、同样颜色、同样大小的衣服，在很多场景下，我们在 A 地看见这件衣服，当我们在 B 地再次看见时，就可以说是同一件衣服，我们没有给衣服编号的必要性，我们只是觉得根据这些属性去判断就足够了。当然，再次强调，这只是例子，如果你在开发的是某纺织工厂的系统，就是要为每一批产品，甚至每一件衣服编号，那这就是你的业务所需要的，衣服或许就应该是一个实体。</p><p>除此以外，entity 实体在内存中是可以变化的，可是 model 值对象不可以变化，即 model 值对象查询到以后，其所有属性值都是不可变的，没有 setter 方法。</p><p>port/repository 都属于从适配器，定义了领域所需要的底层逻辑接口。区别是，在此项目中，repository 所定义的接口都属于对某个 entity 实体的 CRUD。port 则没有此限制，仅代表了接口的含义。需要注意的是，现如今有很多 ORM 框架都只需要定义 java interface，由框架本身实现具体的增删改查逻辑，如 Mybatis、Hibernate 等。但是，把这些框架放在六边形架构中，就产生了一个问题，即领域内所定义的 repository 接口，是和具体实现（具体 ORM 框架）所绑定的，这是绝对不允许的，即领域内只关心业务问题，只要牵扯到了底层技术实现问题，那就是错的。所以，在使用这些框架时，我们依然把 repository 接口当作普通的抽象定义，在实现层，用这些框架的写法去定义框架所需要的 interface，来作为对 repository 的实现。</p><p>service 实现了领域内的业务逻辑。如创建订单、创建退款单等，注意，这里的每个动作，都是单一领域内的完整动作，即只是创建了一个“订单”而已（粗暴的理解，只是在订单表插入了一条记录，但这只是为了理解，切记，领域内不关心具体实现，具体实现可能要复杂很多），至于我们平常所认知的创建订单–商品、优惠券、活动等等相关概念的处理，他们都不属于此领域，故 service 中不牵扯这些概念。</p></li><li><p>infrastructure</p><p>六边形架构中的从适配器，用于对接数据、业务逻辑的底层实现，并且承担了防腐层的职责。以电商项目为例，商品、订单等功能对接电商中台，故查看商品详情、创建订单、退款订单等动作，底层数据、甚至逻辑就存储在“电商中台”。优惠券、代币等属于业务部门的功能，底层数据选择使用 mysql 存储。回想之前的主适配器，可以看出在整个六边形架构中，整个架构的依赖方向是向内的，即指向领域中心。用来约定外层行为的方式就是抽象，彻底与外层解耦。</p><p>对于领域内部而言，这些细节是不重要的，领域内不需要清楚具体的实现细节，对它而言，它只是根据约定，即 port/repository 所定义接口中声明的方法与数据结构，来实现领域的业务动作。</p></li></ul><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>微服务数量变少之后，可以很大程度上改善抽象泄露的问题，一个领域内的逻辑可以尽量保持在一个项目内部，不需要对外暴露内部接口。</p></li><li><p>在我们的基础设施足够强悍之前，微服务的数量变少总是可以大大的方便各种基础库的迭代。</p></li><li><p>项目内部的调用不需要过 rpc，可以充分利用 IDE 的自动化重构能力，在运行效率和开发效率上都会有明显提升。</p></li><li><p>项目足够自治，对外部依赖较少，更加便于自动化测试。</p></li><li><p>只有确实跨领域的逻辑才需要对外暴露接口，对于这些接口也可以进行更严格的 code review。如果微服务数量和拆分相对合理，应当期望微服务对外接口的变动是相对少的。这样我们可以强制要求所有涉及到接口变动的修改应当有更加严格的 code review 流程，从而保证系统设计的合理性。而微服务内部的变动可以相对灵活，因为重构和测试的成本都是较小的。</p></li><li><p>更易于消除循环依赖。</p></li><li><p>服务这一层抽象不是为了解决功能的划分，但是提供了两个益处：</p><ul><li>不同服务对应独立进程，提供了一定的运行时隔离，也便于单独扩容</li><li>一些展示层的代码可以放在上层模块中，使得模块之间容易避免循环依赖</li></ul><p>虽然不同服务对应了不同的进程，但是因为底层逻辑和存储都是共享的，因此只是提供了非常有限的隔离性。新建和删除服务的成本相对较低。但是每个服务都需要单独的部署，因此服务拆分也不宜太细。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>仓库规模更大，打包、编译、自动化测试等步骤可能更加耗时，一次部署涉及的服务数量会更多。虽然对于单个仓库的操作效率会降低，但是减少了一次需要所涉及的仓库数量，所以整体效率还是提升的。</li><li>多人开发同一仓库的情况变的更加严重，修改冲突的机会变大。大部分的修改应该是局限在一个 module 内部，甚至 module 内的一个 package 内部，通过限制修改范围，可以很大程度上避免冲突。</li><li>因为迭代是以项目为单位，中间的某些稳定模块也会因为其他模块的更改而多次部署。理论上基础架构的改进应当使得部署本身更加轻松和稳定，不会影响到整个系统的稳定。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Domain Driven Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO!GO!GO!</title>
    <link href="/2021/08/19/GO-GO-GO/"/>
    <url>/2021/08/19/GO-GO-GO/</url>
    
    <content type="html"><![CDATA[<p>本文是我个人博客的起点，故多说点废话。</p><p>首先说点最近的个人经历吧，有关于我对目前想要探讨的问题在时间上有个脉络。</p><ul><li>我是在研究生一年级入学前开始学习大数据相关知识，如基本思潮、hdoop、spark等，当时在没有实践基础的情况下，主要的学习内容是相关工具/框架的搭建、编码使用以及技术细节。</li><li>在研究生一年级学习中，又系统地学习了大数据相关更多的知识，如Hive、Hbas、Spark &amp; Spark Streaming、Zookeeper等等，所学内容与之前无异。</li><li>与此同时，由于本人导师的原因，又接触到了许多工程/软件工程/敏捷相关的思想课程，如《精益创业》、看板、Scrum、极限编程等（有愧的是一直没有深入系统的去看过DevOps相关书籍，只是泛泛地看过大佬们的博客，就不当作学习吧）。</li><li>再之后，即2019年上半年在上海的某家公司实习时，由于所处项目正在微服务化改造，故又去系统学习了微服务，主要书籍有《微服务架构设计模式》、《微服务设计》、《Spring 微服务实战》、Martin Flower等大佬们的各种博客，有了微服务，就总有一个绕不过去的坎–如何拆分为服务？之前的这些文章中，都或多或少的讲解过这个问题，也或明或暗的牵扯到了DDD、六边形架构、整洁架构等概念。</li><li>我实习所处的产品组，做的事简单说就是「AI模型部署」，这个过程中涉及到的知识有云计算相关（k8s、网关、灰度/蓝绿/金丝雀部署、集群监控、集群报警）、DevOps相关。</li><li>后续回到学校，又去研究了分布式相关的概念和知识，这里要重重的推荐一本书–《数据密集型应用系统设计》。</li><li>研究生毕业后，我去某国企参加了他们电商项目的微服务化改造项目，与之前的实习相比，这次我去的早，真正的从0到1体验到了到了这个过程。</li><li>工作一年不到，因为一些个人原因，跳槽到了一家互联网企业。在这里，除了日常的业务工作，我们开始了对之前微服务项目的整合（这个后续会细说，又是一个电商迁移项目，但整个公司所面对的问题简单说就是微服务一开始拆的太细了），项目结构是面向DDD的，整个开发过程中的设计策略也是DDD的那一套，我们按下不表。</li></ul><p>说了这么多细枝末节，连云计算和大数据都扯出来了，我这是要干嘛？其实我一直有一种糊涂的感觉，就是我觉得我刚才所说的这些知识，它们是有深刻联系的，在思想上、在技术上都有，我想要理清这个脉络，所以我需要按照一些方式去梳理他。所以我开启了我的博客行，旨在解决个人问题……^_^</p><p>什么联系？</p><p>细节不说，我所学习的大数据知识告诉我最重要的思想是「分而治之」，除此以外，我在学习大数据相关框架/工具的技术细节时，与之后学习分布式相关的知识不谋而合，或者说，大数据相关工具就是对这些分布式理论知识的实践（所以学习分布式时接受的也特别快～）。在微服务的整个学习过程中，分布式的影子无处不。，在思想层面，「分而治之」依旧影响着一切。至于底层的实现细节，微服务与分布式所面对的问题，也有了联系上。还是那个问题，如何拆分微服务？又引出了DDD、六边形架构等等，那么去看这些概念，「分而治之」再一次在另一个维度闪耀。</p><p>这或许就是我目前所能写出的联系吧，但我觉得不止于此处，故现在开始我的学习之旅，在未来的一段时间，我想要探究以下问题。</p><ul><li>微服务、DDD、六边形等架构、DevOps、分布式之间的关系</li><li>这些技术的历史发展</li><li>这些技术的细节探究</li><li>相关架构的研讨</li></ul><p>内容很多，路也很长，我一步一步走，就今年而言，重点放在以下两个系列。</p><ul><li>DDD 理论/实践总结</li><li>以时间轴为视角，总结各架构核心理念（灵感来源）</li></ul><p>那，就开始吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
