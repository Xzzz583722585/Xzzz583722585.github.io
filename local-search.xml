<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis基础-基本数据结构与对象</title>
    <link href="/2023/05/30/Redis%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/30/Redis%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis基础-基本数据结构与对象"><a href="#Redis基础-基本数据结构与对象" class="headerlink" title="Redis基础 - 基本数据结构与对象"></a>Redis基础 - 基本数据结构与对象</h1><p>我们使用redis时，最直观接触到的就是redis对象及其命令。那我们今天就一起了解下这些对象的实现细节。</p><h1 id="一-基本数据结构"><a href="#一-基本数据结构" class="headerlink" title="一.基本数据结构"></a>一.基本数据结构</h1><h2 id="1-简单动态字符串-SDS"><a href="#1-简单动态字符串-SDS" class="headerlink" title="1.简单动态字符串 SDS"></a>1.简单动态字符串 SDS</h2><p>redis是用C语言实现的，我们需要先认识一下C语言里面的字符串（以下简称C字符串）。</p><p>“Redis\0”这是一个C语言字符串，它具有以下特点：</p><ul><li>必须以 ‘\0’ 空字符结尾</li><li>系统不维护该字符串的长度（不像java的String类型有length），获取字符串长度必须遍历整个字符串，即时间复杂度为 O(n)</li><li>每次更改（缩短或增长）字符串都需要重新内存分配，否则可能造成内存泄漏或缓冲区溢出</li><li>只能保存文本数据</li><li>C语言有相关代码库，支持各类字符串操作</li></ul><p>对于redis而言，只有像log这类字符串一定没有变化的场景会使用C字符串实现以外，其余大多数场景都使用它自己的SDS来实现字符串，例如：</p><ul><li>命令里的key和value SET name “xqz”</li><li>各类嵌套对象 [“a”, “b”]</li><li>缓冲区：AOF缓冲区、客户端的输入输出缓冲区</li><li>等等</li></ul><p>SDS的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDS</span> </span>&#123;<br><span class="hljs-comment">// 记录buf中已经被使用的长度</span><br>  <span class="hljs-keyword">int</span> len;<br>  <span class="hljs-comment">// 记录buf中没有被使用的长度</span><br>  <span class="hljs-keyword">int</span> free;<br>  <span class="hljs-comment">// 实际存储字符串的地方</span><br>  <span class="hljs-comment">// 其末尾以&#x27;\0&#x27;结尾，不记录在上述两个长度内，即SDS实际字符长度为 len+free+1</span><br>  <span class="hljs-keyword">char</span>[] buf;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们可以解释 SDS 名称的由来：</p><ul><li>简单：相比于C字符串，要获取SDS内的字符串长度，可以直接通过len字段，时间复杂度为 O(1)</li><li>动态：每次对 SDS增长时，redis都会自己检查free是否充足，如果不够，那么就会自动进行内存分配以获取足够的空间，即redis保证了不会发生缓冲区溢出</li></ul><p>那么，我们又引申出一个小问题，那就是sds的内存分配策略：</p><ul><li>字符串增长时<ul><li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li><li><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/sds%E4%BF%AE%E6%94%B9.png" alt="sds修改"></li></ul></li><li>字符串减短时<ul><li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li></ul></li></ul><p>总结，SDS相比于C字符串的特点是：</p><ul><li>实际也以 ‘\0’ 空字符结尾</li><li>获取字符串长度的时间复杂度为 O(1)</li><li>每次更改（缩短或增长）字符串，调用者不需要重新内存分配，redis会保证不造成内存泄漏或缓冲区溢出</li><li>sds的所有api都是二进制安全的，即sds不仅可以保存文本数据，还可以保存任意格式的二进制数据</li><li>因为实际以 ‘\0’ 字符结尾，可以使用C语言相关代码库</li></ul><h2 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2.双向链表"></a>2.双向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> </span>&#123;<br>  <span class="hljs-comment">// 头节点指针</span><br>  ListNode head;<br>  <span class="hljs-comment">// 尾节点指针</span><br>  ListNode tail;<br>  <span class="hljs-comment">// 链表总长度</span><br>  uint64 len;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 前一个节点指针</span><br>  ListNode pre;<br>  <span class="hljs-comment">// 后一个节点指针</span><br>  ListNode next;<br>  <span class="hljs-comment">// 指向具体内容的指针</span><br>  Object value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-键值对映射（字典）"><a href="#3-键值对映射（字典）" class="headerlink" title="3.键值对映射（字典）"></a>3.键值对映射（字典）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dict</span> </span>&#123;<br>  <span class="hljs-comment">// 为对象多态服务，DictType保存了针对每种不同类型键值对的特定函数</span><br>  DictType type;<br>  <span class="hljs-comment">// 为对象多态服务，保存了不同特定函数的可选参数</span><br>  Object privData;<br>  <span class="hljs-comment">// ht[0]指向正在使用的hash表，ht[1]正常情况下指向null，rehash过程中指向即将迁移过去的hash表</span><br>  DictHt[] ht;<br>  <span class="hljs-comment">// rehash索引</span><br>  <span class="hljs-keyword">int</span> rehashidx;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictHt</span> </span>&#123;<br>  <span class="hljs-comment">// hash桶，存储具体数据</span><br>  DictEntry[] table;<br>  <span class="hljs-comment">// 桶大小</span><br>  uint64 size; <br>  <span class="hljs-comment">// 桶已使用大小</span><br>  uint64 used;<br>  <span class="hljs-comment">// 用于计算对象下标，sizemask=size-1</span><br>  uint64 sizemask;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictEntry</span> </span>&#123;<br>  <span class="hljs-comment">// 只能是字符串类型</span><br>  Object key;<br>  <span class="hljs-comment">// 对象多态</span><br>  <span class="hljs-comment">// 另外，并没有使用字符串对象处理整数和普通对象，下面讲字符串对象时会涉及</span><br>  union &#123;<br>    <span class="hljs-comment">// value类行为对象</span><br>    Object v;<br>    <span class="hljs-comment">// value类型为无符号整数</span><br>    uint64 u64;<br>    <span class="hljs-comment">// value类型为有符号整数</span><br>    int64 s64;<br>  &#125; value;<br>  <span class="hljs-comment">// 拉链法解决hash冲突：key相同的下一个value对象</span><br>  DictEntry next;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然提到hash，那么着重解决一下几个问题：</p><ul><li>hash函数怎么选择？</li><li>hash冲突如何解决？</li><li>如何维护hash冲突的概率？</li></ul><h3 id="3-1-hash函数如何选择？"><a href="#3-1-hash函数如何选择？" class="headerlink" title="3.1.hash函数如何选择？"></a>3.1.hash函数如何选择？</h3><p>redis选用<a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C">murmurhash2</a>算法生成key对应的hash值，记做hash(key)，则最终插入下标index=hash(key) &amp; ht[x].sizemask。这里面信息量比较大，我们一一介绍：</p><ul><li>若N为2的n次幂，则 H%N = H&amp;(N-1)，这是快速计算方式，并且后续会看到redis保证桶大小为2的n次幂（java的HashMap也有类似设计），这里也解释了为什么会有一个sizemask字段</li><li>ht[x]的含义是，若当前字典不是rehash状态，则x=0，否则x=1</li></ul><h3 id="3-2-hash冲突如何解决？"><a href="#3-2-hash冲突如何解决？" class="headerlink" title="3.2.hash冲突如何解决？"></a>3.2.hash冲突如何解决？</h3><p>一般的hash冲突解决方法有两种：开放定址法和拉链法，redis和java.HashMap均采用拉链法，即将hash到相同桶下标的entry组织成一个链表（java的HashMap在链表长度大于8时，会将该链表转换为一棵红黑树，即平衡树，依次来提高检索效率）。</p><p>另外，此处的链表不是双向链表，所以采用头插法快速添加新节点（多嘴说一句，并发环境下，头插法可能产生循环链表问题，jdk8前后的解决方法并不相同，感兴趣的小伙伴可以搜一搜，但是单线程的redis并不存在这个问题）</p><h3 id="3-3-如何维护hash冲突的概率？"><a href="#3-3-如何维护hash冲突的概率？" class="headerlink" title="3.3.如何维护hash冲突的概率？"></a>3.3.如何维护hash冲突的概率？</h3><p>介绍一个概念：负载因子=桶已被使用的大小/桶总大小，可以看出，若负载因子过大，则产生hash冲突的可能性就更高，若负载因子过小，则空间利用率就变低。因此，根据负载因子大小，在合适的时机调整桶大小就变的尤为重要。</p><p>下面是redis执行的rehash的具体步骤：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%E5%A4%B9/rehash.png" alt="rehash"></p><ul><li>负载因子过大：<ul><li>服务器没有执行 <a href="https://www.runoob.com/redis/server-bgsave.html">BGSAVE</a> 或 <a href="https://www.runoob.com/redis/server-bgrewriteaof.html">BGREWRITEAOF</a> 命令时，&gt;=1，这是因为这些命令都会采取写时复制的手段来优化子进程的执行效率，那么就需要降低非必要的内存写入操作</li><li>服务器执行 BGSAVE 或 BGREWRITEAOF 命令时，&gt;=5</li></ul></li><li>负载因子过小：&lt;0.1</li></ul><p>最后，需要注意，rehash过程不是一次性完成的，而是延迟、渐进式的完成的，其过程是：</p><ol><li>rehash开始，将rehashidx置为0，代表rehash开始</li><li>其后每次对该字典有增删改查（包括rehash开始时的那一次）操作时，都会将ht[0]桶rehashidx位置上的数据重新写入到ht[1]桶内，删除ht[0]桶rehashidx位置上的所有数据，rehashidx++</li><li>当ht[0]桶上所有数据都迁移完成后，将rehashidx置为-1，代表rehash结束</li></ol><p>很明显，在rehash期间，插入操作会直接在ht[1]桶上完成（保证ht[0]只减不增，另外，先插入到ht[0]再rehash到ht[1]也太傻了），删除、更改、查询操作都会先检索ht[0]，数据不存在时再检索ht[1]得到最终结果</p><h2 id="4-跳表"><a href="#4-跳表" class="headerlink" title="4.跳表"></a>4.跳表</h2><p>鉴于大学的数据结构课本或者《算法导论》这样的书上都没有跳表的内容，所以我们得先介绍下跳表这种数据结构（这里奉上原始论文，感兴趣的同学可以看看<a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf%EF%BC%89%E3%80%82">https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf）。</a></p><p>这是一个链表：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/skiplist1.png" alt="skiplist1"></p><p>我们给他加一点索引，用来加快检索速度：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/skiplist2.png" alt="skiplist2"></p><p>当数据量特别大的时候，我们可能需要多层索引，获取更好的检索速度：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/skiplist3.png" alt="skiplist3"></p><p>好了，我们可以做一个优化，即相同元素（初始元素及该元素代表的索引）只使用一个节点即可。</p><p>这就是跳表，我们来看下跳表如何检索一个元素（下述跳表中查找71）：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/skiplist4.png" alt="skiplist4"></p><p>其时间复杂度 = 索引的高度 * 每层索引遍历元素的个数，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。那么跳表的总高度 h = log2n。并且，上层两个索引中间对应的下层索引个数最多为3，即时间复杂度=O(log2n)。</p><p>空间复杂度显然等于 n/2+n/4+…+n/h=O(n)。</p><p>那么，接下来的问题就变成了，随着元素的插入/删除，我们应该如何去维护跳表的索引，以使其保持优良的性能？</p><p>一种设计方案是，还是假设每两个结点会抽出一个结点作为上一级索引的结点，那么当本层元素大于3时，我们就要将其分裂为两部分，并且在上层添加这两部分的索引。删除同理。好了，说到这你应该意识到，这是B树的设计。</p><p>另一种方案，即跳表天才的设计，用概率来维护索引。即每个元素都有1/2的概率建立上层索引，当数据量足够大时，我们有理由相信这种概率建立起来的索引是离散的，即所有元素不会堆积在一起。</p><p>那么，我们来看一下跳表如何插入元素。假设在我们插入元素时，有一个函数randomLevel(x)，其返回值表示应该为这个元素新建几层索引。例如，randomLevel(x)=2，则新建1层索引。我们保证，randomLevel(x)函数有1/2的概率返回1，有1/4的概率返回2，以此类推。有的小伙伴会问，为什么不是randomLevel(x)=1新建一层索引呢？这是因为，只要randomLevel(x)&gt;1那么就会新建第一层的索引，那么randomLevel(x)=1的概率为1/2，就等同于第一层索引不被建立的概率等于1/2，那么，只要randomLevel(x)=2我们再开始建立索引就可以了。</p><p>我们举一个插入87的例子，randomLevel(87)=3，</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/skiplist5.png" alt="skiplist5"></p><p>最后看一眼删除（删除87），我们只需要该元素整个删除即可（包括该元素代表的索引）：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/skiplist6.png" alt="skiplist6"></p><p>至此，我们可以介绍下redis的跳表了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br>  <span class="hljs-comment">// 指向跳表头节点</span><br>  <span class="hljs-comment">// 头节点不是实际的元素节点，即不计算在level、length内</span><br>  SkipListNode header;<br>  <span class="hljs-comment">// 指向跳表尾节点</span><br>  <span class="hljs-comment">// 尾节点是实际的元素节点</span><br>  SkipListNode tail;<br>  <span class="hljs-comment">// 层数最大的节点的层数</span><br>  <span class="hljs-keyword">int</span> level;<br>  <span class="hljs-comment">// 节点个数</span><br>  <span class="hljs-keyword">int</span> length;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 分数，redis跳表通过分数作为元素插入位置的依据</span><br>  <span class="hljs-comment">// 分数按从小到大的顺序排列</span><br>  <span class="hljs-comment">// 不同元素分数可以相同，但是对象不能相同。相同分数的不同对象按照字典序排列。</span><br>  <span class="hljs-keyword">double</span> score;<br>  <span class="hljs-comment">// 对象指针</span><br>  Object obj;<br>  <span class="hljs-comment">// 后退指针，指向紧邻的前一个元素。注意，后退指针不参与跳表的索引结构，就像B+树的叶子结点链表一样，将所有的元素节点连接起来。方便检索范围内的所有数据。</span><br>  SkipListNode backward;<br>  <span class="hljs-comment">// 层（上述的各层索引）</span><br>  <span class="hljs-comment">// Level1-Level32，L1可以看做之前讲的基础数据，L2-L32可以看做索引</span><br>  SkipListLevel[] level;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListLevel</span> </span>&#123;<br>  <span class="hljs-comment">// 前进指针，指向拥有同层索引的下一个节点</span><br>  SkipListNode forward;<br>  <span class="hljs-comment">// 跨度，注意，跨度并不参与实际的检索过程（有疑惑的抛开redis再看看前面的跳表介绍），只是用于计算同层两个节点间的元素个数</span><br>  uint32 span;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们看一下redis如何实现前述的randomLevel(x)函数的：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/randomLevel.png" alt="randomLevel"></p><p>上述代码等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">func <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level+1</span><br>  <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>    level += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，redis设置的SKIPLIST_P=0.25，即每4个元素生成一个上层索引</p><h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSet</span> </span>&#123;<br>  <span class="hljs-comment">// 编码方式（注意与之后对象结构内的编码方式区分）</span><br>  <span class="hljs-comment">// 目前支持：int16、int32、int64</span><br>  uint32 encoding;<br>  <span class="hljs-comment">// 集合长度，即元素个数</span><br>  uint32 length;<br>  <span class="hljs-comment">// 具体数据，不会有重复值，按值大小从小往大排列</span><br>  <span class="hljs-comment">// 需要注意，具体数据类型与编码格式相关，并不是int8类型</span><br>  int8[] contents;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入元素的执行步骤：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/intsetAdd.png" alt="intsetAdd"></p><p>整数数组的特点是：</p><ul><li>灵活：支持不同类型的整数</li><li>节约内存：并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li><li>一旦编码升级，就不会降级了</li></ul><h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h2><p>压缩列表是为节约内存而开发的，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。其编码格式为：</p><table><thead><tr><th align="left">记录整个压缩列表占用的内存字节数</th><th align="left">记录压缩列表尾节点距离起始位置的字节数</th><th align="left">记录节点个数</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">特殊值0xFF，标志压缩列表结尾</th></tr></thead><tbody><tr><td align="left">zlbytes</td><td align="left">zltail</td><td align="left">zllen</td><td align="left">entry1</td><td align="left">…</td><td align="left">entryn</td><td align="left">zlend</td></tr><tr><td align="left">4B</td><td align="left">4B</td><td align="left">2B</td><td align="left">不定</td><td align="left">不定</td><td align="left">不定</td><td align="left">1B</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>根据压缩列表地址p和zltail，我们可以计算出尾节点的起始位置p+zltail</li><li>若节点数&lt;65535，则zllen代表真实的节点数量，否则真实数量只能通过遍历压缩列表得到</li></ul><p>其中，entry的编码格式为：</p><table><thead><tr><th align="left">前一节点的长度（单位：B）</th><th align="left">记录了content的数据类型和长度</th><th align="left">具体值</th></tr></thead><tbody><tr><td align="left">previous_entry_length</td><td align="left">encoding</td><td align="left">content</td></tr><tr><td align="left">1B or 5B</td><td align="left">1B、2Bor5B</td><td align="left">不定</td></tr></tbody></table><p>特殊说明：</p><ul><li>previous_entry_length<ul><li>若前一节点长度小于254B，则其长度就保存在1B内</li><li>否则，previous_entry_length长度为5B，其第一字节被设置为固定值0xFE（254），后4字节保存前一节点的实际长度</li></ul></li><li>encoding<ul><li>字节数组编码<ul><li>1B，00开头，content长度由去除头两位的其余位表达</li><li>2B，01开头，content长度由去除头两位的其余位表达</li><li>5B，10开头，content长度由去除头两位的其余位表达</li></ul></li><li>整数编码<ul><li>1B，11开头，不同编码代表了不同的int类型</li><li>特殊的，1111开头，对应节点没有content字段，剩余四位表达具体数据</li></ul></li></ul></li></ul><p>压缩列表的遍历方式：</p><ol><li>根据压缩列表起始地址p和zltail，计算出尾节点的起始位置 pn=p+zltail</li><li>根据pn，获取到pn-1的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>根据pn-1，获取到pn-2的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>…</li><li>根据p1，获取到p0的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>结束遍历</li></ol><p>最后，当我们插入或者删除数据时，有可能会导致原本用1B记录前一节点大小的previous_entry_length不够用了，从而引发一连串的节点更新，这种现象就叫做“连锁更新”</p><h1 id="二-对象"><a href="#二-对象" class="headerlink" title="二.对象"></a>二.对象</h1><p>首先，redis数据库中的数据都是通过键值对（字典）的形式组织的。其中，键key永远是字符串对象。</p><p>其次，redis中只有字符串对象可以被嵌套使用，其余对象（list、set、zset、hash对象）都不可以互相嵌套使用。例如，[“a”, “b”]是允许的，但[{“k1”: “v1”}, {“k2”: “v2”}]是不允许的。</p><p>下面是redis对象的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisObject</span> </span>&#123;<br>  <span class="hljs-comment">// 类型</span><br>  uint4 type;<br>  <span class="hljs-comment">// 具体的数据结构</span><br>  uint4 encoding;<br>  <span class="hljs-comment">// 引用计数</span><br>  <span class="hljs-keyword">int</span> refcount;<br>  <span class="hljs-comment">// 对象最后一次被命令程序访问的时间点</span><br>  <span class="hljs-keyword">int</span> lru;<br>  <span class="hljs-comment">// 指针，指向具体对象</span><br>  Object ptr;<br>&#125;<br><br><span class="hljs-comment">// 查看key对应的value.type</span><br>TYPE &#123;key&#125;<br><span class="hljs-comment">// 查看key对应的value.encoding</span><br>OBJECT ENCODING &#123;key&#125;<br></code></pre></td></tr></table></figure><h2 id="1-string对象"><a href="#1-string对象" class="headerlink" title="1.string对象"></a>1.string对象</h2><p>string对象可以用来存储整数（12345）、浮点数（123.45）、字符串（“xqz”），其底层的实现方式是不同的，我们逐个探讨。</p><h3 id="1-1-整数"><a href="#1-1-整数" class="headerlink" title="1.1.整数"></a>1.1.整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = <span class="hljs-keyword">int</span><br>obj.ptr = 具体的整数<br></code></pre></td></tr></table></figure><h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2.字符串"></a>1.2.字符串</h3><p>当创建的字符串长度 &gt; 39B时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = raw<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>当创建的字符串长度 &lt;= 39B时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>可以看到，存储字符串时，底层数据结构都是sds，但是具体的编码方式不同：</p><table><thead><tr><th align="left">编码</th><th align="left">内存结构</th><th align="left">读写操作</th></tr></thead><tbody><tr><td align="left">raw</td><td align="left">obj和sds分开申请，两片独立的内存空间，使用ptr指针连接</td><td align="left">可读/可写</td></tr><tr><td align="left">embstr</td><td align="left">obj和sds同时申请，一片连续的内存空间，使用ptr指针连接</td><td align="left">只读</td></tr></tbody></table><h3 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3.浮点数"></a>1.3.浮点数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>浮点数实际是通过字符串来存储的，在浮点数计算时，redis从sds内取出字符串，转换成浮点数进行计算，并将计算结果再次转换成字符串进行存储。另外，过长的整型数也是通过这种方式存储的。</p><h3 id="1-4-编码转换"><a href="#1-4-编码转换" class="headerlink" title="1.4.编码转换"></a>1.4.编码转换</h3><p>当我们执行操作将整形数据变为字符串时，该对象的编码格式也变成了raw，如 1+”a”这种操作。</p><p>之前也提到，embstr是只读的，所以当我们修改embstr编码的字符串时，其底层编码也会变为raw。</p><h2 id="2-list对象"><a href="#2-list对象" class="headerlink" title="2.list对象"></a>2.list对象</h2><p>同时满足以下两个条件的list对象使用ziplist编码，即压缩列表数据结构，否则使用linkedlist编码，即双向链表数据结构。</p><ol><li>list中元素个数小于512（list-max-ziplist-entries可调）</li><li>list中所有字符串元素长度小于64字节（list-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到linkedlist，将保存在压缩列表的元素遍历取出，转成双向链表节点保存。</p><p>反之，若一开始是linkedlist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><p>另外，redis 3.2版本后引入quicklist数据结构，本文暂不介绍。</p><h3 id="2-1-ziplist编码"><a href="#2-1-ziplist编码" class="headerlink" title="2.1.ziplist编码"></a>2.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><h3 id="2-2-linkedlist编码"><a href="#2-2-linkedlist编码" class="headerlink" title="2.2.linkedlist编码"></a>2.2.linkedlist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = linkedlist<br>obj.ptr = 双向链表对象<br></code></pre></td></tr></table></figure><h2 id="3-hash对象"><a href="#3-hash对象" class="headerlink" title="3.hash对象"></a>3.hash对象</h2><p>同时满足以下两个条件的hash对象使用ziplist编码，即压缩列表数据结构，否则使用ht编码，即字典数据结构。</p><ol><li>hash中元素个数小于512（hash-max-ziplist-entries可调）</li><li>hash中所有字符串元素（键或值）长度小于64字节（hash-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在压缩列表的元素遍历取出，转成字典节点保存。</p><p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="3-1-ziplist编码"><a href="#3-1-ziplist编码" class="headerlink" title="3.1.ziplist编码"></a>3.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><p>插入元素时，会先往压缩列表中添加键对象，再往压缩列表中添加值对象。</p><h3 id="3-2-ht编码"><a href="#3-2-ht编码" class="headerlink" title="3.2.ht编码"></a>3.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure><h2 id="4-set对象"><a href="#4-set对象" class="headerlink" title="4.set对象"></a>4.set对象</h2><p>同时满足以下两个条件的set对象使用intset编码，即整数集合数据结构，否则使用ht编码，即字典数据结构。</p><ol><li>set中元素个数小于512（set-max-ziplist-entries可调）</li><li>set中所有元素均为整数</li></ol><p>若一开始是intset编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在整数集合的元素遍历取出，转成字典节点保存。</p><p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="4-1-intset编码"><a href="#4-1-intset编码" class="headerlink" title="4.1.intset编码"></a>4.1.intset编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = intset<br>obj.ptr = 整数集合对象<br></code></pre></td></tr></table></figure><h3 id="4-2-ht编码"><a href="#4-2-ht编码" class="headerlink" title="4.2.ht编码"></a>4.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure><p>实现类似于java的HashSet，即字典键保存数据，字典值为NULL。</p><h2 id="5-zset有序集合对象"><a href="#5-zset有序集合对象" class="headerlink" title="5.zset有序集合对象"></a>5.zset有序集合对象</h2><p>同时满足以下两个条件的zset对象使用ziplist编码，即压缩列表数据结构，否则使用skiplist编码，这里指跳表+字典数据结构。</p><ol><li>zset中元素个数小于128（zset-max-ziplist-entries可调）</li><li>zset中所有字符串元素长度小于64字节（zset-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到skiplist，将保存在压缩列表的元素遍历取出，转成跳表+字典节点保存。</p><p>反之，若一开始是skiplist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="5-1-ziplist编码"><a href="#5-1-ziplist编码" class="headerlink" title="5.1.ziplist编码"></a>5.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><p>插入元素时，会遍历压缩列表所有元素，根据score从小往大的顺序（即靠近表头位置的元素score小），先往压缩列表中添加数据对象，再往压缩列表中添加score对象。</p><h3 id="5-2-skiplist编码"><a href="#5-2-skiplist编码" class="headerlink" title="5.2.skiplist编码"></a>5.2.skiplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = skiplist<br>obj.zsl = 跳表对象<br>obj.dict = 字典对象<br></code></pre></td></tr></table></figure><p>跳表中元素按score从小往大的顺序排列。</p><p>字典键等于数据元素（string类型），字典值等于score（double类型），即该字典的作用时从元素映射到对应score。</p><p>为什么需要跳表+字典两个数据结构？速度。如前所述，跳表可以提供优秀的范围查找能力，字典做不到。字典可以O(1) 地查看元素分值，跳表做不到（需要遍历找到节点）。</p><p>最后一点，跳表与字典对应的底层数据对象，是共用的，这是为了节约空间。</p><h1 id="三-对象其他细节"><a href="#三-对象其他细节" class="headerlink" title="三.对象其他细节"></a>三.对象其他细节</h1><h2 id="1-命令类型检查"><a href="#1-命令类型检查" class="headerlink" title="1.命令类型检查"></a>1.命令类型检查</h2><p>大体上可以将redis的操作键的命令分为两类</p><ol><li>可以对任意对象类型生效</li><li>只对命令绑定的对象类型生效</li></ol><p>对于第二种类型命令，redis会根据obj.type字段，在执行命令前主动检查：</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/checkobject.png" alt="checkobject"></p><h2 id="2-命令多态实现"><a href="#2-命令多态实现" class="headerlink" title="2.命令多态实现"></a>2.命令多态实现</h2><ul><li>基于类型的多态：可以对任意对象类型生效的命令，会根据value对象具体类型，做不同处理</li><li>基于编码的多态：作用到具体对象上的命令，会根据对象编码，调用对应数据结构API实现命令</li></ul><h2 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3.内存回收机制"></a>3.内存回收机制</h2><p>c语言不像java，java虚拟机会帮助程序员管理对象占用的内存，在对象不被使用时自动释放内存。redis使用引用计数算法实现了一套内存管理机制，现简单介绍。</p><p>首先了解下redis对象生命周期</p><p><img src="/Users/xiaoqizong/Desktop/%E9%A1%B9%E7%9B%AE/redis/objectlife.png" alt="objectlife"></p><p>与之对应的，之前说到的obj.refcount值是这样变化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建一个对象时，refcount初始化为1，因为不论有无key对象，服务器都需要持有这个对象</span><br>Object obj = <span class="hljs-keyword">new</span> StringObject();<br><br><span class="hljs-comment">// 对象被新程序使用时，调用incrRefCount(obj)函数，obj.refcount++</span><br><span class="hljs-comment">// 对象不再被新程序使用时，调用decrRefCount(obj)函数，obj.refcount--</span><br>...<br>  <br><span class="hljs-comment">// 最终，调用decrRefCount(obj)函数，将obj.refcount减为0，会导致该对象被redis服务器回收，内存被释放</span><br>decrRefCount(obj);<br></code></pre></td></tr></table></figure><p>涉及到函数列表：</p><table><thead><tr><th align="left">函数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">incrRefCount()</td><td align="left">refcount++</td></tr><tr><td align="left">decrRefCount()</td><td align="left">refcount–</td></tr><tr><td align="left">resetRefCount()</td><td align="left">refcount=0，但是不会释放对象</td></tr></tbody></table><h2 id="4-对象共享机制"><a href="#4-对象共享机制" class="headerlink" title="4.对象共享机制"></a>4.对象共享机制</h2><p>类似于java常量池机制，redis也会将常用字符串做为“常量”共享起来。在redis初始化服务器时，会创建0-9999共一万个整数字符串（通过redis.h/REDIS_SHARED_INTEGERS设置），后续共享使用。这些对象不仅是字符串对象可以共享，前述所有类型对象都可以使用。</p><p>但是，需要注意，redis只支持整数字符串的共享，这主要是因为要共享一个对象，当然需要判断两个引用对应的对象是否一致，整数对象可以在O(1)时间内验证，但当字符串复杂时，或其他结构的对象时（如list），这个验证过程会很消耗CPU并且不可控。</p><p>最后需要注意，当对象被共享时，其refcount++。</p><h2 id="5-对象空转时长"><a href="#5-对象空转时长" class="headerlink" title="5.对象空转时长"></a>5.对象空转时长</h2><p>前面提到的obj.lru记录了该对象最后一次被命令程序访问的时间点。</p><p>我们可以通过 OBJECT IDLETIME 命令查看值对象的 空转时长=当前时间-obj.lru。这个命令比较特殊，不会刷新obj.lru的值。</p><p>空转时长是当服务器内存不够时，用来判断该对象是否可以被回收时使用的，这个之后的专题会详细介绍。</p><p>至此，我们了解了redis所有的对象及其底层数据结构，希望对大家的工作学习有所帮助，谢谢～</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SAC-003-REST</title>
    <link href="/2021/09/08/SAC-003-REST/"/>
    <url>/2021/09/08/SAC-003-REST/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>架构级别的所有设计决策都应该在所设计系统的功能、行为和社会需求的背景下做出，这是一个同样适用于软件架构和传统建筑架构领域的原则。“形式追随功能”的准则来自数百年失败的构建项目的经验，但经常被软件从业者忽视。</p><p>改变应用程序的交互方式对性能的影响比所使用的通信协议更大。</p><p>一般而言，基于网络的体系结构和软件体系结构之间的主要区别在于，如果可以在运行时基于组件的位置选择更有效的机制，则组件之间的通信仅限于消息传递或等效于消息传递。</p><p>分布式系统在用户看来就像一个普通的集中式系统，但运行在多个独立的 CPU 上。相比之下，基于网络的系统是那些能够跨网络运行的系统，但不一定以对用户透明的方式运行。在某些情况下，用户需要了解需要网络请求的操作与可在其本地系统上满足的操作之间的区别，特别是当网络使用意味着额外的交易成本时 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。</p><p>应用程序软件架构是整个系统的抽象级别，其中用户操作的目标可表示为功能架构属性。</p><p>这与网络抽象形成对比，网络抽象的目标是将位从一个位置移动到另一个位置，而不考虑为什么移动这些位。只有在应用程序级别，我们才能根据每个用户操作的交互次数、应用程序状态的位置、所有数据流的有效吞吐量（相对于单个数据流的潜在吞吐量）来评估设计权衡)、每个用户操作执行的通信范围等。</p><p>基于网络的应用程序的性能首先受应用程序需求的约束，然后是选择的交互方式，其次是实现的架构，最后是每个组件的实现。</p><p>关于基于网络的应用程序的一个有趣观察是，最好的应用程序性能是通过不使用网络来获得的。这实质上意味着基于网络的应用程序最有效的架构风格是那些在可能的情况下可以有效地最大限度地减少网络使用的风格，通过重用先前的交互（缓存），减少网络交互的频率与用户操作（复制数据和断开连接的操作）相关，或者通过将数据处理移动到更靠近数据源（移动代码）来消除某些交互的需要。</p><p>可修改性是指对应用程序架构进行更改的难易程度。可修改性可以进一步分解为可进化性、可扩展性、可定制性、可配置性和可重用性，如下所述。基于网络的系统的一个特别关注点是动态可修改性，其中对已部署的应用程序进行修改而无需停止和重新启动整个系统。</p><p>即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。由于参与基于网络的应用程序的组件可能分布在多个组织边界，因此系统必须为渐进的、碎片化的变化做好准备，在这种变化中，新旧实现并存，同时又不妨碍新实现利用其扩展功能。</p><p>构建软件的目的不是创建特定的交互拓扑或使用特定的组件类型——而是创建一个满足或超过应用程序需求的系统。为系统设计选择的架构风格必须符合这些需求，而不是相反。因此，为了提供有用的设计指导，架构风格的分类应该基于这些风格所引发的架构特性。</p><p>Berners-Lee [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_20">20</a> ] 写道，“Web 的主要目标是成为一个共享的信息空间，通过它人和机器可以进行通信。” 人们需要一种方法来存储和构建他们自己的信息，无论是永久的还是短暂的，以便他们自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护本地副本。</p><p>该系统的预期最终用户位于世界各地，通过互联网连接的各个大学和政府高能物理研究实验室。他们的机器是终端、工作站、服务器和超级计算机的异构集合，需要操作系统软件和文件格式的大杂烩。信息范围从个人研究笔记到组织电话列表。面临的挑战是构建一个系统，该系统将为这种结构化信息提供普遍一致的接口，可在尽可能多的平台上使用，并且随着新人员和组织加入项目而逐步部署。</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此体系结构需要最大限度地减少网络交互（数据传输协议内的往返）。</p><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p><p>假设 I：WWW 体系结构背后的设计原理可以用一种体系结构风格来描述，该体系结构风格由应用于 Web 体系结构中元素的一组约束组成。</p><p>假设二：可以在 WWW 架构风格中添加约束，以推导出一种新的混合风格，更好地反映现代 Web 架构所需的属性。</p><p>假设 III：可以将修改 Web 架构的建议与更新的 WWW 架构风格进行比较，并在部署之前分析冲突。</p><h1 id="XML-RPC"><a href="#XML-RPC" class="headerlink" title="XML-RPC"></a>XML-RPC</h1><p><strong>XML-RPC</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a>（Remote Procedure Call，RPC）的<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算</a><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2%E5%8D%94%E8%AD%B0">协议</a>，通过<a href="https://zh.wikipedia.org/wiki/XML">XML</a>将调用函数封装，并使用<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>协议作为发送机制。</p><p>XML-RPC 消息是一个 HTTP-POST 请求。请求的正文采用 XML 格式。一个过程在服务器上执行，它返回的值也采用 XML 格式。</p><p>过程参数可以是标量、数字、字符串、日期等；也可以是复杂的记录和列表结构。</p><p>下面是一个 XML-RPC 请求的例子：</p><p>必须指定用户代理和主机。</p><p>内容类型是 text/xml。</p><p>必须指定 Content-Length 并且必须正确。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">POST /RPC2 HTTP/1.0<br>User-Agent: Frontier/5.1.2 (WinNT)<br>Host: betty.userland.com<br>Content-Type: text/xml<br>Content-length: 181<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodCall</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">methodName</span>&gt;</span>examples.getStateName<span class="hljs-tag">&lt;/<span class="hljs-name">methodName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i4</span>&gt;</span>41<span class="hljs-tag">&lt;/<span class="hljs-name">i4</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodCall</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是对 XML-RPC 请求的响应示例：</p><p>除非出现低级错误，否则总是返回 200 OK。</p><p>内容类型是 text/xml。Content-Length 必须存在且正确。</p><p>响应的主体是单个 XML 结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 158<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:08 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>South Dakota<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>故障示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 426<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:02 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">fault</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">struct</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultCode<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">int</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">int</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultString<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Too many parameters.<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">struct</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">fault</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>XML-RPC发表于1998年，由<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>（<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>）的<a href="https://zh.wikipedia.org/w/index.php?title=Dave_Winer&action=edit&redlink=1">Dave Winer</a>及<a href="https://zh.wikipedia.org/wiki/Microsoft">Microsoft</a>共同发表[<a href="https://zh.wikipedia.org/wiki/XML-RPC#cite_note-2">2]</a>。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的<a href="https://zh.wikipedia.org/wiki/SOAP">SOAP</a>协议。</p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>SOAP 的最初意图相当温和：编写如何发送 <em>瞬态</em>XML 文档以触发远程主机上的操作或响应的方法。OAP 1.2 版提供了基于 XML 的信息的定义，该信息可用于在分散的分布式环境中的对等点之间交换结构化和类型化信息。</p><p><strong>SOAP</strong>（原为<strong>Simple Object Access Protocol</strong>的<a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E5%86%99">首字母缩写</a>，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，使用在计算机网络<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1">Web服务</a>（web service）中，交换带结构的信息。SOAP为了简化网页服务器（Web Server）从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>通信协议，遵从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><p>目前SOAP 1.1版是业界共同的标准，属于第二代的XML协议（第一代具主要代表性的技术为XML-RPC以及WDDX）</p><p>用一个简单的例子来说明SOAP使用过程，一个SOAP消息可以发送到一个具有Web Service功能的Web站点，例如，一个含有房价信息的数据库，消息的参数中标明这是一个查询消息，此站点将返回一个XML格式的信息，其中包含了查询结果（价格，位置，特点，或者其他信息）。由于数据是用一种标准化的可分析的结构来传递的，所以可以直接被第三方站点所利用。</p><ul><li>SOAP封装（envelope）：定义了一个框架，描述消息中的内容是什么、是谁发送的、谁应当接受并处理它以及如何处理它们；</li><li>SOAP编码规则（encoding rules）：定义了一种<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的机制，用于表示应用程序需要使用的数据类型的实例；</li><li>SOAP RPC表示（RPC representation）：定义了一个协定，用于表示远程过程调用和应答；</li><li>SOAP绑定（binding），它定义了SOAP使用哪种协议交换信息。使用<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>/<a href="https://zh.wikipedia.org/wiki/TCP">TCP</a>/<a href="https://zh.wikipedia.org/wiki/UDP">UDP</a>协议都可以。</li></ul><p>把SOAP绑定到HTTP的方式，同时利用了SOAP的样式和分散的灵活性特点以及HTTP的丰富特征库的优点。在HTTP上传送SOAP并不意味着SOAP会覆盖现有的HTTP语义，而是HTTP上的SOAP语义会自然地映射到HTTP语义。在使用HTTP作为协议绑定的场合中，RPC请求映射到HTTP请求上，而RPC应答映射到HTTP应答。然而，在RPC上使用SOAP并不仅限于HTTP协议绑定。</p><p>SOAP使用因特网应用层协议作为其传输协议。<a href="https://zh.wikipedia.org/wiki/SMTP">SMTP</a>以及<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>协议都可以用来传输SOAP消息，但是由于HTTP在如今的因特网结构中工作得很好，特别是在网络防火墙下仍然正常工作，所以被广泛采纳。SOAP亦可以在<a href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>上传输。</p><p>SOAP的消息格式采用<a href="https://zh.wikipedia.org/wiki/XML">XML</a>。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>定义了 SOAP 信封，它是一种结构，它定义了一个整体框架，用于表示 SOAP 消息的内容，确定谁应该处理全部或部分消息，以及处理这些部分是可选的还是强制性的。它还定义了一个协议绑定框架，它描述了如何编写将 SOAP 绑定到另一个底层协议的规范。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a>定义了<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP</a>的数据模型，一种特定的数据类型编码方案，可用于传送远程过程调用 (RPC)，以及[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1] 中</a>定义的底层协议绑定框架的一个具体实现。此绑定允许将 SOAP 消息作为 HTTP POST 请求和响应的有效负载进行交换，或者作为对 HTTP GET 的响应中的 SOAP 消息进行交换。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>描述了一个抽象特性，用于优化特定类型内容的 SOAP 消息的有线格式，以及它在 HTTP 绑定中实现的具体实现，同时仍将 SOAP 消息建模为单个 XML 信息集.</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP]</a>定义了一种更有效地序列化具有二进制内容的 XML 信息集的约定。 [<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>利用 [ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP</a> ] 格式来优化 SOAP 消息的传输。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L4299">ResRep]</a>指定了一个 SOAP 头块，它携带 Web 资源的表示，这是处理 SOAP 消息所需要的，但接收者不愿意或不能通过取消引用消息中携带的资源的 URI 来获得。</p><p>SOAP 从根本上是一种无状态的单向消息交换范例，但应用程序可以通过将此类单向交换与底层协议提供的功能相结合来创建更复杂的交互模式（例如，请求/响应、请求/多响应等）和/或特定于应用程序的信息。SOAP 对它所传达的任何特定于应用程序的数据的语义保持沉默，因为它涉及诸如 SOAP 消息的路由、可靠的数据传输、防火墙穿越等问题。但是，SOAP 提供了一个框架，通过该框架，特定于应用程序的信息可以以可扩展的方式传达。此外，SOAP 提供了 SOAP 节点在接收 SOAP 消息时采取的所需操作的完整描述。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/primer-figure-1.png" alt="primer-figure-1"></p><p>SOAP标头元素是可选的，但它已被包括在示例来解释SOAP的某些特征。SOAP 标头是一种扩展机制，它提供了一种在 SOAP 消息中传递不是应用程序有效负载的信息的方法。这种“控制”信息包括例如与消息处理相关的传递指令或上下文信息。这允许以特定于应用程序的方式扩展 SOAP 消息。该元素的直接子元素<code>env:Header</code>称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#encapsulation"> 标头块</a>，代表数据的逻辑分组，如下所示，可以单独针对 SOAP 节点，这些节点在从发送方到最终接收方的消息路径中可能会遇到。SOAP 标头的设计考虑到 SOAP 的各种用途，其中许多将涉及其他 SOAP 处理节点（称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts"> SOAP 中介）</a>的参与，沿着从<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">初始 SOAP 发送方</a>到<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">最终 SOAP 接收</a><a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">方</a>的消息路径。这允许 SOAP 中介提供增值服务。标题，如后所示，可以被沿<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">SOAP 消息路径</a>遇到的 SOAP 节点检查、插入、删除或转发. （不过，应该记住，SOAP 规范不处理头元素的内容，或者 SOAP 消息如何在节点之间路由，或者确定路由的方式等等。这些是整个应用程序的一部分，并且可能是其他规范的主题。）</p><p>SOAP Version 1.2 是一个简单的消息传递框架，用于在初始 SOAP 发送方和最终 SOAP 接收方之间传输以 XML 信息集形式指定的信息。更有趣的场景通常涉及这两个节点之间的多个消息交换。最简单的这种交换是请求-响应模式。[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R11">SOAP 1.1</a> ] 的一些早期使用强调使用这种模式作为传送远程过程调用 (RPC) 的手段，但重要的是要注意并非所有 SOAP 请求-响应交换都可以或需要建模为 RPC。当需要对某个程序行为建模时使用后者，交换的消息符合远程调用及其返回的预定义描述。比请求-响应模式所涵盖的更多的使用场景集可以简单地建模为在 SOAP 消息中交换的基于 XML 的内容以形成来回“对话”，其中语义处于发送和接收应用程序。</p><p>SOAP 1.2 版的设计目标之一是使用 XML 的可扩展性和灵活性封装远程过程调用功能。尽管用于 RPC 的 SOAP 的大多数示例都使用 HTTP 协议绑定，但它并不仅限于这种方式。要调用 SOAP RPC，需要以下信息：</p><ol><li>目标 SOAP 节点的地址。</li><li>过程或方法名称。</li><li>要传递给过程或方法的任何参数的标识和值以及任何输出参数和返回值。</li><li>用于识别作为 RPC 实际目标的 Web 资源的参数的明确分离，与传送用于处理目标资源调用的数据或控制信息的参数形成对比。</li><li>将用于传达 RPC 的消息交换模式，以及要使用的所谓“Web 方法”（稍后将详细介绍）的标识。</li><li>可选地，可以作为 SOAP 头块的一部分携带的数据。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:reference</span>&gt;</span>uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:20:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">m:reservation</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itinerary</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-14<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>late afternoon<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>&gt;</span>aisle<span class="hljs-tag">&lt;/<span class="hljs-name">p:seatPreference</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-20<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>mid-morning<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itinerary</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">q:lodging</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:q</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/hotels&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">q:preference</span>&gt;</span>none<span class="hljs-tag">&lt;/<span class="hljs-name">q:preference</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">q:lodging</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span> =<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   &lt; m:reference&gt;uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:35:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span> <br>  &lt;/m:reservation &gt; <br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env</span> <span class="hljs-attr">:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itineraryClarification</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span> &gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>          JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span> <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span> <br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>         JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>     &lt;/p:arriving &gt; <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itineraryClarification</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">xmlns:rpc</span>=<span class="hljs-string">&#x27;http://www.w3.org/2003/05/soap-rpc&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">env:Fault</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Code</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>env:Sender<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Subcode</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>rpc:BadArguments<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">env:Subcode</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Code</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Reason</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span>Processing error<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;cs&quot;</span>&gt;</span>Chyba zpracování<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Reason</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Detail</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">e:myFaultDetails</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:e</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/faults&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:message</span>&gt;</span>Name does not match card number<span class="hljs-tag">&lt;/<span class="hljs-name">e:message</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:errorcode</span>&gt;</span>999<span class="hljs-tag">&lt;/<span class="hljs-name">e:errorcode</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">e:myFaultDetails</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Detail</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">env:Fault</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>头块和正文的进一步处理取决于SOAP 节点为处理给定消息所承担的<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts"> 角色</a>。SOAP 定义了（可选）<code>env:role</code>属性 - 在语法上， <code>xs:anyURI</code>- 可能出现在头块中，它标识该头块的预期目标所扮演的角色。如果 SOAP 节点承担由 URI 的值标识的角色，则它需要处理头块。</p><p>为了确保 SOAP 节点不会忽略对应用程序的总体目的很重要的头块，SOAP 头块还提供了附加的可选属性<code>env:mustUnderstand</code>，如果为“true”，则意味着目标 SOAP 节点<em>必须</em>根据该块的规范处理该块。</p><p>为了规避处理模型的默认规则，使用附加属性标记标题块<code>env:relay</code> 值为“true”时允许中介在它选择不处理它的情况下转发针对它自己的标头块。</p><p>SOAP 消息可以使用各种“底层”协议进行交换，包括其他应用层协议。SOAP 消息如何使用底层协议从一个 SOAP 节点传递到另一个节点的规范称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts">SOAP 绑定</a>。[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>以[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R12">XML Infoset</a> ]的形式定义了一个SOAP 消息，即，根据称为the <code>env:Envelope</code>（参见<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#soapenv">SOAP Part 1，第5 节</a>）的抽象“文档”的元素和属性信息项 。但是，SOAP 消息可能会在发送方和最终接收方之间经过几跳，其中每一跳可能是不同的协议绑定。换言之，在一个跳跃中由协议绑定支持的特征（例如，消息相关性、可靠性等）可能不被沿消息路径的另一个支持。SOAP 本身并没有提供任何机制来隐藏不同底层协议提供的特性差异。但是，特定应用程序需要的任何端到端或多跳特性，但在<em>预期</em>消息路径上的底层基础设施中可能不可用，可以通过作为 SOAP 的一部分携带来补偿消息信息集，即作为某个模块中指定的 SOAP 头块。应用程序设计者必须解决许多问题才能完成特定的应用程序语义，包括如何利用可用于所选环境的底层协议的本机特性</p><p>功能描述由 URI 标识，因此所有引用它的应用程序都确保具有相同的语义。特征由<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#bindprops">属性</a>限定，提供有助于实现该功能的附加信息。当 RPC 定义使得其方法描述的所有部分都可以描述为资源标识时，RPC 的整个目标可以由 URI 标识。如果应用程序需要使用只能在 SOAP 信息集中具有特定于绑定的表达式的功能，即使用 SOAP 标头块，则应用程序必须选择 HTTP POST 方法，并在请求正文中包含 SOAP 消息.如果 RPC 描述包含非资源识别的数据（参数），它还需要使用通过 HTTP POST 实现的<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>。即使在这种情况下，带有 SOAP 消息的 HTTP POST 也可以以 Web 友好的方式表示。与 GET 的使用一样，[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a> 建议在一般情况下，在 HTTP 请求 URI 中标识用于标识请求被 POST 到的资源的 SOAP 消息的任何部分。当然，相同的参数可以保留在 SOAP<code>env:Body</code>元素中。（在基于 SOAP 的 RPC 的情况下，参数必须保留在主体中，因为这些参数与接收应用程序期望的过程/方法描述相关。）</p><p>SOAP 规范中的建议是以 Web 架构兼容的方式使用 URI - 即作为资源标识符 - 无论使用的是 GET 还是 POST。</p><p>HTTP 具有众所周知的连接模型和消息交换模式。客户端通过 URI 识别服务器，使用底层 TCP/IP 网络连接到它，发出 HTTP 请求消息并通过相同的 TCP 连接接收 HTTP 响应消息。HTTP 隐式地将其请求消息与其响应消息相关联；因此，使用此绑定的应用程序可以选择推断 HTTP 请求消息正文中发送的 SOAP 消息与 HTTP 响应中返回的 SOAP 消息之间的相关性。类似地，HTTP 通过 URI 标识服务器端点，即<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2">Request-URI</a>，它也可以用作服务器上 SOAP 节点的标识。HTTP 允许在初始客户端和由 Request-URI 标识的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html#sec1.3">源服务器</a>之间存在多个中介 ，在这种情况下，请求/响应模型是一系列这样的对。但是请注意，HTTP 中介与 SOAP 中介不同。SOAP Part2中的 HTTP 绑定利用<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#WebMethodFeature">SOAP Web 方法特性</a>来允许应用程序选择所谓的 Web 方法——将其限制为 GET 或 POST 之一——以通过 HTTP 消息交换使用。此外，它还利用了两种消息交换模式，为应用程序提供了两种通过 HTTP 交换 SOAP 消息的方式：1) 使用 HTTP POST 方法在 HTTP 请求和响应消息的正文中传送 SOAP 消息，以及 2)在 HTTP 请求中使用 HTTP GET 方法在 HTTP 响应的正文中返回 SOAP 消息。第一种使用模式是称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>的绑定特性的 HTTP 特定实例，而第二种使用称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#soapresmep">SOAP 响应消息交换模式</a>。由于 HTTP SOAP GET 用法不允许请求中包含 SOAP 消息，因此在出站交互中需要功能的应用程序显然不能由 SOAP 信息集中的绑定特定表达式（即，作为 SOAP 标头块）支持利用这种消息交换模式。请注意，HTTP POST 绑定可用于所有情况。SOAP 使用 HTTP 传输，遵循 HTTP 状态代码的语义以在 HTTP 中传递状态信息。</p><p>万维网最核心的概念之一是作为资源标识符的 URI。使用 HTTP 绑定并希望与其他 Web 软件互操作的 SOAP 服务应该使用 URI 来寻址其服务中的所有重要资源。例如，万维网的一个非常重要（实际上占主导地位）的用途是纯信息检索，其中由 URI 标识的可用资源的表示是使用 HTTP GET 请求获取的，而不会以任何方式影响资源。（这在 HTTP 术语中称为<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1">安全且幂等的方法</a>。）关键点是资源的发布者提供其 URI，消费者可以“获取”该 URI。在许多情况下，SOAP 消息被设计用于纯粹用于信息检索的用途，例如请求某些资源（或对象，在编程术语中）的状态，而不是执行资源操作的用途。在这种情况下，使用 SOAP 主体来携带状态请求，主体的一个元素代表所讨论的对象，被视为与 Web 精神背道而驰，因为资源不是由请求标识的—— HTTP GET 的 URI。（在一些 SOAP/RPC 实现中，HTTP 请求 URI 通常不是资源本身的标识符，而是一些必须评估 SOAP 消息以识别资源的中间实体。）</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>为了方便后续讨论 REST 和 RESTful Api，我们先说 HTTP 协议的资源、请求方法与响应码的定义。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>HTTP 请求的目标称为<strong>资源</strong>。 每个资源都由统一资源标识符 URI 标识。人们很容易将 URI 视为远程文件系统路径名，并将该资源的表示视为此类文件的副本。但即使将 URI 映射机制绑定到文件系统，服务端也可能被配置为以请求作为输入执行文件，并将输出作为表示进行响应，而不是直接传输文件。无论如何，只有服务端需要知道它的每个 URI 如何对应于一个实现，以及每个实现如何管理、如何发送目标资源的当前表示以响应 GET 方法等工作。</p><p>HTTP 不限制资源的性质，资源可以是任何东西，例如一份文档，亦或是数据库中存储的数据，等等。HTTP 只是定义了一个与资源交互的统一接口。统一接口类似于一个窗口，只有通过向另一侧的某个独立参与者传递消息才能观察和处理资源。HTTP 没有定义资源是如何存储的，也没有定义这种存储如何响应资源状态变化，也没有定义服务端如何将资源转换为表示。</p><p>就 HTTP 而言，资源的表示（以下统称为<strong>表示</strong>）是旨在反映给定资源过去、当前或期望状态的信息（举例，若将订单视为一种资源，那么查询订单就是希望获取订单资源过去或者当前的信息，创建订单就是在传输订单的期望信息）。表示由元数据和数据流组成，可以轻松地通过 HTTP 进行传输。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>HTTP 的一个设计目标是将资源标识与请求方法分离，这是通过在请求方法和一些请求头字段中赋予语义来实现的：请求方法被设想为将语义应用于目标资源，这很类似于在已识别的对象上调用其定义好的方法，从而将方法语义应用到该对象上的方式。 如果请求方法语义与 URI 本身隐含的任何语义之间存在冲突，则请求方法语义优先。</p><p>与对象方法不同，HTTP 中的标准化请求方法不是特定于某类资源的。尽管每个资源自己确定这些语义是否被允许以及如何实现，但是应该确保标准化方法在应用于任何资源时具有相同的语义。统一的标准化方法在基于网络的系统中提供了更好的可见性和重用性。</p><p>下面根据请求方法的语义对方法进行分类：</p><ul><li><p>安全方法</p><p>如果请求方法所定义的语义本质上是只读的，则该请求方法被认为是安全的。客户端不会请求，也不期望将安全方法应用于目标资源，从而导致服务端上该资源的任何状态变更。同样，合理使用安全方法不会对服务端造成任何伤害、财产损失或异常负担。</p><p>安全方法的定义不会阻止服务端上的方法实现包含潜在有害的行为、并非完全只读的行为或调用时会导致副作用的行为。然而，重要的是客户端没有要求额外的行为，也不会为此负责。例如，大多数服务端在响应完成时会记录访问日志，无论使用何种方法，即使日志存储可能已满并导致服务端崩溃，该方法也被认为是安全的。同样，查看广告而发起的安全请求通常会产生向广告帐户收费的副作用，这也是安全的。</p><p>区分安全和不安全方法的目的是为了支持爬虫和缓存。此外，它允许用户代理在处理潜在不可信内容时对不安全方法应用适当的约束。</p></li><li><p>幂等方法</p><p>如果使用该请求方法的多个相同请求与使用单个此类请求对服务器的预期效果相同，则该请求方法被认为是幂等的。</p><p>与安全方法的定义一样，幂等性仅适用于客户端，服务端可以记录每次历史访问，或为每个幂等请求实现其他非幂等副作用。</p><p>客户端可以自动重复发送幂等请求。例如，如果客户端发送 PUT 请求，并且在收到任何响应之前网络底层连接已关闭，则客户端可以建立新连接并重试该幂等请求。</p></li><li><p>可缓存方法</p><p>请求方法若被定义为可缓存的，则表示允许中介存储对它们的响应以备将来重用。 通常，不依赖于当前或权威响应的安全方法被定义为可缓存的方法。</p><p>但即使规范定义为可缓存方法，但类似于 GET 方法，可以通过在请求头中设置 Cache-Control 字段，更改可缓存特性。</p></li></ul><table><thead><tr><th>方法名</th><th>介绍</th><th>是否安全</th><th>是否幂等</th><th>是否可缓存</th><th>是否有请求体</th></tr></thead><tbody><tr><td>GET</td><td>获取目标资源的当前选定表示</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>HEAD</td><td>与 GET 请求相同，但是只传输状态码和响应头</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>POST</td><td>请求目标资源根据资源自身的特定语义处理请求中包含的表示</td><td>否</td><td>否</td><td>否（规范上定义为可缓存，但大多数实现为不可缓存）</td><td>是</td></tr><tr><td>PUT</td><td>使用请求体中包含的表示替换目标资源当前所有表示，即请求目标资源的状态被<strong>创建</strong>或<strong>替换</strong>为由包含在请求消息有效负载中的表示所定义的状态</td><td>否</td><td>是</td><td>否</td><td>是</td></tr><tr><td>PATCH</td><td>请求创建新资源或对现有资源应用部分修改</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>DELETE</td><td>请求删除目标资源当前所有表示</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>CONNECT</td><td>建立到（被目标资源标识的）服务端的隧道</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>OPTIONS</td><td>请求有关可用于目标资源的通信选项，无论这些信息是存储在服务端还是中介</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>TRACE</td><td>沿着到目标资源的网络路径执行 HTTP 消息的环回测试</td><td>否</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><p>下面详细介绍各请求方法：</p><ul><li><p>GET</p><p>GET 方法是信息检索的主要机制，也是几乎所有性能优化的重点。客户端通过在请求头中设置 Range 字段，可以将 GET 方法的语义更改为“范围请求”，即请求仅传输所选表示的某些部分。注意，这不是类似于对订单信息的分页查询，而是请求对响应的部分获取。</p></li><li><p>HEAD</p><p>HEAD 方法可用于在不传输表示数据的情况下获取所选表示的元数据，通常用于测试超文本链接的有效性、可访问性和最近是否修改。HEAD方法的 响应可能对先前缓存的 GET 方法响应产生影响。</p></li><li><p>POST</p><p>POST 方法不可以被理解为仅代表<strong>创建</strong>。简单说，我们将请求分为读、写两类，那么自然 GET 方法代表读请求，POST 方法代表写请求。写请求自然包含很多语义，类似于创建、修改、删除、取消、预约等等。这是一开始 POST 方法的设计，也是过去（现在甚至还存在）很多系统对于 GET 和 POST 方法的使用方式。可以说，有了 GET 和 POST 方法就可以了。但是，为了更好的利用网络资源，对 HTTP 消息进行优化，比如缓存，以及规范客户端与服务端的交互，就逐渐需要更细化的方法定义，这也是 PUT、DELETE等方法的由来。</p></li><li><p>PUT</p><p>POST 和 PUT 方法之间的根本区别是： POST 方法旨在根据目标资源自己所定义的语义处理请求中的资源表示，而 PUT 方法被定义为替换目标资源的状态。</p><p>除了客户端请求的意图和服务端响应的语义可以表达的内容之外，HTTP 没有确切定义 PUT 方法如何影响服务端资源的状态。资源接口 URI 背后的所有实现细节都被服务端隐藏。</p><p>服务端应该保证 PUT 方法不会修改所定义的资源约束，并验证请求中的表示符合任何约束。当 PUT 方法请求中的表示与目标资源不一致时，服务端应该通过转换表示或更改资源配置来使它们一致，或者以包含足够信息的错误响应来解释表示为什么不合适。</p></li><li><p>PATCH</p><p>PATCH 方法将请求体中描述的一组更改应用于 URI 所标识的资源。更改的格式为补丁文档。如果 URI 未指向现有资源，则服务器可以创建新资源，具体取决于补丁文档类型是否可以在逻辑上修改空资源，以及权限等限制。</p><p>PUT 和 PATCH 方法之间的区别体现在服务端处理表示从而修改 URI 所标识的资源的方式上。PUT 方法请求所包含的表示被认为是存储在源服务器服务端上的资源的修改版本，客户端请求使用这个资源的修改版本替换现有的存储版本。但是 PATCH 方法请求所包含的表示是一组指令，它描述了当前服务端上的资源应如何修改以生成新版本。 服务端必须以原子方式应用整个更改指令，并且不会提供部分修改的表示。如果无法成功应用整个补丁文档，则服务端不得应用任何更改。原子性要求适用于所有直接受影响的文件和数据。如果补丁文档的大小大于 PUT 方法请求中的新资源的大小，那么更应该使用 PUT 方法。</p><p>POST 方法的使用方式多种多样，如果服务器愿意，可以将 POST 方法实现为类似 PUT 和 PATCH 的操作。如果操作没有以可预测的方式修改由 URI 标识的资源，则更应考虑 POST 方法。</p></li><li><p>DELETE</p><p>如果目标资源具有一个或多个表示，它们可能会或不会被服务端销毁，并且其存储可能会或不会被回收，这完全取决于资源的性质及其服务端的实现。</p></li><li><p>CONNECT</p><p>隧道通是通过一个或多个代理所创建的端到端的虚拟连接，可以使用 TLS 进行保护。除了成功响应之外的任何响应都表明隧道尚未连接成功，并且连接仍然由 HTTP 控制。如果隧道连接成功，则此后客户端与服务端的<strong>发送或者接受 TCP 消息流</strong>，直到隧道关闭。</p><p>建立通向任意服务端的隧道存在重大风险，特别是当目标服务端不是众所周知或保留的 TCP 端口时。</p></li><li><p>OPTIONS</p><p>客户端应该在向用户呈现通信选项时区分安全和不安全的方法。</p></li><li><p>TRACE</p></li></ul><h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><p>客户端必须理解任何状态代码类别（例如 3xx），并将无法识别的状态代码视为等同于该类别的 x00 状态码。</p><ul><li>1xx（信息）：请求已收到，继续处理。</li><li>2xx（成功）：请求被成功接收、理解和接受。</li><li>3xx（重定向）：需要采取进一步行动才能完成请求。</li><li>4xx（客户端错误）：请求包含错误的语法或无法完成。</li><li>5xx（服务器错误）：服务器未能满足有效的请求。</li></ul><h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><h2 id="World-Wide-Web-万维网特点及其需求"><a href="#World-Wide-Web-万维网特点及其需求" class="headerlink" title="World Wide Web 万维网特点及其需求"></a>World Wide Web 万维网特点及其需求</h2><p>在理解 REST 设计思想之前，我们需要先明确 Web 的特点，即 Web 系统架构的设计要求。</p><p>Web 的主要目标是成为一个人与机器互联互通的信息共享空间：人们需要一种方法来构建和存储他们自己的信息，无论这些信息是永久的还是短暂的，以便自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护信息的本地副本。Web 系统的最终预期是用户位于世界各地，并通过 Web 连接的。用户所使用的机器是终端、工作站、服务器和超级计算机的异构集合，有各式各样的操作系统软件和文件格式。信息范围从个人研究笔记到组织电话列表。Web 系统需要为这些异构信息提供普遍一致的接口，在尽可能多的平台上使用，并且随着新人员和组织加入而逐步部署整个 Web 系统。</p><p>尽管对它的成功感到欣喜若狂，但 Internet 开发人员社区开始担心 Web 使用的快速增长以及早期 HTTP 的一些不良网络特性会迅速超过 Internet 基础设施的容量并导致全面崩溃。Web 上应用程序交互性质的变化使情况变得更糟。最初的协议是为单个请求-响应对设计的，而新站点使用越来越多的内嵌图像作为网页内容的一部分，从而产生不同的浏览交互配置文件。部署的架构在支持可扩展性、共享缓存和中介方面存在重大限制，这使得针对日益增长的问题开发临时解决方案变得困难。同时，</p><p>Internet Engineering Taskforce 内的工作组成立以研究 Web 的三个主要标准：URI、HTTP 和 HTML。这些小组的章程是定义在早期 Web 架构中普遍和一致实现的现有架构通信的子集，识别该架构中的问题，然后指定一组标准来解决这些问题。这给我们带来了一个挑战：我们如何向已经广泛部署的架构引入一组新功能，以及我们如何确保它的引入不会对支持 Web 的架构属性产生不利影响甚至破坏成功？</p><p>Web 系统有以下特点：</p><ul><li><p>低门槛</p><p>由于参与信息的创建和构建是自愿的，因此需要低门槛才能充分采用。这适用于 Web 架构的所有用户：读者、作者和应用程序开发人员。</p><p>选择超媒体作为用户界面是因为它的简单性和通用性：无论信息来源如何，都可以使用相同的界面，超媒体关系（链接）的灵活性允许无限的结构化，链接的直接操作允许内部的复杂关系指导读者完成应用程序的信息。由于大型数据库中的信息通常更容易通过搜索界面而不是浏览来访问，因此 Web 还集成了通过向服务提供用户输入的数据并将结果呈现为超媒体来执行简单查询的能力。</p><p>对于作者而言，主要要求是整个系统的部分可用性不得妨碍内容的创作。超文本创作语言需要简单并且能够使用现有的编辑工具进行创建。作者希望以这种格式保存个人研究笔记等内容，无论是否直接连接到互联网，因此不能允许某些参考信息暂时或永久不可用的事实阻止阅读和创作可用的信息。出于类似的原因，必须能够在该引用的目标可用之前创建对信息的引用。由于鼓励作者合作开发信息源，参考文献需要易于交流，</p><p>简单性也是应用程序开发人员的目标。由于所有协议都定义为文本，因此可以使用现有网络工具查看和交互测试通信。尽管缺乏标准，这使得协议的早期采用得以实现。</p></li><li><p>可拓展性</p><p>虽然简单性使得部署分布式系统的初始实现成为可能，但可扩展性使我们能够避免永远陷入部署的限制。即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。一个想要像 Web 一样长期存在的系统必须准备好接受变化。</p></li><li><p>分布式超媒体</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此架构需要最小化网络交互（数据传输协议内的往返）。</p></li><li><p>互联网规模</p><p>万维网旨在成为一个<em>互联网规模的</em>分布式超媒体系统，这意味着不仅仅是地理上的分散。互联网是关于跨越多个组织边界的互连信息网络。信息服务供应商必须能够应对无政府可扩展性和软件组件独立部署的需求。</p><h4 id="4-1-4-1-无政府可扩展性"><a href="#4-1-4-1-无政府可扩展性" class="headerlink" title="4.1.4.1 无政府可扩展性"></a>4.1.4.1 无政府可扩展性</h4><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>架构元素及其运行平台的安全性也成为一个重要的问题。多个组织边界意味着在任何通信中都可能存在多个信任边界。中间应用程序（例如防火墙）应该能够检查应用程序交互并防止组织安全策略之外的应用程序被执行。应用程序交互中的参与者应该假设收到的任何信息都是不可信的，或者在给予信任之前需要一些额外的身份验证。这要求架构能够传达身份验证数据和授权控制。但是，由于身份验证会降低可扩展性，因此架构的</p><h4 id="4-1-4-2-独立部署"><a href="#4-1-4-2-独立部署" class="headerlink" title="4.1.4.2 独立部署"></a>4.1.4.2 独立部署</h4><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>具象状态传输（REST）</strong>是一种软件架构风格，旨在指导万维网架构的设计和开发，特别是客户端-服务端应用程序。但更重要的是，REST 为互联网规模的分布式超媒体系统的架构定义了一组约束条件，因此客户端和服务端之间的耦合必须尽可能松散以促进大规模使用。这是通过定义<strong>资源</strong>作为抽象层，从而隐藏了底层实现细节。这种方法允许在跨组织（信任）边界的大规模分布式环境中的客户端和服务端之间实现最大的互操作性。</p><p>REST 的目标是提高性能、可扩展性、简单性、可修改性、可见性、可移植性和可靠性。这是通过遵循 REST 原则来实现的，例如客户端 - 服务器架构、无状态、可缓存性、分层系统的使用、按需代码支持以及使用统一接口。要对系统进行分类，必须遵循这些原则。REST架构风格强调组件间交互的可扩展性、统一接口、组件独立部署、分层架构、方便缓存组件、减少用户感知延迟、加强安全性和封装遗留系统。</p><p>就其本质而言，架构风格独立于任何特定的实现，虽然 REST 是作为 Web 标准开发的一部分创建的，但 Web 的实现并不遵守 REST 架构风格中的每一个约束。不匹配可能由于无知或疏忽而发生，但 REST 架构风格的存在意味着它们可以在标准化之前被识别出来。例如，Fielding 将会话信息嵌入 URI 确定为违反 REST 的约束，这会对共享缓存和服务器可扩展性产生负面影响。<a href="https://en.wikipedia.org/wiki/HTTP_cookies">HTTP cookie</a>也违反了 REST 约束，因为它们可能与浏览器的应用程序状态不同步，从而使它们不可靠；它们还包含可能涉及隐私和安全的不透明数据。</p><p>REST 已被整个软件行业采用，并且是一套被广泛接受的用于创建无状态、可靠的<a href="https://en.wikipedia.org/wiki/Web_API">Web API 的指南</a>。遵守<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints">REST 约束的</a>Web API被非正式地描述为<strong>RESTful</strong>。RESTful Web API 通常松散地基于<a href="https://en.wikipedia.org/wiki/HTTP_method">HTTP 方法</a>，通过<a href="https://en.wikipedia.org/wiki/URL-encoding">URL 编码的</a>参数访问<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_concepts">资源</a>，并使用<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或<a href="https://en.wikipedia.org/wiki/XML">XML</a>传输数据。</p><p>为了创建 REST 架构风格，Fielding 确定了在创建基于全球网络的应用程序时适用的要求，例如需要低进入壁垒以实现全球采用。他还调查了基于网络的应用程序的许多现有架构风格，确定了哪些功能与其他风格共享，例如缓存和客户端-服务器功能，以及 REST 独有的功能，例如资源概念。Fielding 试图对当前实现的现有架构进行分类，并确定哪些方面应该被视为 Web 的行为和性能要求的核心。</p><p>其核心原则是定义可以用少量方法控制的命名资源。这些资源和方法被称为 API 的“名词”和“动词”。使用 HTTP 协议时，资源名称自然映射到网址，方法自然映射到 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>。这使得要学习的内容减少了很多，因为开发人员可以专注于资源及其关系，并假定它们拥有的标准方法同样很少。</p><p>一个万维网应该如何工作的模型。</p><p>REST 最初被称为“HTTP 对象模型”，但该名称通常会导致将其误解为 HTTP 服务器的实现模型。“具象状态转移”这个名称旨在唤起一个精心设计的 Web 应用程序行为的图像：网页网络（虚拟状态机），用户通过选择链接（状态转换）在应用程序中前进。REST 提供了一组架构约束，当作为一个整体应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署和中间组件，以减少交互延迟、加强安全性和封装遗留系统。</p><p>Representational State Transfer (REST) 风格是分布式超媒体系统中架构元素的抽象。REST 忽略了组件实现和协议语法的细节，以便专注于组件的角色、它们与其他组件交互的约束以及它们对重要数据元素的解释。它包含对组件、连接器和数据的基本约束，这些约束定义了 Web 体系结构的基础，从而定义了其作为基于网络的应用程序的行为的本质。</p><p>REST 定义了一个预期应用程序行为模型，该模型支持简单而健壮的应用程序，这些应用程序在很大程度上不受困扰大多数基于网络的应用程序的部分故障条件的影响。</p><p>通过将延迟减少作为架构目标，REST 可以根据用户感知的性能区分媒体类型（表示的数据格式）。</p><p>REST 是一组协调的架构约束，它试图最大限度地减少延迟和网络通信，同时最大限度地提高组件实现的独立性和可扩展性。这是通过对连接器语义施加约束来实现的，而其他样式则专注于组件语义。REST 实现了交互的缓存和重用、组件的动态可替代性以及中介对动作的处理，从而满足了互联网规模的分布式超媒体系统的需求。</p><p>REST 仅详细阐述了被认为对互联网规模的分布式超媒体交互必不可少的架构部分。对于基于网络的应用程序，系统性能取决于网络通信。对于分布式超媒体系统，组件交互由大粒度数据传输而不是计算密集型任务组成。REST 风格是为响应这些需求而开发的。它对资源和表示的通用连接器接口的关注启用了组件的中间处理、缓存和可替换性，这反过来又允许基于 Web 的应用程序从 1994 年的 100,000 个请求/天扩展到 1999 年的 600,000,000 个请求/天。</p><p>REST 或 REpresentational State Transfer 是一种架构风格，用于在网络上的计算机系统之间提供标准，使系统更容易相互通信。符合 REST 的系统，通常称为 RESTful 系统，其特点是它们是无状态的，并且将客户端和服务器的关注点分开。</p><p>2000 年，Roy Fielding 提出了表征状态转移 (REST) 作为设计 Web 服务的架构方法。REST 是一种基于超媒体构建分布式系统的架构风格。REST 独立于任何底层协议，不一定与 HTTP 绑定。但是，最常见的 REST API 实现使用 HTTP 作为应用程序协议。REST 相对于 HTTP 的主要优势在于它使用开放标准，并且不会将 API 或客户端应用程序的实现绑定到任何特定实现。</p><ul><li>REST API 是围绕<em>资源</em>设计的，<em>资源</em>是客户端可以访问的任何类型的对象、数据或服务。</li><li>资源有一个<em>identifier</em>，它是唯一标识该资源的 URI。</li><li>客户端通过交换资源<em>表示</em>与服务交互。</li><li>REST API 使用统一的接口，这有助于将客户端和服务实现解耦。对于基于 HTTP 构建的 REST API，统一接口包括使用标准 HTTP 动词对资源执行操作。最常见的操作是 GET、POST、PUT、PATCH 和 DELETE。</li><li>REST API 使用无状态请求模型。HTTP 请求应该是独立的并且可以以任何顺序发生，因此在请求之间保持瞬态信息是不可行的。唯一存储信息的地方是资源本身，每个请求都应该是一个原子操作。此约束使 Web 服务具有高度可扩展性，因为无需在客户端和特定服务器之间保留任何关联。任何服务器都可以处理来自任何客户端的任何请求。也就是说，其他因素可能会限制可扩展性。</li><li>REST API 由表示中包含的超媒体链接驱动。</li></ul><h2 id="架构约束"><a href="#架构约束" class="headerlink" title="架构约束"></a>架构约束</h2><p>六个指导性约束定义了一个 RESTful 系统。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-SOA_with_REST-6">6] </a>[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Richardson_2007-8">8]</a>这些约束限制了服务器处理和响应客户端请求的方式，因此，通过在这些约束内运行，系统可以获得理想的<a href="https://en.wikipedia.org/wiki/Non-functional_requirement">非功能特性</a>，例如性能、可伸缩性、简单性、可修改性、可见性、便携性和可靠性。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a>如果系统违反了任何必需的约束，则不能将其视为 RESTful。</p><p>正式的 REST 约束如下：</p><h3 id="客户端-服务端架构"><a href="#客户端-服务端架构" class="headerlink" title="客户端-服务端架构"></a>客户端-服务端架构</h3><p>关注点分离是客户端-服务器约束背后的原则。通过将用户界面问题与数据存储问题分开，我们提高了用户界面跨多个平台的可移植性，并通过简化服务器组件提高了可扩展性。然而，也许对 Web 最重要的是分离允许组件独立发展，从而支持多个组织域的 Internet 规模需求。</p><p>在 REST 架构风格中，客户端的实现和服务器的实现可以独立完成，彼此互不了解。只要每一方都知道要向另一方发送什么格式的消息，它们就可以保持模块化和分离。将用户界面问题与数据存储问题分开，我们提高了跨平台界面的灵活性，并通过简化服务器组件来提高可扩展性。此外，分离允许每个组件独立发展的能力。通过使用 REST 接口，不同的客户端访问相同的 REST 端点，执行相同的操作，并接收相同的响应。</p><p>一个或多个客户端必须能够同时监视和操作同一资源。</p><p>大多数现代 Web 应用程序都公开了客户端可用于与应用程序交互的 API。一个设计良好的 Web API 应该旨在支持：</p><ul><li><strong>平台独立性</strong>。无论 API 在内部如何实现，任何客户端都应该能够调用 API。这需要使用标准协议，并具有一种机制，使客户端和 Web 服务可以就要交换的数据格式达成一致。</li><li><strong>服务进化</strong>。Web API 应该能够独立于客户端应用程序发展和添加功能。随着 API 的发展，现有的客户端应用程序应该无需修改即可继续运行。所有功能都应该是可发现的，以便客户端应用程序可以充分使用它。</li></ul><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>在计算中，无状态协议是一种<a href="https://en.wikipedia.org/wiki/Communications_protocol">通信协议</a>，其中接收方（通常是服务器）不保留会话信息。客户端将相关会话数据发送到接收器，这样传输的每个信息包都可以被孤立地理解，而无需会话中先前数据包的上下文信息。无状态协议的这一特性使它们成为高容量应用程序的理想选择，通过消除由保留会话信息引起的服务器负载来提高性能。</p><p>我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_3">第 3.4.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_3">图 5-3</a>）的客户端-无状态-服务器 (CSS) 风格，这样从客户端到服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。这种约束导致了可见性、可靠性和可伸缩性的特性。可见性得到改善，因为监控系统不必查看单个请求数据之外的内容来确定请求的全部性质。可靠性得到提高，因为它简化了从部分故障中恢复的任务 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。可扩展性得到改进，因为不必在请求之间存储状态允许服务器组件快速释放资源，并进一步简化实现，因为服务器不必管理跨请求的资源使用。与大多数架构选择一样，无状态约束反映了设计权衡。缺点是它可能会通过增加一系列请求中发送的重复数据（每次交互开销）来降低网络性能，因为这些数据不能在共享上下文中留在服务器上。此外，将应用程序状态置于客户端会减少服务器对一致应用程序行为的控制，因为应用程序变得依赖于跨多个客户端版本的正确语义实现。</p><p>遵循 REST 范式的系统是无状态的，这意味着服务器不需要知道客户端处于什么状态，反之亦然。这样，服务器和客户端都可以理解收到的任何消息，即使没有看到以前的消息。这种无状态约束是通过使用<em>资源</em>而不是<em>命令</em>来强制执行的。资源是 Web 的名词——它们描述您可能需要存储或发送到其他服务的任何对象、文档或 <em>事物</em>。由于 REST 系统通过对资源的标准操作进行交互，因此它们不依赖于接口的实现。这些约束帮助 RESTful 应用程序实现可靠性、快速性能和可扩展性，作为可以管理、更新和重用的组件，即使在系统运行期间也不影响整个系统。</p><p>系统状态应该始终是可发现和可测试的。即使操作跟踪资源不再处于活动状态，客户端也应该能够确定系统状态。查询长时间运行的操作状态的行为本身应该利用网络的原则。即具有统一接口语义的明确定义的资源。客户端可以对某些资源发出 GET 请求以确定长时间运行的操作的状态</p><p>长期运行的操作应该适用于希望“即发即忘”的客户以及希望积极监控结果并采取行动的客户。</p><p>取消并不明确意味着回滚。在每个 API 定义的情况下，它可能意味着回滚、补偿、完成或部分完成等。在取消操作之后，客户不应该负责将服务返回到允许继续服务的一致状态。</p><h3 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h3><p>在万维网上，客户端和中介可以缓存响应。响应必须隐式或显式地将自己定义为可缓存或不可缓存，以防止客户端提供陈旧或不适当的数据以响应进一步的请求。管理良好的缓存部分或完全消除了一些客户端-服务器交互，进一步提高了可扩展性和性能。</p><p>为了提高网络效率，我们添加缓存约束，形成<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_4">3.4.4节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_4">图5-4</a>）的client-cache-stateless-server样式。缓存约束要求对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权为以后的等效请求重用该响应数据。添加缓存约束的优势在于它们有可能通过减少一系列交互的平均延迟来部分或完全消除某些交互，从而提高效率、可扩展性和用户感知性能。然而，权衡是，如果缓存中的陈旧数据与将请求直接发送到服务器时获得的数据显着不同，则缓存会降低可靠性。</p><h3 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h3><p>统一接口约束是任何 RESTful 系统设计的基础。它简化和解耦了架构，使每个部分都可以独立演进。这个统一接口的四个约束是：</p><ul><li>请求中的资源标识 - 单个资源在请求中标识，例如在 RESTful Web 服务中使用URI。资源本身在概念上与返回给客户端的表示分开。例如，服务器可以以HTML、XML或JSON格式从其数据库发送数据——这些都不是服务器的内部表示。</li><li>通过表示进行资源操作 - 当客户端持有资源的表示（包括附加的任何<a href="https://en.wikipedia.org/wiki/Metadata">元数据）时</a>，它有足够的信息来修改或删除资源的状态。</li><li>自描述消息 - 每条消息都包含足够的信息来描述如何处理消息。例如，要调用的解析器可以由<a href="https://en.wikipedia.org/wiki/Media_type">媒体类型</a>指定。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a></li><li>超媒体作为应用状态（发动机<a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>） -已经进入一个初始的URI REST应用类似于人类的Web用户访问该<a href="https://en.wikipedia.org/wiki/Home_page">主页</a>网站-REST客户端的话应该能够动态地使用服务器提供的链接发现它需要的所有可用资源。随着访问的进行，服务器以包含指向当前可用的其他资源的<a href="https://en.wikipedia.org/wiki/Hyperlink">超链接的</a>文本进行响应。客户端无需使用有关应用程序结构或动态的信息进行硬编码。</li></ul><p>将 REST 架构风格与其他基于网络的风格区分开来的核心特征是它强调组件之间的统一接口（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_6">图 5-6</a>）。通过将通用性的软件工程原理应用于组件接口，简化了整个系统架构并提高了交互的可见性。实现与它们提供的服务分离，这鼓励了独立的可进化性。然而，代价是统一的接口会降低效率，因为信息是以标准化的形式传输的，而不是特定于应用程序需求的形式。REST 接口被设计为高效的大粒度超媒体数据传输，针对 Web 的常见情况进行优化，但导致接口对于其他形式的架构交互不是最佳的。为了获得统一的接口，需要多个架构约束来指导组件的行为。REST 由四个接口约束定义：资源识别、通过表征操纵资源、自我描述信息、超媒体作为应用程序状态的引擎。</p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>客户端通常无法判断它是直接连接到终端服务器还是沿途的中介。如果在客户端和服务器之间放置代理或负载均衡器，则不会影响它们的通信，也不需要更新客户端或服务器代码。中间服务器可以通过启用负载平衡和提供共享缓存来提高系统可扩展性。此外，安全性可以添加为 Web 服务之上的一个层，将业务逻辑与安全逻辑分开。将安全添加为一个单独的层会强制执行安全策略。最后，中间服务器可以调用多个其他服务器来生成对客户端的响应。</p><p>为了进一步改善 Internet 规模需求的行为，我们添加了分层系统约束（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_7">图 5-7</a>）。如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_2">第 3.4.2 节</a>所述，分层系统风格允许架构通过约束组件行为而由分层层组成，使得每个组件不能“看到”超出与其交互的直接层。通过将系统的知识限制在单个层，我们对整个系统的复杂性进行了限制，并促进了基板的独立性。层可用于封装遗留服务并保护来自遗留客户端的新服务，通过将不常用的功能移动到共享中介来简化组件。中介还可用于通过跨多个网络和处理器实现服务负载平衡来提高系统可扩展性。分层系统的主要缺点是它们增加了数据处理的开销和延迟，降低了用户感知的性能 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_32">32</a> ]。对于支持缓存约束的基于网络的系统，这可以被中介共享缓存的好处所抵消。在组织域的边界放置共享缓存可以带来显着的性能优势 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_136">136</a> ]。这些层还允许对跨越组织边界的数据实施安全策略，这是防火墙的要求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_79">79</a> ]。分层系统和统一接口约束的组合产生类似于统一管道和过滤器风格（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_2_2">第 3.2.2 节</a>）的架构特性。尽管 REST 交互是双向的，但超媒体交互的大粒度数据流都可以像数据流网络一样进行处理，过滤器组件有选择地应用于数据流，以便在内容通过时对其进行转换 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_26">26</a> ]。在 REST 中，中介组件可以主动转换消息的内容，因为消息是自描述的，并且它们的语义对中介是可见的。</p><h3 id="按需代码（可选）"><a href="#按需代码（可选）" class="headerlink" title="按需代码（可选）"></a>按需代码（可选）</h3><p>服务器可以通过传输可执行代码来临时扩展或自定义客户端的功能：例如，已编译的组件（如Java 小程序）或客户端脚本（如JavaScript）。</p><p>我们为 REST 设置的最后一项约束来自<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_5_3">第 3.5.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_8">图 5-8</a>）的按需代码风格。REST 允许通过下载和执行小程序或脚本形式的代码来扩展客户端功能。这通过减少需要预先实现的功能数量来简化客户端。允许在部署后下载功能提高了系统可扩展性。但是，它也会降低可见性，因此它只是 REST 中的一个可选约束。可选约束的概念似乎是矛盾的。但是，它在包含多个组织边界的系统的架构设计中确实有其用途。这意味着体系结构只有在已知可选约束对整个系统的某些领域有效时才能获得它们的好处（并遭受缺点）。可选约束允许我们设计一个架构，在一般情况下支持所需的行为，但要理解它可能在某些上下文中被禁用。</p><h2 id="架构元素"><a href="#架构元素" class="headerlink" title="架构元素"></a>架构元素</h2><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p><img src="/images/SAC/REST/data_element.png"></p><p>数据元素的性质和状态是 REST 架构的一个重要方面。</p><p>许多分布式处理范式将处理逻辑（例如代码、存储过程、搜索表达式等，MapReduce 即是此思想的代表）移动到数据端，而不是将数据移动到处理组件中，这些分布式对象的所有数据都封装在处理组件中并由处理组件隐藏。在 REST 架构中，用户选择链接后，数据需要从其存储位置移动到用户的位置。有如下三种基本的数据移动方式：</p><ol><li><strong>在数据所在的位置渲染数据并将固定格式的渲染结果发送给接收者。</strong>传统的客户端 - 服务器风格，允许所有关于数据真实性质的信息隐藏在发送者中，防止对数据结构做出假设并使客户端实现更容易。但是，它也严重限制了接收方的功能，并将大部分处理负载置于发送方，从而导致可扩展性问题。    </li><li><strong>用渲染引擎封装数据并发送给接收者。</strong>移动对象样式 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_50">50</a>]，提供信息隐藏，同时通过其独特的渲染引擎对数据进行专门处理，但将接收方的功能限制在该引擎中的预期范围内，并可能大大增加传输的数据量。</li><li><strong>将原始数据连同描述数据类型的元数据一起发送给接收者，以便接收者可以选择自己的渲染引擎。</strong>允许发送方在最小化传输的字节数的同时保持简单和可扩展，但失去了信息隐藏的优势，并且要求发送方和接收方都理解相同的数据类型。</li></ol><p>REST 通过关注对数据类型与元数据的共同理解，提供了所有三个选项的混合，但限制了向标准化接口显示的内容的范围。REST 组件通过以与一组不断发展的标准数据类型之一匹配的格式传输资源的表示来进行通信，根据接收者的能力或愿望以及资源的性质动态选择。无论表示形式与原始源的格式相同，还是源自源，都隐藏在界面后面。通过发送由封装渲染引擎的标准数据格式中的指令组成的表示，可以近似移动对象样式的好处。因此，REST 获得了客户端-服务器风格的关注点分离，而没有服务器可扩展性问题，允许通过通用接口隐藏信息以实现服务的封装和演变，并通过可下载的功能引擎提供多样化的功能集。</p><p>REST 中信息的关键抽象是<em>资源</em>。任何可以命名的信息都可以是资源：文档或图像、时间服务（例如“洛杉矶今天的天气”）、其他资源的集合、非虚拟对象（例如人）等. 换句话说，任何可能成为作者超文本引用目标的概念都必须符合资源的定义。资源是到一组实体的概念映射，而不是在任何特定时间点对应于映射的实体。更准确地说，资源<em>R</em>是随时间变化的隶属函数<em>M</em> R <em>(t)<em>，它在时间</em>t</em>映射到一组等效的实体或值。集合中的值可以是<em>资源表示</em>和/或<em>资源标识符</em>。资源可以映射到空集，这允许在该概念的任何实现存在之前对其进行引用——这个概念对于 Web 之前的大多数超文本系统来说是陌生的 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_61">61]</a>]。某些资源在某种意义上是静态的，即在它们创建后的任何时间进行检查时，它们始终对应于相同的值集。其他人的价值随着时间的推移有很大程度的变化。资源唯一需要静态的是映射的语义，因为语义是区分一种资源与另一种资源的原因。资源的这种抽象定义启用了 Web 架构的关键特性。首先，它通过包含许多信息源而没有人为地按类型或实现来区分它们来提供通用性。其次，它允许对表示的引用进行后期绑定，从而能够根据请求的特征进行内容协商。最后，它允许作者引用该概念而不是该概念的某些单一表示，从而无需在表示更改时更改所有现有链接（假设作者使用了正确的标识符）。REST 使用资源标识符来标识组件之间交互中涉及的特定资源。REST 连接器提供了一个通用接口，用于访问和操作资源的值集，而不管成员函数是如何定义的或处理请求的软件类型如何。分配资源标识符的命名机构，使引用资源成为可能，负责随着时间的推移维护映射的语义有效性（即，确保成员函数不会改变）。</p><p>REST 组件通过使用表示来捕获该资源的当前或预期状态并在组件之间传输该表示来对资源执行操作。表示是一个字节序列，加上描述这些字节的表示元数据。表示的其他常用但不太精确的名称包括：文档、文件和 HTTP 消息实体、实例或变体。表示包括数据、描述数据的元数据，有时还包括描述元数据的元数据（通常用于验证消息完整性）。元数据采用名称-值对的形式，其中名称对应于定义值结构和语义的标准。响应消息可能包括表示元数据和资源元数据：关于资源的信息，不是特定于所提供的表示。控制数据定义了组件之间消息的目的，例如请求的操作或响应的含义。它还用于参数化请求并覆盖某些连接元素的默认行为。例如，缓存行为可以通过包含在请求或响应消息中的控制数据进行修改。根据消息控制数据，给定的表示可以指示所请求资源的当前状态、所请求资源的期望状态或某些其他资源的值，例如客户端查询表单中输入数据的表示，或响应的某些错误条件的表示。例如，资源的远程创作要求创作者向服务器发送一个表示，从而为该资源建立一个值，该值可以由以后的请求检索。如果给定时间资源的值集由多个表示组成，则可以使用内容协商来选择最佳表示以包含在给定消息中。</p><p>但定义比这更普遍：任何可以命名的信息都可以是资源：图像、数据库查询、时间服务（例如“伦敦今天的天气”），甚至是其他资源的集合</p><p>面向资源的 API 通常被构建为资源层次结构，其中每个节点是一个“简单资源”或“集合资源”。为方便起见，它们通常被分别称为资源和集合。</p><ul><li>一个集合包含<strong>相同类型</strong>的资源列表。 例如，一个用户拥有一组联系人。</li><li>资源具有一些状态和零个或多个子资源。 每个子资源可以是一个简单资源或一个集合资源。</li></ul><p>例如，Gmail API 有一组用户，每个用户都有一组消息、一组线程、一组标签、一个个人资料资源和若干设置资源。</p><p>虽然存储系统和 REST API 之间存在一些概念上的对应，但具有面向资源 API 的服务不一定是数据库，并且在解释资源和方法方面具有极大的灵活性。例如，创建日历事件（资源）可以为参与者创建附加事件、向参与者发送电子邮件邀请、预约会议室以及更新视频会议时间安排。</p><p>虽然完整的资源名称类似于普通网址，但两者并不相同。单个资源可以由不同的 API 版本、API 协议或 API 网络端点公开。完整资源名称未指明此类信息，因此在实际使用中必须将其映射到特定的 API 版本和 API 协议。</p><p>“Web 资源”首先在万维网上定义为由其URL标识的文档或文件。今天，该定义更加通用和抽象，包括可以在 Web 上以任何方式识别、命名、寻址、处理或执行的所有事物、实体或操作。在 RESTful Web 服务中，对资源的<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>发出的请求会引发响应，其<a href="https://en.wikipedia.org/wiki/Payload_(computing)">有效负载</a>格式为<a href="https://en.wikipedia.org/wiki/HTML">HTML</a>、<a href="https://en.wikipedia.org/wiki/XML">XML</a>、<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或某种其他格式。例如，响应可以确认资源状态已更改。响应还可以包含<a href="https://en.wikipedia.org/wiki/Hypertext">超文本</a>相关资源的链接。这些请求和响应最常见的协议是 HTTP。它提供操作（<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP 方法</a>），例如 GET、POST、PUT 和 DELETE。通过使用无状态协议和标准操作，RESTful 系统旨在通过重用可以管理和更新的组件来实现快速性能、可靠性和增长能力，即使在系统运行时也不影响整个系统。</p><p>客户端只能使用<strong>URI</strong>访问资源。换句话说，客户端使用 URI 请求资源，服务器使用资源的<strong>表示</strong>进行响应。资源的表示是 REST 中的另一个重要概念。为了确保响应可以被尽可能多的客户端<strong>应用程序</strong>解释，资源的表示以超文本格式发送。因此，通过在客户端和服务器之间的<strong>消息中</strong>传输的超文本表示来操纵资源。客户端和服务器的强解耦以及使用统一寻址协议的基于文本的信息传输为满足 Web 的要求提供了基础：健壮性（无政府可扩展性）、组件的独立部署、大粒度数据传输和内容读者、内容作者和开发人员的低准入门槛。</p><p>REST 架构风格的约束影响以下架构属性：</p><ul><li>组件交互中的性能，这可能是用户感知性能和网络效率的主导因素；[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch2-7">7]</a></li><li><a href="https://en.wikipedia.org/wiki/Scalability">可扩展性</a>允许支持大量组件和组件之间的交互；</li><li>统一界面的简单性；</li><li>组件的可修改性以满足不断变化的需求（即使在应用程序运行时）；</li><li>服务代理组件之间通信的可见性；</li><li>通过随数据移动程序代码来实现组件的可移植性；</li><li>在组件、连接器或数据中存在故障时，系统级抗故障的可靠性。</li></ul><p>REST 用于定义 URI 标准的术语资源 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_21">21</a>]，以及通过其表示来操作资源的通用接口的整体语义。早期的 Web 架构将 URI 定义为文档标识符。作者被指示根据文档在网络上的位置来定义标识符。然后可以使用 Web 协议来检索该文档。然而，由于多种原因，这个定义被证明是不令人满意的。首先，它表明作者正在识别传输的内容，这意味着只要内容发生变化，标识符就应该改变。其次，存在许多对应于服务而不是文档的地址——作者可能打算将读者引导至该服务，而不是先前访问该服务的任何特定结果。最后，在某些时间段存在与文档不对应的地址，REST 中资源的定义基于一个简单的前提：标识符应尽可能不经常更改。因为 Web 使用嵌入式标识符而不是链接服务器，作者需要一个与他们想要的超媒体引用语义密切匹配的标识符，允许引用保持静态，即使访问该引用的结果可能会随着时间的推移而改变。REST 通过将资源定义为作者想要识别的语义，而不是在创建引用时对应于这些语义的值来实现这一点。然后由作者确保为引用选择的标识符确实标识了预期的语义。</p><p>定义资源以便 URI 标识概念而不是文档给我们留下了另一个问题：用户如何访问、操作或传输概念，以便在选择超文本链接时他们可以获得有用的东西？REST 通过将被操作的事物定义为已识别资源的表示而不是资源本身来回答这个问题。源服务器维护从资源标识符到对应于每个资源的一组表示的映射。因此，通过资源标识符定义的通用接口传输表示来操纵资源。REST 对资源的定义源自 Web 的核心需求：跨多个信任域独立创作互连的超文本。强制接口定义与接口要求相匹配会导致协议看起来模糊，但这只是因为被操作的接口只是一个接口而不是一个实现。协议特定于应用程序操作的意图，但接口背后的机制必须决定该意图如何影响资源映射到表示的底层实现。信息隐藏是推动 REST 统一接口的关键软件工程原则之一。由于客户端仅限于对表示的操作而不是直接访问资源的实现，因此可以以命名机构所需的任何形式构造实现，而不会影响可能使用其表示的客户端。此外，如果在访问资源时存在多个资源表示，则可以使用内容选择算法来动态选择最适合该客户端能力的表示。当然，缺点是资源的远程创作不像文件的远程创作那么简单。</p><p>通过 Web 的统一接口进行远程创作的挑战是由于客户端可以检索的表示与服务器上可能用于存储、生成或检索该表示的内容的机制之间的分离。单个服务器可以将其命名空间的某些部分映射到文件系统，文件系统又映射到可以映射到磁盘位置的 inode 的等价物，但是这些底层机制提供了一种将资源与一组表示相关联的方法，而不是而不是识别资源本身。许多不同的资源可以映射到相同的表示，而其他资源可能根本没有映射。资源不是存储对象。资源不是服务器用来处理存储对象的机制。资源是一个概念映射——服务器接收标识符（标识映射）并将其应用于其当前的映射实现（通常是特定于集合的深度树遍历和/或哈希表的组合）以查找当前负责的处理程序实现和处理程序实现然后根据请求内容选择适当的操作+响应。所有这些特定于实现的问题都隐藏在 Web 界面后面；只能通过 Web 界面访问的客户端无法假定它们的性质。</p><p>如上所述，一个资源可以有许多标识符。换句话说，当用于访问服务器时，可能存在两个或多个具有等效语义的不同 URI。也可能有两个 URI 导致在访问服务器时使用相同的机制，但这些 URI 标识两个不同的资源，因为它们的含义不同。语义是分配资源标识符和用表示填充这些资源的行为的副产品。服务器或客户端软件在任何时候都不需要知道或理解 URI 的含义——它们只是作为一个渠道，资源的创建者（人类命名机构）通过它可以将表示与由 URI 标识的语义相关联。 URI。换句话说，服务器上没有资源；只是通过资源定义的抽象接口提供答案的机制。这可能看起来很奇怪，但这就是使 Web 能够跨许多不同实现工作的本质。</p><p>尽管 URI 设计符合 REST 的标识符架构概念，但仅靠语法不足以强制命名机构根据资源模型定义自己的 URI。一种滥用形式是在超媒体响应表示引用的所有 URI 中包含标识当前用户的信息。当软件试图将 Web 视为分布式文件系统时，会发生与 REST 资源接口的另一个冲突。由于文件系统公开其信息的实现，因此存在将这些信息“镜像”到多个站点的工具，作为负载平衡和重新分配更接近用户的内容的一种手段。但是，它们之所以能够这样做，只是因为文件具有一组固定的语义（命名的字节序列），可以轻松复制。相比之下，尝试将 Web 服务器的内容镜像为文件将失败，因为资源接口并不总是与文件系统的语义匹配，并且因为数据和元数据都包含在表示的语义中并且对表示的语义很重要. 可以在远程站点复制 Web 服务器内容，但只能通过复制整个服务器机制和配置，或选择性地仅复制那些具有已知静态表示的资源。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>![image-20210913181829225](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913181829225.png)</p><p>REST 使用各种连接器类型（在<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#tab_5_2">表 5-2</a>中进行了总结）来封装访问资源和传输资源表示的活动。连接器为组件通信提供了一个抽象接口，通过提供清晰的关注点分离和隐藏资源和通信机制的底层实现来增强简单性。接口的通用性还实现了可替换性：如果用户只能通过抽象接口访问系统，则可以在不影响用户的情况下替换实现。由于连接器管理组件的网络通信，因此可以在多个交互之间共享信息，以提高效率和响应能力。所有 REST 交互都是无状态的。也就是说，每个请求都包含连接器理解请求所需的所有信息，独立于可能在它之前的任何请求。这种限制实现了四个功能：1）它消除了连接器在请求之间保留应用程序状态的任何需要，从而减少了物理资源的消耗并提高了可扩展性；2）它允许并行处理交互，而不需要处理机制理解交互语义；3）它允许中介孤立地查看和理解请求，这在服务动态重新排列时可能是必要的；并且，4) 它强制所有可能影响缓存响应可重用性的信息出现在每个请求中。主要的连接器类型是客户端和服务器。第三种连接器类型，缓存连接器，可以位于客户端或服务器连接器的接口上，以便保存对当前交互的可缓存响应，以便它们可以重用于以后请求的交互。REST 试图在缓存行为的透明性需求与高效使用网络的需求之间取得平衡，而不是假设始终需要绝对透明性。缓存能够确定响应的可缓存性，因为接口是通用的而不是特定于每个资源的。默认情况下，对检索请求的响应是可缓存的，而对其他请求的响应是不可缓存的。如果某种形式的用户身份验证是请求的一部分，或者如果响应指示不应共享它，则该响应只能由非共享缓存进行缓存。组件可以通过包含将交互标记为可缓存、不可缓存或仅在有限时间内可缓存的控制数据来覆盖这些默认值。解析器将部分或完整的资源标识符转换为建立组件间连接所需的网络地址信息。连接器类型的最后一种形式是隧道，它只是跨连接边界中继通信，例如防火墙或较低级别的网络网关。它被建模为 REST 的一部分而不是作为网络基础设施的一部分抽象出来的唯一原因是某些 REST 组件可能会从活动组件行为动态切换到隧道行为。主要示例是 HTTP 代理，它响应 CONNECT 方法请求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_71">71</a> ]切换到隧道，从而允许其客户端使用不允许代理的不同协议（例如 TLS）直接与远程服务器通信。当两端终止通信时，隧道消失。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>![image-20210913182732672](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913182732672.png)</p><p>用户代理使用客户端连接器发起请求并成为响应的最终接收者。最常见的示例是 Web 浏览器，它提供对信息服务的访问并根据应用程序需要呈现服务响应。源服务器使用服务器连接器来管理所请求资源的命名空间。它是其资源表示的最终来源，并且必须是旨在修改其资源值的任何请求的最终接收者。每个源服务器为其服务提供一个通用接口作为资源层次结构。资源实现细节隐藏在接口后面。中间组件既充当客户端又充当服务器，以便在可能的翻译、请求和响应的情况下进行转发。</p><p>![image-20210913183608285](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913183608285.png)</p><p>REST 的客户端-服务器关注点分离简化了组件实现，降低了连接器语义的复杂性，提高了性能调优的有效性，并增加了纯服务器组件的可扩展性。分层系统约束允许在通信中的各个点引入中介——代理、网关和防火墙——而不改变组件之间的接口，从而允许它们通过大规模共享缓存来协助通信转换或提高性能。REST 通过将消息约束为自描述性来实现中间处理：请求之间的交互是无状态的，标准方法和媒体类型用于指示语义和交换信息，响应明确指示可缓存性。由于组件是动态连接的，它们的排列和功能对于特定的应用程序操作具有类似于管道和过滤器样式的特性。尽管 REST 组件通过双向流进行通信，但每个方向的处理都是独立的，因此容易受到流转换器（过滤器）的影响。通用连接器接口允许基于每个请求或响应的属性将组件放置在流上。服务可以使用复杂的中介层次结构和多个分布式源服务器来实现。REST 的无状态特性允许每个交互独立于其他交互，无需了解整体组件拓扑，这是 Internet 规模架构不可能完成的任务，并允许组件充当目的地或中介，动态确定通过每个请求的目标。连接器只需要在其通信范围内知道彼此的存在，尽管出于性能原因，它们可能会缓存其他组件的存在和功能。</p><p>客户端连接器检查资源标识符，以便为每个请求选择适当的通信机制。例如，当标识符指示它是本地资源时，客户端可以被配置为连接到特定代理组件，可能充当注释过滤器的代理组件。同样，客户端可以配置为拒绝对某些标识符子集的请求。REST 不限制特定协议的通信，但它确实限制了组件之间的接口，因此限制了组件之间可能以其他方式进行的交互和实现假设的范围。</p><p>REST 组件交互以分层的客户端-服务器风格构建，但通用资源接口的附加约束为中介提供了可替代性和检查的机会。请求和响应具有远程调用风格的外观，但 REST 消息针对的是概念资源而不是实现标识符。已经进行了多次尝试将 Web 体系结构建模为分布式文件系统（例如 WebNFS）的形式或分布式对象系统 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_83">83</a> ]。然而，他们将各种 Web 资源类型或实现策略排除为“不有趣”，而实际上它们的存在使这些模型的假设无效。REST 运行良好，因为它不会将资源的实现限制为某些预定义的模型，允许每个应用程序选择最符合其自身需求的实现，并能够在不影响用户的情况下替换实现。向消费组件发送资源表示的交互方法与基于事件的集成 (EBI) 风格有一些相似之处。主要区别在于 EBI 样式是基于推送的。包含状态的组件（相当于 REST 中的源服务器）在状态更改时发出事件，无论是否有任何组件实际上对此类事件感兴趣或侦听此类事件。在 REST 风格中，消费组件通常会提取表示。尽管将其视为希望监控单个资源的单个客户端时效率较低，但 Web 的规模使得不受监管的推送模型不可行。</p><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><ul><li><p>围绕资源组织 API 设计</p><p>关注 Web API 公开的业务实体。如果可能，资源 URI 应基于名词（资源）而不是动词（对资源的操作）。资源不必基于单个物理数据项。避免创建简单地反映数据库内部结构的 API。REST 的目的是对实体以及应用程序可以对这些实体执行的操作进行建模。客户端不应暴露于内部实现。实体通常被组合成集合（订单、客户）。集合是与集合中的项目不同的资源，应该有自己的 URI。如有必要，在数据库和 Web API 之间引入一个映射层。这样，客户端应用程序就与底层数据库方案的更改隔离开来。</p><p>在 URI 中采用一致的命名约定。一般来说，对引用集合的 URI 使用复数名词会有所帮助。将集合和项目的 URI 组织成层次结构是一种很好的做法。这种方法有助于保持 Web API 的直观性。</p><p>还要考虑不同类型资源之间的关系以及如何公开这些关联。更好的解决方案是在 HTTP 响应消息的正文中提供指向相关资源的可导航链接。在更复杂的系统中，提供 URI 使客户端能够浏览多个级别的关系可能很诱人，例如<code>/customers/1/orders/99/products</code>. 但是，如果资源之间的关系在未来发生变化，这种复杂程度可能难以维护并且不灵活。相反，尽量保持 URI 相对简单。一旦应用程序拥有对资源的引用，就应该可以使用此引用来查找与该资源相关的项目。可以将前面的查询替换为 URI<code>/customers/1/orders</code>来查找客户 1 的所有订单，然后<code>/orders/99/products</code>查找该订单中的产品。</p><p>另一个因素是所有 Web 请求都会对 Web 服务器施加负载。请求越多，负载越大。因此，尽量避免暴露大量小资源的“健谈”Web API。此类 API 可能需要客户端应用程序发送多个请求以查找其所需的所有数据。相反，您可能希望对数据进行非规范化并将相关信息组合到可以通过单个请求检索的更大资源中。但是，您需要平衡这种方法与获取客户端不需要的数据的开销。检索大对象会增加请求的延迟并产生额外的带宽成本。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-string">orders</span> // <span class="hljs-string">Good</span><br><br><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-built_in">create-order</span> // <span class="hljs-string">Avoid</span><br></code></pre></td></tr></table></figure></li><li><p>根据 HTTP 方法定义 API 操作</p><p>HTTP 协议定义了许多为请求分配语义的方法。大多数 RESTful Web API 使用的常见 HTTP 方法是：</p><ul><li><strong>GET</strong>在指定的 URI 处检索资源的表示。响应消息的正文包含所请求资源的详细信息。</li><li><strong>POST</strong>在指定的 URI 处创建一个新资源。请求消息的正文提供了新资源的详细信息。请注意，POST 还可用于触发实际上不创建资源的操作。</li><li><strong>PUT</strong>创建或替换指定 URI 处的资源。请求消息的正文指定要创建或更新的资源。</li><li><strong>PATCH</strong>执行资源的部分更新。请求正文指定要应用于资源的一组更改。</li><li><strong>DELETE</strong>删除指定 URI 处的资源。</li></ul><p>特定请求的效果应取决于资源是集合还是单个项目。</p><ul><li>POST 请求创建一个资源。服务器为新资源分配一个 URI，并将该 URI 返回给客户端。POST 请求还可用于将数据提交到现有资源进行处理，而无需创建任何新资源。</li><li>PUT 请求创建资源<em>或</em>更新现有资源。客户端指定资源的 URI。请求正文包含资源的完整表示。如果具有此 URI 的资源已存在，则会替换它。否则，如果服务器创建一个新资源。服务器可能支持更新，但不支持通过 PUT 创建。是否支持通过 PUT 创建取决于客户端是否可以在资源存在之前有意义地为其分配 URI。如果没有，则使用 POST 创建资源并使用 PUT 或 PATCH 进行更新。</li><li>PATCH 请求对现有资源执行<em>部分更新</em>。客户端指定资源的 URI。请求正文指定要应用于资源的一组<em>更改</em>。这比使用 PUT 更有效，因为客户端只发送更改，而不是资源的整个表示。从技术上讲，如果服务器支持，PATCH 还可以创建新资源（通过指定对“空”资源的一组更新）。</li></ul><p>PUT 请求必须是幂等的。如果客户端多次提交相同的 PUT 请求，结果应该始终相同（相同的资源将被修改为相同的值）。POST 和 PATCH 请求不保证是幂等的。</p></li><li><p>符合 HTTP 语义</p><p>JSON 合并补丁稍微简单一些。补丁文档与原始 JSON 资源具有相同的结构，但仅包含应更改或添加的字段子集。此外，可以通过<code>null</code>在补丁文档中指定字段值来删除字段。（这意味着如果原始资源可以具有显式空值，则合并补丁不适合。）JSON 合并补丁的媒体类型是<code>application/merge-patch+json</code>.如果原始资源可以包含显式空值，则不适合合并补丁，因为<code>null</code>补丁文档中的特殊含义。此外，补丁文档没有指定服务器应用更新的顺序。这可能重要也可能无关紧要，具体取决于数据和域。<a href="https://tools.ietf.org/html/rfc6902">RFC 6902 中</a>定义的 JSON 补丁更加灵活。它将更改指定为要应用的操作序列。操作包括添加、删除、替换、复制和测试（以验证值）。JSON 补丁的媒体类型是<code>application/json-patch+json</code>.</p><p>如果在向客户端发送响应之前等待完成，可能会导致无法接受的延迟。如果是这样，请考虑使操作异步。返回 HTTP 状态代码 202（已接受）以指示请求已被接受进行处理但尚未完成。您应该公开一个返回异步请求状态的端点，以便客户端可以通过轮询状态端点来监视状态。在 202 响应的 Location 标头中包含状态端点的 URI。如果客户端向此端点发送 GET 请求，则响应应包含请求的当前状态。或者，它还可以包括预计完成时间或取消操作的链接。</p></li><li><p>使用 HATEOAS 启用导航到相关资源</p><p>REST 背后的主要动机之一是应该可以在不需要 URI 方案的先验知识的情况下导航整个资源集。每个 HTTP GET 请求都应返回通过响应中包含的超链接查找与所请求对象直接相关的资源所必需的信息，并且还应提供描述对这些资源中的每一个可用的操作的信息。这一原则被称为 HATEOAS，或作为应用程序状态引擎的超文本。该系统实际上是一个有限状态机，对每个请求的响应都包含从一种状态转移到另一种状态所需的信息；不需要其他信息。</p><p>返回的链接集可能会更改，具体取决于资源的状态。这就是超文本作为“应用程序状态引擎”的含义。</p></li></ul><p>REST 要求客户端向服务器发出请求，以便检索或修改服务器上的数据。一个请求通常包括：</p><ul><li>一个 HTTP 动词，它定义了要执行的操作类型</li><li>一个<em>标头</em>，它允许客户端传递有关请求的信息</li><li>资源的路径</li><li>包含数据的可选消息正文</li></ul><p>我们在请求中使用了 4 个基本的 HTTP 动词来与 REST 系统中的资源进行交互：</p><ul><li>GET — 检索特定资源（通过 id）或资源集合</li><li>POST — 创建一个新资源</li><li>PUT — 更新特定资源（通过 id）</li><li>DELETE — 通过 id 删除特定资源</li></ul><p>请求必须包含指向应该对其执行操作的资源的路径。在 RESTful API 中，应该设计路径以帮助客户端了解正在发生的事情。路径的第一部分应该是资源的复数形式。<code>fashionboutique.com/customers/223/orders/12</code>即使您以前从未见过这条特定路径，like 路径也很清楚它指向的内容，因为它是分层的和描述性的。我们可以看到，我们正在<code>id</code>为<code>id</code>223的客户访问12的订单。路径应包含定位资源所需的特定程度所需的信息。在引用资源列表或集合时，并不总是需要添加<code>id</code>. 例如，对<code>fashionboutique.com/customers</code>路径的 POST 请求不需要额外的标识符，因为服务器将为<code>id</code>新对象生成一个。如果我们尝试访问单个资源，则需要<code>id</code>在路径后附加。例如： <code>GET fashionboutique.com/customers/:id</code>— 检索<code>customers</code>资源中<code>id</code>指定的项目。 <code>DELETE fashionboutique.com/customers/:id</code>— 删除<code>customers</code>资源中<code>id</code>指定的项目。</p><p>人类应该能够轻松阅读和构建 URL。这有助于发现并简化在没有良好支持的客户端库的平台上的采用。除了友好的 URL 之外，可以移动或重命名的资源应该公开一个包含唯一稳定标识符的 URL。可能需要与服务交互以从资源的友好名称中获取稳定的 URL，例如某些服务使用的“/my”快捷方式。稳定标识符不需要是 GUID。操作必须尽可能使用正确的 HTTP 方法，并且必须遵守操作幂等性。HTTP 方法通常称为 HTTP 动词。</p><p>随着数据的增长，集合也在增长。规划分页对于所有服务都很重要。因此，当有多个页面可用时，序列化有效负载必须包含下一个页面的不透明 URL。集合查询的结果可以根据属性值进行排序。该属性由*$orderBy<em>查询参数的值确定。如果服务不支持按</em>$orderBy*表达式中命名的属性进行排序，则服务必须以响应不支持的请求部分中定义的错误消息进行响应。</p><p>如果调用者请求在功能允许列表中发现不受支持的功能，服务必须提供错误响应。错误响应必须是来自 4xx 系列的 HTTP 状态代码，指示无法满足请求。</p><p>由于 REST 专门针对分布式信息系统，因此它将应用程序视为信息和控制替代方案的内聚结构，用户可以通过它来执行所需的任务。小粒度或中粒度消息用于控制语义，但大部分应用程序工作是通过包含完整资源表示的大粒度消息完成的。请求语义的最常见形式是检索资源的表示（例如，HTTP 中的“GET”方法），通常可以将其缓存以供以后重用。REST 将所有控制状态集中到响应交互而接收到的表示中。目标是通过消除服务器在当前请求之外保持对客户端状态的感知的任何需要来提高服务器可伸缩性。An application’s state is therefore defined by its pending requests, the topology of connected components (some of which may be filtering buffered data), the active requests on those connectors, the data flow of representations in response to those requests, and the processing of those representations as they are received by the user agent.只要没有未完成的请求，应用程序就会达到稳定状态；即，它没有未决请求，并且对其当前请求集的所有响应都已完全接收或接收到可以将它们视为表示数据流的程度。对于浏览器应用程序，此状态对应于“网页”，包括主要表示和辅助表示，例如内嵌图像、嵌入的小程序和样式表。应用稳态的重要性体现在它们对用户感知性能和网络请求流量突发性的影响中。浏览器应用程序的用户感知性能取决于稳态之间的延迟：在一个网页上选择超媒体链接和为下一个网页呈现可用信息之间的时间段。因此，浏览器性能的优化集中在减少这种通信延迟上。由于基于 REST 的架构主要通过资源表示的传输进行通信，因此延迟可能会受到通信协议设计和表示数据格式设计的影响。在接收到响应数据时增量呈现响应数据的能力取决于媒体类型的设计和每个表示中的布局信息（内嵌对象的视觉尺寸）的可用性。</p><p>一个有趣的观察是最有效的网络请求是不使用网络的请求。换句话说，重用缓存响应的能力可显着提高应用程序性能。尽管由于查找开销，使用缓存会为每个单独的请求增加一些延迟，但即使是一小部分请求导致可用缓存命中，平均请求延迟也会显着降低。应用程序的下一个控制状态驻留在第一个请求资源的表示中，因此获得第一个表示是一个优先事项。因此，REST 交互通过“先响应后思考”的协议得到改进。换句话说，一个需要每个用户操作多次交互的协议，以便在发送内容响应之前执行诸如协商功能功能之类的事情，将比 （一种协议，它首先发送最有可能是最佳的，然后在第一个响应不令人满意时为客户端提供一个可供选择的列表。） 感知速度更慢。应用程序状态由用户代理控制和存储，并且可以由来自多个服务器的表示组成。除了将服务器从存储状态的可扩展性问题中解放出来之外，这还允许用户直接操作状态（例如，Web 浏览器的历史记录），预测该状态的变化（例如，链接映射和表示的预取），并跳转从一个应用程序到另一个应用程序（例如，书签和 URI 条目对话框）。因此，模型应用程序是一个引擎，通过检查和选择当前表示集合中的替代状态转换，从一个状态移动到下一个状态。毫不奇怪，这与超媒体浏览器的用户界面完全匹配。但是，该样式并不假定所有应用程序都是浏览器。事实上，应用程序的详细信息通过通用连接器接口对服务器隐藏，因此用户代理同样可以是为索引服务执行信息检索的自动化机器人，寻找符合特定标准的数据的个人代理，或维护Spider 忙于在信息中查找损坏的引用或修改的内容 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_39">39</a> ]。</p><p>REST 确定的 HTTP 中的关键问题领域包括规划新协议版本的部署、将消息解析与 HTTP 语义和底层传输层 (TCP) 分开、区分权威和非权威响应、细粒度控制缓存，以及无法自我描述的协议的各个方面。REST 还被用于对基于 HTTP 的 Web 应用程序的性能进行建模，并预测诸如持久连接和内容协商等扩展的影响。最后，REST 已被用于将标准化 HTTP 扩展的范围限制在适合架构模型的范围内，而不是允许滥用 HTTP 的应用程序同样影响标准。</p><p>REST 的主要目标之一是支持在已经部署的架构中逐步和分散部署变更。通过引入版本控制要求和规则来扩展协议的每个语法元素，对 HTTP 进行了修改以支持该目标。HTTP 请求语义由请求方法名称表示。只要可以在客户端、服务器和它们之间的任何中介之间共享一组标准化的语义，就允许方法扩展。不幸的是，早期的 HTTP 扩展，特别是 HEAD 方法，使得 HTTP 响应消息的解析依赖于了解请求方法的语义。这导致了部署矛盾：如果接收方需要知道方法的语义才能被中介安全转发，那么在部署新方法之前必须更新所有中介。通过将解析和转发 HTTP 消息的规则与与新 HTTP 协议元素关联的语义分离，此部署问题已得到解决。例如，HEAD 是唯一一种方法，Content-Length 头字段除了表示消息体长度之外，还有其他意义，并且没有新的方法可以改变消息长度的计算。GET 和 HEAD 也是条件请求头字段具有缓存刷新语义的唯一方法，而对于所有其他方法，它们具有前提条件的含义。同样，HTTP 需要一个通用规则来解释新的响应状态代码，以便可以部署新的响应而不会显着损害旧客户端。因此，我们扩展了规则，即每个状态代码都属于由其三位十进制数的第一位表示的类别：100-199 表示消息包含临时信息响应，200-299 表示请求成功，300 -399 表示请求需要重定向到另一个资源， 400-499 表示客户端犯了一个不应重复的错误， 500-599 表示服务器遇到了错误，但客户端可能会得到更好的稍后（或通过其他服务器）响应。如果接收者不理解给定消息中状态代码的特定语义，那么他们必须像对待它的类中的 x00 代码一样对待它。</p><p>REST 将组件之间的消息限制为自描述的，以支持交互的中间处理。由于 REST 试图在对高效、低延迟行为的需求与对语义透明缓存行为的需求之间取得平衡，因此 HTTP 允许应用程序确定缓存要求而不是将其硬编码到协议本身中是至关重要的。协议要做的最重要的事情是完整准确地描述正在传输的数据，这样任何应用程序都不会被愚弄，认为它只有一件事，而实际上它有其他东西。HTTP/1.1 通过添加 Cache-Control、Age、Etag 和 Vary 标头字段来实现这一点。</p><p>所有资源都将请求（由方法、标识符、请求头字段，有时是表示）映射到响应（由状态代码、响应头字段，有时是表示）。</p><p>HTTP 不支持回写缓存。HTTP 缓存不能假设通过它写入的内容与从对该资源的后续请求中可检索的内容相同，因此它无法缓存 PUT 请求正文并将其重用于以后的 GET 响应。这条规则有两个原因：1) 元数据可能在幕后生成，2) 无法从 PUT 请求中确定对以后 GET 请求的访问控制。但是，由于使用 Web 的写入操作极为罕见，因此缺少回写缓存不会对性能产生重大影响。</p><p>Cookie 还违反了 REST，因为它们允许在没有充分识别其语义的情况下传递数据，从而成为安全和隐私方面的问题。cookie 与 Referer [sic] 标头字段的组合可以在用户在站点之间浏览时对其进行跟踪。因此，Web 上基于 cookie 的应用程序永远不会可靠。应该通过匿名身份验证和真正的客户端状态来完成相同的功能。使用上下文设置 URI 而不是 cookie 的明智使用可以更有效地实现涉及偏好的状态机制，其中明智意味着每个状态一个 URI，而不是由于嵌入了用户 ID 的无限数量的 URI。理想的 ReSTful 服务允许客户端（可能不在浏览器中）<em>在一个请求中</em>执行任何需要的任务；因为执行此操作所需的完整状态由客户端保存，而不是由服务器保存。由于客户端完全控制状态，它可以自己创建状态（如果这是合法的），并且只与 API 对话以“完成”。需要 cookie 会使这变得困难。对于浏览器以外的客户端，与查询参数、普通请求头或请求正文相比，管理 cookie 是一个相当大的不便。另一方面，在浏览器中，使用 cookie 可以让很多事情变得更简单。</p><h1 id="Web成熟度模型"><a href="#Web成熟度模型" class="headerlink" title="Web成熟度模型"></a>Web成熟度模型</h1><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img54.png" alt="img54"></p><p>万维网的技术形成了网络服务的技术栈。当人们设计 Web 服务时，他们倾向于从堆栈底部选择一些技术。您可以通过查看他们是选择零、一项、两项还是三项技术来粗略地判断他们。当我说您从堆栈中选择时，我并不是说您会找到根本不使用 HTTP 或没有 URI 的 Web 服务。我的意思是有一类 Web 服务并没有真正获得 URI 或没有真正获得 HTTP。该模型之所以有用，是因为这三种技术是 RESTful 约束的真实实现。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/overview.png" alt="overview"></p><p>我要强调的是，RMM 虽然是思考 REST 元素的好方法，但并不是 REST 本身级别的定义。Roy Fielding 已经明确表示，<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">级别 3 RMM 是 REST 的先决条件</a>。 RMM 的有用之处在于它提供了一个很好的逐步方式来理解rest背后的基本思想。因此，我认为它是帮助我们了解概念的工具，而不是应该在某种评估机制中使用的东西。我认为我们还没有足够的例子来真正确定 restful 方法是集成系统的正确方法，我确实认为这是一种非常有吸引力的方法，并且在大多数情况下我会推荐这种方法。</p><p>该模型的吸引力在于它与常见设计技术的关系。</p><ul><li>级别 1 通过使用分而治之，将大型服务端点分解为多个资源来解决处理复杂性的问题。</li><li>级别 2 引入了一组标准的动词，以便我们以相同的方式处理类似的情况，消除不必要的变化。</li><li>级别 3 引入了可发现性，提供了一种使协议更具自文档性的方法。</li></ul><hr><ul><li><p>0级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img55.png" alt="img55"></p><p>如果您查看 XML-RPC 服务或典型的 SOAP 服务（例如 Google 现已弃用的搜索服务），您会看到一些看起来很像 C 库的东西。有很多函数，有时用句点命名。所有这些功能都可以通过向一个 URI 发送 POST 请求来访问。这些网站很烦人，因为它们实际上并不在网络上。有一个小的基于网络的窥视孔进入其他宇宙，你只能通过窥视孔传递消息来与另一个宇宙交流。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level0.png" alt="level0"></p><p>该模型的出发点是使用 HTTP 作为远程交互的传输系统，但不使用任何网络机制。本质上，您在这里所做的是使用 HTTP 作为您自己的远程交互机制的隧道机制，通常基于<a href="http://www.eaipatterns.com/EncapsulatedSynchronousIntegration.html">Remote Procedure Invocation</a>。</p><p>它只是来回传递普通的旧 XML (POX)。如果您使用 SOAP 或 XML-RPC，它的机制基本相同，唯一的区别是您将 XML 消息包装在某种信封中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>The server then will return a document giving me this information<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">reason</span>&gt;</span>Slot not available<span class="hljs-tag">&lt;/<span class="hljs-name">reason</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>1级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img56.png" alt="img56"></p><p>为每个单独的事物提供了一个 URI。如果我们以一级思维回到 XML-RPC 示例，我们可以说它有什么问题。只有一种资源，这个黑匣子。我们看到了解决方案：将复杂性从黑匣子中取出并制造更多资源。将 Web 服务拆分为其分子组件，并为每个分子提供自己的 URI。</p><p>Web 的强大之处在于它为您提供了将任务的固有复杂性拆分为小块的工具。URI 允许您为系统中的每个对象命名。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level1.png" alt="level1"></p><p>在 RMM 中实现 Glory of Rest 的第一步是引入资源。因此，现在我们不再向单个服务端点发出所有请求，而是开始与单个资源进行对话。</p><p>回复携带相同的基本信息，但现在每个时隙都是可以单独寻址的资源。</p><p>使用特定资源预订约会意味着发布到特定时段。</p><p>对于像我这样的对象人来说，这就像特定对象的概念。我们不是在以太中调用某个函数并传递参数，而是在一个特定对象上调用一个方法，为其他信息提供参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /doctors/mjones HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span>/&gt;</span><br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img58.png" alt="img58"></p><p>在 HTTP 层面，Web 的主要进步在于，虽然它可以处理任何类型的操作，但它将读取操作、想要获取数据的操作分开，并对其进行特殊处理。</p><p>在 80 年代和 90 年代，“get”与 FTP、Gopher、WAIS、Archie 和 Comp-U-Store 的含义截然不同。取消引用 FTP URI 是一个巨大的音乐数字。当所有这些协议都转移到 Web 上，并且所有这些信息都获得了 URI 时，突然间“get”对所有这些协议都意味着同样的事情。URI 的意思是“那个”，HTTP 方法的意思是“给我”。这里是堆栈的 URI 部分与 HTTP 部分相遇的地方。RFC 2616 赋予 GET 特定含义。GET 请求必须是安全的和幂等的，等等。GET 的确切含义并不重要。重要的是 GET 对其含义有限制，当存在限制时，您可以围绕它们进行优化：条件 GET、部分 GET、可靠性、可缓存性等等。这就是统一接口的价值。一级服务不遵守这些限制。</p><p>您发出的每个 XML-RPC 请求都使用 POST。HTTP 标准对 POST 没有任何限制。您可能正在获取数据，您可能正在修改数据，但无法知道。HTTP POST 的意思是“随便！” 您无法对安全或幂等请求应用优化，因为无法知道哪些请求满足这些要求。</p><p>我们使用的 Web 仅使用 GET 和 POST，因为它们是 HTML 4 支持的唯一方法。但大多数 RESTful 更进一步，将 PUT 和 DELETE 从 POST 中分离出来。我想你可能对这场争论很熟悉。关于这些方法的价值存在争论，但这是关于成熟启发式的第二级争论，而不是关于谁更纯粹或更实用的争论。这些方法或任何方法的论据是，如果我们将它们从 POST 中分离出来，它们开始意味着除了“随便！”之外的其他内容。我们可以围绕它们进行优化。</p><p>缺点是，当您添加 HTTP 方法时，您会限制可以理解您的服务语义的客户端的范围</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level2.png" alt="level2"></p><p>我在 0 级和 1 级的所有交互中都使用了 HTTP POST 动词，但有些人使用 GET 代替或另外使用。在这些级别上并没有太大区别，它们都被用作隧道机制，允许您通过 HTTP 隧道进行交互。级别 2 远离此，使用 HTTP 动词尽可能接近它们在 HTTP 本身中的使用方式。</p><p>在第 2 级，对这样的请求使用 GET 是至关重要的。 HTTP 将 GET 定义为安全操作，即它不会对任何事物的状态进行任何重大更改。这使我们能够以任何顺序安全地多次调用 GET，并且每次都获得相同的结果。这样做的一个重要结果是，它允许请求路由中的任何参与者使用缓存，这是使 Web 表现良好的关键因素。HTTP 包括各种支持缓存的措施，可供通信中的所有参与者使用。通过遵循 HTTP 规则，我们能够利用该功能.</p><p>即使我使用与级别 1 相同的帖子，远程服务的响应方式也存在另一个显着差异。如果一切顺利，该服务将回复 201 的响应代码，以表明世界上有新资源。201 响应包含一个带有 URI 的位置属性，客户端可以使用该 URI 获取该资源在未来的当前状态。此处的响应还包括该资源的表示，以立即为客户端节省额外的调用。</p><p>此响应的重要部分是使用 HTTP 响应代码来指示出现问题。在这种情况下，409 似乎是一个不错的选择，表明其他人已经以不兼容的方式更新了资源。与使用 200 的返回码但包括错误响应不同，在级别 2 中，我们明确地使用了某种类似这样的错误响应。由协议设计者决定使用什么代码，但如果出现错误，应该有一个非 2xx 响应。级别 2 介绍使用 HTTP 动词和 HTTP 响应代码。</p><p>这里有一种矛盾。REST 倡导者谈论使用所有 HTTP 动词。他们还通过说 REST 试图从网络的实际成功中学习来证明他们的方法是合理的。但是万维网在实践中并没有太多地使用 PUT 或 DELETE。网络实践所支持的关键元素是安全（例如 GET）和非安全操作之间的强分离，以及使用状态代码来帮助传达您遇到的错误类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 409 Conflict<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>3级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img66.png" alt="img66"></p><p>如果您嵌入实际的 URI，您的客户可以更容易地从一种资源移动到另一种资源。撇开那些不仅可以使用它们的 URI 很烦人的事实，这种设计在客户端和这个特定的 Web 服务之间创建了耦合。您必须编写无法重用的自定义客户端代码。客户端行为由 Web 服务当前提供的文档编程，而不是由过去决定的内容编程。资源之间的连接是一种数据形式，它们应该与其余数据一起在文档中进行描述。让您的客户专注于查看该文档并决定下一步做什么。不是内化关于您将数据放在网络上的位置的特定规则。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level3.png" alt="level3"></p><p>每个时间片都有一个链接元素，其中包含一个 URI 来告诉我们如何预约。超媒体控制的重点在于它们告诉我们下一步可以做什么，以及我们需要操纵的资源的 URI 来完成它。我们不必知道在哪里发布我们的预约请求，响应中的超媒体控件告诉我们如何去做。</p><p>超媒体控制的一个明显好处是它允许服务器在不破坏客户端的情况下更改其 URI 方案。只要客户端查找“addTest”链接 URI，服务器团队就可以处理除初始入口点之外的所有 URI。</p><p>另一个好处是它可以帮助客户端开发人员探索协议。这些链接为客户开发人员提供了下一步可能的提示。它没有提供所有信息：“self”和“cancel”控件都指向同一个 URI——它们需要确定一个是 GET，另一个是 DELETE。但至少它为他们提供了一个起点，让他们了解更多信息并在协议文档中寻找类似的 URI。</p><p>同样，它允许服务器团队通过在响应中放置新链接来宣传新功能。如果客户端开发人员密切关注未知链接，这些链接可能会触发进一步探索。</p><p>关于如何表示超媒体控件没有绝对的标准。遵循 ATOM ( <a href="https://tools.ietf.org/html/rfc4287">RFC 4287</a> )指出，众所周知<a href="http://www.iana.org/assignments/link-relations.html">的链接关系</a>的定义是<a href="http://www.iana.org/assignments/link-relations.html">链接关系注册表</a>。这些仅限于 ATOM 所做的事情，它通常被视为 3 级的领导者。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br>But the response has a new element<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/5678&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: http://royalhope.nhs.uk/slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/addTest&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment/tests&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;self&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/changeTime&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/doctors/mjones/slots?date=20100104&amp;status=open&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/updateContactInfo&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/patients/jsmith/contactInfo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/help&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/help/appointment&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Thomas Fielding.Architectural Styles and the Design of Network-based Software Architectures.2000</a></p><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Wiki:Representational state transfer</a></p><p><a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html">Leonard Richardson.Justice Will Take Us Millions Of Intricate Moves.2008</a></p><p><a href="https://martinfowler.com/articles/richardsonMaturityModel.html#level0">Martin Fowler.Richardson Maturity Model.2010</a></p><p><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md">Microsoft REST API Guidelines</a></p><p><a href="https://cloud.google.com/apis/design">Google Cloud API 设计指南</a></p><p><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">Ed Price - MSFT.RESTful web API design.2018</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc5789">RFC5789</a></p><p><a href="https://zh.wikipedia.org/wiki/XML-RPC">Wiki:XML-RPC</a></p><p><a href="http://xmlrpc.com/">XML-RPC Home</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">Wiki:SOAP</a></p><p><a href="https://web.archive.org/web/20080915090248/http://webservices.xml.com/pub/a/ws/2001/04/04/soap.html">A Brief History of SOAP</a></p><p><a href="https://www.w3.org/TR/soap/">W3C:SOAP</a></p>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
