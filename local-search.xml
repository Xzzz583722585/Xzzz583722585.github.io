<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>工作笔记</title>
    <link href="/2023/08/19/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/19/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="订单消息中心"><a href="#订单消息中心" class="headerlink" title="订单消息中心"></a>订单消息中心</h2><ol><li>本地消息表：落订单数据表的时候，会利用Mysql的事务机制，保证同时成功落本地消息表，代表之后要发送的通知消息。消息表主要包含订单id、消息状态、消息初始内容、消息最终内容、创建时间、最后发送消息的时间</li><li>重试：调用带有 callback 的 send 方法，可以确认消息是否发送成功。</li><li>幂等性生产者：本地消息表的唯一键保证</li></ol><h2 id="设计模式在订单系统的应用"><a href="#设计模式在订单系统的应用" class="headerlink" title="设计模式在订单系统的应用"></a>设计模式在订单系统的应用</h2><ol><li><p>核心逻辑</p><ul><li>生成器模式<ul><li>分步骤创建复杂对象。</li><li>使用实例<ul><li>创建订单前需要先生成一个复杂的上下文对象，包含订单核心参数、算价结果、用户、用户地址、流程控制信息等，采用生成器模式逐步构建</li></ul></li></ul></li><li>责任链模式<ul><li>沿着处理链的各个节点依次处理请求</li><li>使用实例<ul><li>订单正向流程（创建结算单、创建订单、提交订单）的各类校验，有入参校验、商品信息校验、业务校验等。</li><li>算价会定义一系列又先后计算关系的价格类型，依次进行计算，并生成相应价格 ，最终完成所有价格的计算并输出</li></ul></li></ul></li><li>策略模式<ul><li>相同算法，不同策略会产生不同的结果</li><li>使用实例<ul><li>算价时，每种促销源，会设置其支持的价格类型。根据当前要计算的价格类型，获取不同的促销数据，进而计算价格。</li><li>创建订单时，依次需要准备上下文、校验、锁定资源、落库、落库失败时释放资源、发送通知、打点步骤，其中锁定资源、落库失败时释放资源阶段，根据设置策略不同，会操作不同资源。提交订单情况类似。</li></ul></li></ul></li><li>工厂模式<ul><li>在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</li><li>使用实例<ul><li>分布式锁工厂，底层有RedisLockFactory和EtcdLockFactory两种实现，用于生产锁工具，然后利用锁工具加锁</li></ul></li></ul></li><li>其他<ul><li>使用实例<ul><li>我们并没有实现空对象，但要说的是，我们系统内部使用Money对象封装所有与钱相关的数据，即所有Http、rpc接口接收到的钱必须转为Money对象，所有DB查询到的钱必须转为Money对象，所有落DB的钱的值都由Money对象生成<ul><li>优点<ul><li>保证全局对钱的校验、控制逻辑一致，单位一致</li><li>针对各种价钱的定义也都收敛到此处，方便理解业务</li></ul></li><li>缺点<ul><li>代码复杂，可读性查，加减乘除逻辑丑陋</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>代码迁移</p><ul><li>原型模式<ul><li>复制已有对象</li><li>使用实例<ul><li>逻辑迁移的过程中，有时候会进行AB对比，为了防止长处理链路对入参修改（理论上最好是情况是不要对入参做任何修改，但是有债务问题），从而使新老逻辑互相影响，所以规范对入参做copy，然后传入新老逻辑中。</li><li>clone实现有<ul><li>利用getter、setter写方法实现<ul><li>优点<ul><li>不会出现json序列化的问题，出问题也方便定位排查</li></ul></li><li>缺点<ul><li>代码量大，但是有现成的代码生成器，生成的代码需要check，例如list、map这些集合类型需要包装下</li><li>深拷贝成本高</li></ul></li></ul></li><li>json序列化与反序列化两种（一些新实现的代码规定入参不可修改）<ul><li>优点<ul><li>简单快捷</li></ul></li><li>缺点<ul><li>不完全可靠，会出现一些奇怪的json序列化的问题，很难定位排查</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>适配器模式<ul><li>能使接口不兼容的对象能够相互合作</li><li>使用实例<ul><li>逻辑迁移的过程中，新逻辑定义了一套新接口，为了兼容老逻辑与老接口，采用适配器模式</li></ul></li></ul></li><li>代理模式<ul><li>代理控制着对于原对象的访问</li><li>使用实例<ul><li>系统拆分后，老系统里遗留了老逻辑，不能立即下掉。这时候一是采用代理模式，将请求路由至新系统处理，二是采用适配器模式将新系统提供的新接口适配到老接口</li></ul></li></ul></li></ul></li><li><p>公共的</p><ul><li><p>单例模式</p><ul><li>保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</li><li>使用实例<ul><li>Spring Bean</li></ul></li></ul></li><li><p>迭代器模式</p><ul><li>在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素<ul><li>使用实例<ul><li>java for循环、stream</li></ul></li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka面试题</title>
    <link href="/2023/08/18/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/08/18/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>消息持久化</li><li>高吞吐<ul><li>日志追加写</li><li>零拷贝</li><li>reactor 网络模型</li></ul></li><li>高容错</li><li>高可拓展<ul><li><p>多分区多副本</p><ul><li><p>partition 分区</p><ul><li><p>可伸缩性</p><ul><li>将每个 topic 划分为多个分区，不同的分区可以放置在不同的节点上，而数据的读写操作也是针对分区这个粒度进行的，这样每个分区都能独立地处理读写请求</li></ul></li><li><p>分区策略（负载均衡）：</p><ul><li><p> 生产者：将消息发送到哪个分区</p></li><li><p>轮询</p></li><li><p>加权轮询</p></li><li><p>最小连接数</p></li><li><p>加权最小连接数</p></li><li><p>随机</p></li><li><p>源地址映射：订单消息中心就按照dealId分区</p></li><li><p>消费者：从哪个分区读取消息</p><ul><li><p>RoundRobin</p><ul><li>针对所有 topic 分配：将所有分区和消费者按照 hashcode 排序，然后依次分配下去（一张一张发牌）。</li></ul></li><li><p>TopicRange</p><ul><li>按 topic 依次分配：分区数/消费者数就是每个消费者分配到的分区数（余数按顺序依次给前面的消费者每人一个）。对每个 topic 内的分区按需要从小到大排序，对所有消费者按照字典序排序，逐个分配（一次分配完，而不是一张一张发牌）。</li></ul></li><li><p>Sticky</p><ul><li>尽可能保证分区分配均衡（优先级更高）</li><li>rebalance 情况下尽可能保留现有分区</li></ul></li><li><p>CooperativeSticky</p><ul><li>上述三种策略都会导致一次全局的重新分配</li><li>本策略分成多次小规模的重新分配</li></ul></li></ul></li></ul></li><li><p>数据持久化</p><ul><li>使用日志文件保存数据。写入消息就在文件末尾追加，消费消息就从offset （最新的读取位置）顺序读取。所以可以保证消息在 partition 内有序，但在 topic 内无序</li><li>对日志进行分段 segment，当写满一个日志段后，就会新建一个日志段继续写，并且会将之前的日志段封存起来。会有定时任务定期检查日志段并删除</li></ul></li><li><p>索引</p><ul><li>偏移量索引</li><li>时间戳索引</li></ul></li></ul></li><li><p>replication 副本</p><ul><li>好处<ul><li>数据可靠性：分布在不同机器上</li><li>高伸缩性（没有，因为副本不对外提供任何服务）</li><li>改善数据局部性，可以更加靠近用户地理位置，从而降低延迟（没有）</li></ul></li><li>为什么不要另外两个好处<ul><li>本身可以实现高吞吐量，不需要额外提供读服务</li><li>没有数据一致性问题</li></ul></li><li>针对分区做数据备份，每个分区有多个副本</li><li>分类<ul><li>partition leader 分区主副本<ul><li>主副本，对外提供读写功能</li><li>由 controller leader 负责选举出 partition leader</li></ul></li><li>partition follower 分区从副本<ul><li>备份副本，只做数据备份，不提供任何功能</li><li>ISR<ul><li>由主副本负责维护。代表了与主副本进度同步的副本集合。所以主副本天生就在 ISR 内，如果不在，说明主副本挂掉了。判断一个副本在不在 ISR 的标准就是他落后主副本的最长连续时间间隔，默认不超过10秒。通过LEO判断。</li><li>ISR 是动态集合。如果一个副本落后主副本的时间超过阈值，就会被踢出 ISR。反之如果这个副本追上了主副本进度，会重新加入 ISR。</li><li>unclean 选举：主副本挂掉时，ISR 集合为空，需要根据配置判断是否可以从进度落后主副本的从副本中选主，是一个可用性与数据一致性的选择问题。</li></ul></li></ul></li></ul></li><li>主从同步<ul><li>从副本异步拉取最新数据</li><li>高水位 HW：位移小于高水位的消息属于已提交消息（参见生产者ack），可以被消费者消费。位移大于等于高水位的消息属于未提交消息，不可以被消费者消费。分区的高水位就是主副本的高水位。</li><li>日志末端位移 LEO：当前副本写入下一条消息的位移值</li><li>远程副本LEO：主副本所在 broker 为了辅助主副本判断其HW，保存了各个从副本的LEO值在主 broker 上，称为远程副本</li><li>更新机制<ul><li>主副本LEO：主副本接收到生产者发送来的消息，写入磁盘成功后，更新LEO</li><li>主副本HW<ul><li>主副本.HW = min{主副本.LEO, 从副本1.LEO, …, 从副本n.LEO}</li><li>更新时机<ul><li>主副本更新LEO后</li><li>远程副本更新LEO后</li></ul></li></ul></li><li>从副本 LEO：从副本拉取主副本消息，写入磁盘成功后，更新LEO</li><li>从副本 HW：从副本更新完自己的LEO后，从副本.HW = min{从副本.LEO, 主副本.HW}</li><li>远程副本LEO：从副本拉取主副本消息时，会告诉主副本从哪个位移位置开始拉取，此时会更新远程副本LEO为这个开始位移值</li></ul></li></ul></li><li>主从切换：zookeeper 负责选主</li></ul></li></ul></li></ul></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>本质上是通过中间层，做应用解耦。以此带来了异步通信与流量削峰的好处。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>kafka 是分布式的消息引擎，提供一套完备的消息发布订阅解决方案。</p><ul><li><p>topic 主题</p><ul><li>发布订阅的对象，是一类数据的集合，相当于数据库中的表</li></ul></li><li><p>client 客户端</p><ul><li>producer 生产者<ul><li>向订阅的 topic 发布消息的客户端</li><li>向集群push消息</li></ul></li><li>consumer 消费者<ul><li><p>从订阅的 topic 读取消息的客户端，从集群pull消息</p></li><li><p>消费者 offset</p><ul><li>记录当前实例消费的位置，具体指下一条需要的消息位置，而不是最新消费过的消息位置。需要向分配给它的每个分区提交位移。目的是消费者重启后，能够从上次提交的位置直接重新读取，而不需要从头再来。</li><li>方式<ul><li>自动提交<ul><li>每次 poll 消息，都会先提交上次 poll 返回的所有消息，再处理当前消息</li><li>默认每5秒提交一次</li></ul></li><li>手动提交<ul><li>可以指定消费位移</li></ul></li><li>同步提交</li><li>异步提交<ul><li>不会自动重试</li></ul></li></ul></li></ul></li><li><p>consumer group 消费者组</p><ul><li><p>多个消费者实例组成一个 group，共同消费一组 topic。这组 topic 内的每个分区，都只会被组内的唯一消费者消费。不同组之间，可以重复消费同一个分组。</p></li><li><p>消息模式</p><ul><li><p>点对点</p><ul><li>目的是提高消费端的吞吐量，避免重复消费</li></ul></li><li><p>发布订阅</p></li></ul></li><li><p>保存位移数据</p><ul><li><p>针对每个分区，本组中只有一个消费者会消费它</p></li><li><p>Map&lt;topic-partition, offset&gt;存储每个分区的消费位移</p></li><li><p>Coordinator 协调者</p><ul><li>负责为 group 执行 rebalance、位移管理和组成员管理。所有 broker 启动时，都会开启 Coordinator 组件。当某个 comsumer 向集群提交位移，其实是向服务他的 Coordinator 提交位移。</li><li>消费组内的分区会分配给某个 comsumer 消费，那么这个分区对应的 leader partition 所在 broker 的 Coordinator，就是该消费者需要连接并提交位移的  Coordinator。</li><li>存储位置</li><li>场景要求<ul><li>持久性</li><li>频繁写</li><li>老版本</li><li>zookeeper，但问题是 zookeeper 不适合这种频繁写操作的场景<ul><li>目的是减少 broker 保存状态的开销，并且可以做到无状态，方便拓展</li></ul></li><li>新版本<ul><li>专门存储消费位移的 topic： __consumer_offsets，因为 kafka 天生就是符合这个场景</li><li>专门的后台线程，类似于 AOF 重写式地删除过期消息</li></ul></li></ul></li></ul></li><li><p>rebalance</p></li><li><p>问题</p><ul><li>STW 式的重新分配过程，在此期间无法提供服务</li><li>效率低</li><li>很慢</li></ul></li><li><p>触发条件</p><ul><li><p>组内成员发生变更</p><ul><li><p>原因</p><ul><li>心跳检测失败</li><li>消费时间过长</li><li>消费者实例 GC 问题</li></ul></li><li><p>执行过程</p></li><li><p>当某个消费者主动加入/主动退出/被动退出（被心跳检测出）时，协调者向现有组内成员发出命令，要求他们退出组并重新加入</p><ul><li>协调者收集完所有成员的加入请求后，会将第一个加入组的消费者指定为领导者，并要求他置顶重平衡策略</li><li>领导者负责执行重平衡策略，完成后将其发送给协调者</li><li>协调者将分区方案依次发送给组内每一个消费者</li></ul></li></ul></li><li><p>订阅主题发生变更（一般不变）</p></li></ul></li><li><p>订阅主题的分区数发生变更（一般不变）</p></li></ul></li></ul></li></ul></li></ul></li><li><p>server 集群</p><ul><li><p>可用性</p></li><li><p>broker 实例</p><ul><li>实际执行任务的进程，主要负责接收和处理客户端发送过来的请求，以及数据持久化</li><li>controller<ul><li>每个 broker 启动时都会创建一个 controller 进程</li><li>通过 zookeeper，选举出 controller leader</li><li>controller leader 负责管理集群的分区和副本状态</li></ul></li></ul></li><li><p>网络模型</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/kafka/network.jpg"></p><p>大体上基于 reactor 模型。网络线程池基于 I/O 多路复用，处理完套接字后，将请求放入共享请求队列（相当于缓冲区）内，I/O线程池会不断处理共享请求队列内的请求。如果是不能立即处理的延时请求，就会先将这个请求放入炼狱队列中，等待时机成熟再处理。处理完成的相应会被放入网络县城对应的响应队列中，分别传回客户端。</p><p>另外，控制类请求和数据类请求的处理逻辑一致，但是分别由两套独立上述机制处理。</p></li></ul></li></ul><h2 id="消息可靠性承诺"><a href="#消息可靠性承诺" class="headerlink" title="消息可靠性承诺"></a>消息可靠性承诺</h2><ul><li>最多一次：消息可能丢失，但绝不会重复发送<ul><li>实现：生产者保证不会生成重复消息，并且只发送一遍，发送出去后就不关心了，也不会重试</li></ul></li><li>至少一次：消息不会丢失，但有可能重复发送<ul><li><p>实现：消息丢失</p><ul><li><p>生产者</p><ul><li>本地消息表：落业务数据表的时候，会利用Mysql的事务机制，保证同时成功落本地消息表。</li><li>重试<ul><li>手动重试：调用带有 callback 的 send 方法，可以确认消息是否发送成功</li><li>自动重试：设置 retries</li></ul></li><li>设置 acks<ul><li>有多少副本确认提交后才算提交成功</li></ul></li></ul></li><li><p>服务器：可靠性保证</p><ul><li>冗余副本机制</li><li>禁用 unclean leader：leader 副本挂掉后，一定从 ISR 中挑选新 leader，否则宁愿不可用</li><li>ISR</li><li>高水位线</li></ul></li><li><p>消费者</p><ul><li>先消费消息，再更新位移</li><li>关闭自动提交位移，而是手动提交位移</li></ul></li></ul></li></ul></li><li>精确一次：消息不会丢失，也不会重复发送<ul><li>实现：消息重复<ul><li>生产者<ul><li>本地消息表：业务系统使用数据库唯一键，自己保证消息的幂等性</li><li>幂等型生产者<ul><li>设置幂等键</li><li>可以保证单分区上的幂等性，无法保证多分去区之间的幂等性</li></ul></li><li>事务型生产者<ul><li>设置为幂等型生产者</li><li>设置事务id</li><li>设置隔离级别</li><li>2pc实现</li></ul></li></ul></li><li>消费者<ul><li>业务系统自己保证</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring面试题</title>
    <link href="/2023/08/12/spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/08/12/spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="什么是-IoC-和-DI"><a href="#什么是-IoC-和-DI" class="headerlink" title="什么是 IoC 和 DI"></a>什么是 IoC 和 DI</h2><p>IoC 控制反转，不是一种具体技术，而是一种设计思想，能指导我们如何设计出松耦合的程序。指的是将我们需要使用的对象交给 IOC 容器进行管理控制，由容器进行注入依赖对象。而不是传统的在类内部主动创建依赖对象并进行组合、管理。</p><p>DI 依赖注入，指的是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度的描述。通俗来说就是 IoC是设计思想，DI是实现方式。</p><h2 id="IoC-bean-的配置方式"><a href="#IoC-bean-的配置方式" class="headerlink" title="IoC bean 的配置方式"></a>IoC bean 的配置方式</h2><ul><li>xml</li><li>@Configuration</li><li>注解<ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul></li></ul><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><ul><li><p>setter 方式</p><ul><li>需要默认构造器</li><li>需要 setter 方法</li></ul></li><li><p>构造器方式（推荐）</p><ul><li>需要对应的构造器</li><li>优点<ul><li>依赖不可变：final关键字</li><li>依赖不为空</li><li>完全初始化的状态：向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步，所以返回来的都是初始化之后的状态。</li><li>没有循环依赖问题：启动时会报错</li></ul></li></ul></li><li><p>注解方式</p><ul><li><p>实现</p><ul><li><p>@Autowired</p><ul><li>Spring 自带的注解</li><li>可以作用在构造函数、方法、方法参数、字段、枚举的常量、注解上</li><li>默认根据类型（byType ）进行自动装配的，如果需要按名称进行装配，则需要配合 @Qualifier</li></ul></li><li><p>@Resource</p><ul><li>在 javax.annotation 包下</li><li>可以作用在接口、类、枚举、注解、方法、字段、枚举的常量上</li><li>默认根据属性名称进行自动装配的，只有当找不到与名称匹配的bean才会按照类型来装配注入</li></ul></li><li><p>@Inject</p><ul><li>在 javax.inject.Inject 包下</li></ul><p>2、可以作用在构造函数、方法、字段、枚举的常量上</p><p>3、默认根据类型（byType ）进行自动装配的，如果需要按名称进行装配，则需要配合 @Named</p></li></ul></li><li><p>缺点</p><ul><li>循环依赖问题</li></ul></li></ul></li></ul><h2 id="IoC初始化流程"><a href="#IoC初始化流程" class="headerlink" title="IoC初始化流程"></a>IoC初始化流程</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-ioc/init.png"></p><ol><li>设置资源解析器和环境</li><li>设置配置路径</li><li>IoC容器对Bean定义资源的载入是从 refresh() 函数开始的：<ol><li>初始化 BeanFactory：在创建 BeanFactory 容器前，如果已经有 BeanFactory 存在，则需要把已有的 BeanFactory 销毁和关闭，以保证在 refresh 之后使用的是新建的 BeanFactory 容器。</li><li>读取 Bean 定义资源</li><li>加载 Bean 定义资源</li><li>解析 Bean 定义资源生成 BeanDefinition</li><li>在IoC容器中注册解析后的 BeanDefinition，本质就是一个 ConcurrentHashMap。至此，配置中的 Bean 已经注册到 IoC 容器中，被容器管理起来了。现在 IoC 容器中已经拥有了所有 Bean 的配置信息。这些配置信息是 IoC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</li></ol></li></ol><h2 id="如何解决循环依赖问题"><a href="#如何解决循环依赖问题" class="headerlink" title="如何解决循环依赖问题"></a>如何解决循环依赖问题</h2><ul><li>单例模式下的属性依赖<ul><li>获取单例对象的流程（三级缓存）<ul><li>首先从一级缓存 singletonObjects 中获取，里面存储的是已经实例化并且完成属性赋值的成熟对象；</li><li>如果一级缓存获取不到，并且对象正在创建中，就再从二级缓存 earlySingletonObjects 中获取，里面存储的是已经实例化但尚未完成属性赋值的半成品对象。创建中指的就是半成品对象。</li><li>如果二级缓存获取不到，且允许从三级缓存中获取半成品对象，就从三级缓存 singletonFactory 中获取。若是三级缓存获取到了，则将单例对象从三级缓存提高到二级缓存中。</li><li>三级缓存中的对象，是在单例对象被实例化后，初始化完成前，被塞入到三级缓存内的。原理就是（A对象属性依赖B对象，B对象属性依赖A对象）：<ul><li>A 首先完成了实例化，而且将自身提早曝光到三级缓存中</li><li>此时 A 进行初始化的第二步，发现本身依赖对象 B，此时就尝试去get(B)，发现 B 还没有被创建，因此去走流程创建 B</li><li>B 在初始化时发现自身依赖对象 A，因而尝试get(A)。尝试一级缓存没有，因为 A 还没初始化完成。尝试二级缓存也没有。尝试三级缓存，由于 A 已经实例化后将自身提早曝光了，因此B可以通过三级缓存拿到A对象的半成品。</li><li>B 拿到A对象后顺利完成初始化，将自身放入到一级缓存中。</li><li>此时返回继续初始化 A，A 此时通过一级缓存能拿到 B 对象，顺利初始化，最终A也完成了初始化，将自身放入到一级缓存中。</li></ul></li></ul></li></ul></li><li>其他情况<ul><li>多实例<ul><li>多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。</li><li>把bean改成单例解决</li></ul></li><li>构造器依赖<ul><li>beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。Spring解决循环依赖主要是依赖三级缓存，但是的在调用构造方法之前还未将其放入三级缓存之中，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。</li><li>使用@Lazy注解解决</li></ul></li></ul></li></ul><h2 id="Bean-作用域"><a href="#Bean-作用域" class="headerlink" title="Bean 作用域"></a>Bean 作用域</h2><ul><li>singleton<ul><li>默认</li><li> IoC容器仅存在一个Bean实例，并一直保存引用</li></ul></li><li>prototype<ul><li>每次从容器中调用Bean时，都会返回一个新的实例</li><li>范围是每次获取Bean直至调用者自行销毁，容器创建好交给使用者之后则不会再管理后续的生命周期。</li></ul></li><li>request<ul><li>每次HTTP请求都会创建一个新的Bean</li><li>范围是每次发起http请求直至请求结束</li></ul></li><li>session<ul><li>首次http请求创建一个实例</li><li>范围是首次发起http请求直至session失效</li></ul></li><li>globalsession</li></ul><h2 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-ioc/bean-life.png"></p><ol><li>一些拓展接口的方法，如 BeanFactoryPostProcessor、InstantiationAwareBeanPostProcessor</li><li>根据配置情况调用 Bean 构造方法实例化 Bean</li><li>利用依赖注入完成 Bean 中所有属性值的配置注入</li><li>一些拓展接口的方法</li><li>调用xxxAware接口 (上图只是给了几个例子) <ul><li>第一类Aware接口：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>第二类Aware接口：EnvironmentAware、EmbeddedValueResolverAware、ApplicationContextAware</li><li>其他</li></ul></li><li>一些拓展接口的方法，如 BeanPostProcessor （与 AOP 有关）</li><li>执行 @PostConstruct 注解的方法</li><li>执行配置的 init-method 初始化方法</li><li>一些拓展接口的方法</li><li>单例 bean 则将该 Bean 放入 IoC 的缓存池中，触发 Spring 对该 Bean 的生命周期管理。多例 bean 则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</li><li>执行 @PreDestro注解的方法</li><li>执行配置的 destory-method 销毁方法</li></ol><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h2><h3 id="什么是连接点-JoinPoint"><a href="#什么是连接点-JoinPoint" class="headerlink" title="什么是连接点 JoinPoint"></a>什么是连接点 JoinPoint</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle1.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle2.png"></p><p>单线程JVM运行java程序，就是从main方法开始，一个方法挨着一个方法，一个方法套着多个方法的调用下去。每个线程都会有自己的私有方法栈，每调用一个方法，就是往这个栈内push一个栈桢，栈桢内保存了方法的基本信息和现场信息。那么，如果我们把同一个栈内的栈桢按先后顺序连接起来，其实就是一个方法的顺序执行流。其中每个方法调用就是一个 连接点 JoinPoint。</p><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle3.png"></p><p>即针对上述的方法执行流，可以横向切割出若干切面 Aspect（就是连接点 JoinPoint），我们面向这些切面进行编程，从而增强功能。AOP 目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中，其本质是为了解耦。</p><h3 id="什么是切入点-PointCut"><a href="#什么是切入点-PointCut" class="headerlink" title="什么是切入点 PointCut"></a>什么是切入点 PointCut</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle5.png"></p><p>我们不会针对每个方法进行增强，所以我们可以挑选感兴趣的连接点进行增强，这些被选择的连接点就是切入点 PointCut。</p><h3 id="AOP如何捕获针对切入点的方法调用"><a href="#AOP如何捕获针对切入点的方法调用" class="headerlink" title="AOP如何捕获针对切入点的方法调用"></a>AOP如何捕获针对切入点的方法调用</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle4.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle6.png"></p><p>既然我们选择了切入点，想对其进行增强，那我们如何感知到切入点被调用了呢？这就是代理模式。</p><p>当我们调用一个实例对象的方法时，都会先经过这个实例对象相应的代理对象， 即执行的控制权先交给代理对象。代理对象内部肯定是要调用实力对象的真实方法的，那就可以在真实方法执行前、执行后、异常时都加入额外的逻辑，这就是AOP的实现原理。</p><h3 id="如何自定义增强逻辑"><a href="#如何自定义增强逻辑" class="headerlink" title="如何自定义增强逻辑"></a>如何自定义增强逻辑</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle7.png"></p><p>我们肯定想要针对不同场景指定不同的增强逻辑，那我们就可以将自定义的增强逻辑包装成针对各个位置的建议 Advice，然后在生成代理对象时将它们织入进去。</p><h3 id="如何实现代理"><a href="#如何实现代理" class="headerlink" title="如何实现代理"></a>如何实现代理</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-aop/principle8.png"></p><ul><li><p>静态代理</p><ul><li>在编译期间，由工具类甚至是我们自己手动实现代理对象，并替换原实例对象的调用位置，显然非常低效，可拓展性也很差。</li></ul></li><li><p>动态代理</p><p>之前了解过，Spring 容器里的 bean 都是通过 BeanFactory 工厂类创建出来的。那么如果我们指定的是 ProxyFactoryBean 即生成代理类的工厂，那我们便实现了瞒天过海，将所有原本的实例对象替换成了代理对象，并且这些对象都交由 Spring 容器管理，容器可以获知这些代理对象的一切信息与行为。</p><p>最后只剩一个问题，如何动态地生成这些代理对象。</p><ul><li><p>基于JDK面向接口的动态代理JdkDynamicAopProxy生成代理对象</p><p>利用反射Proxy、InvocationHandler动态织入建议，生成代理对象</p></li><li><p>基于Cglib子类继承方式的动态代理CglibAopProxy生成代理对象</p><p>获取原始对象的字节码文件，改写织入建议后，动态加载代理类，并生成代理对象</p></li></ul></li></ul><h2 id="建议类型"><a href="#建议类型" class="headerlink" title="建议类型"></a>建议类型</h2><ul><li>前置通知：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</li><li>后置通知：在某连接点正常完成后执行的通知。</li><li>异常通知：在方法抛出异常退出时执行的通知。</li><li>最终通知：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知：包围一个连接点的通知，如方法调用。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</li></ul><h2 id="多种增强建议的顺序？"><a href="#多种增强建议的顺序？" class="headerlink" title="多种增强建议的顺序？"></a>多种增强建议的顺序？</h2><p>当定义在不同的切面里的两个通知都需要在一个相同的连接点中运行， 那么除非指定优先级，否则执行的顺序是未知的。在进入连接点的情况下，最高优先级的通知会先执行。 在退出连接点的情况下，最高优先级的通知会最后执行。通过 @Order 注解指定优先级，注解值越低优先级越高。</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><ul><li>Model（模型）：处理应用程序数据逻辑的部分</li><li>View（视图）：处理数据显示的部分</li><li>Controller（控制器）：处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><h2 id="请求处理流程（包含-Servlet）"><a href="#请求处理流程（包含-Servlet）" class="headerlink" title="请求处理流程（包含 Servlet）"></a>请求处理流程（包含 Servlet）</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-mvc/servlet.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/spring-mvc/request.png"></p><ol><li><p>客户端（或浏览器）发送请求至主机（201.187.10.21）的端口 8080，被在该端口上监听的 Connector 所接收。</p></li><li><p>Connector 将该请求交给它所在 Service 的 Engine 处理。</p></li><li><p>Engine 获得请求之后，从报文头中提取主机名称（201.187.10.21），在所有虚拟主机 Host 当中寻找匹配。在未匹配到同名虚拟主机的情况下，Engine 将该请求交给名为 localhost 的默认虚拟主机 Host 处理。</p></li><li><p>Host 获得请求之后，根据 URI 匹配 Context，并将请求交给其处理。</p></li><li><p>Context 构建 HttpServletRequest、HttpServletResponse 对象，将其作为参数传给 Servlet 应用，由应用完成业务逻辑执行、结果数据存储等过程。</p><p>下面讲的 DispatcherServlet 就是上述的 Servlet 实例：</p><ol><li>客户端请求 -&gt; DispatcherServlet：DispatcherServlet 作为统一访问点，进行全局的流程控制，收到请求后自己不进行处理，而是委托给具体的处理器进行处理。</li><li>DispatcherServlet -&gt; HandlerMapping：HandlerMapping 根据 HTTP 请求的 URI 映射到 HandlerExecutionChain 对象，包含一 个Handler 处理器对象、多个 HandlerInterceptor 拦截器对象。</li><li>DispatcherServlet -&gt; HandlerAdapter：HandlerAdapter 是底层多种类型的处理器的适配器，屏蔽掉底层差异。</li><li>HandlerAdapter -&gt; 具体处理器 Handler（如 Controller）：HandlerAdapter 将会根据适配的结果调用真正的处理器方法处理请求，并返回一个 ModelAndView 对象。在调用处理器 Handler 之前其拦截器的方法 preHandler() 会执行。在调用处理器 Handler 之后其拦截器的方法 postHandler() 会执行。</li><li>Handler -&gt; DispatcherServlet：DispatcherServlet 根据返回的 ModelAndView 选择适合的视图解析器 ViewResolver。</li><li>DispatcherServlet -&gt; ViewResolver：ViewResolver 把逻辑视图名解析为具体的 View。</li><li>View -&gt; 渲染：View 会根据传进来的 Model 模型数据进行渲染。</li><li>DispatcherServlet -&gt; 客户端响应：DispatcherServlet 返回渲染后的响应给用户，至此请求处理结束。</li></ol></li><li><p>Context 接收到应用返回的 HttpServletResponse 对象之后将其返回给 Host。</p></li><li><p>Host 将 HttpServletResponse 对象返回给 Engine。</p></li><li><p>Engine 将 HttpServletResponse 对象返回 Connector。</p></li><li><p>Connector 将 HttpServletResponse 对象返回给客户端（或浏览器）</p></li></ol><h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><ol><li>实例化 new：服务器第一次被访问时，加载一个Servlet容器，而且只会被加载一次。</li><li>初始化 init：创建完Servlet容器后，会调用仅执行一次的 init() 初始化方法，用于初始化Servlet对象，无论多少台客户端在服务器运行期间访问都不会再执行 init() 方法。</li><li>执行处理 service：HttpServlet 的抽象类提供了doGet()、doPost() 等方法，对应了request请求的发送方法。</li><li>销毁 destroy：在服务器关闭或重启时，Servlet会调用 destroy 方法来销毁，将Servlet容器标记为垃圾文件，让 GC 回收。</li></ol><h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><h2 id="如何实现事务开启、提交、回滚"><a href="#如何实现事务开启、提交、回滚" class="headerlink" title="如何实现事务开启、提交、回滚"></a>如何实现事务开启、提交、回滚</h2><p>一般情况下，Mysql都会设置autocommit=1，即开启事务自动提交。这种情况下，我们单独执行一个sql就会把它包裹在一个事务中，所以我们需要显示的开启一个事务，然后显示提交或回滚事务。</p><ul><li><p>编程式实现事务</p><p>我们通过 transactionManager.getTransaction 方法开启一个事务，并在其中用 try…catch 包裹我们的业务代码，如果所有业务代码顺利执行，那么就执行 transactionManager.commit 提交事务，否则如果业务代码抛出异常，就在 catch 块中执行 transactionManager.rollback 回滚事务。</p></li><li><p>声明式事务管理</p><p>@Transactional 底层就是通过 AOP，将被注解的业务方法，用上述编程式事务实现一遍。@Transactional 注解的使用范围：</p><ul><li>方法<ul><li>推荐</li><li>只能应用到 public 方法上，否则不生效。原因是 AOP 底层有 JDK 和 CGlib 两种实现方式，其中 JDK 基于接口实现，所以都是 public 方法，CGlib 基于继承实现，可以是 public、protected、package 方法。综合起来，@Transactional 只支持 public 方法</li></ul></li><li>类<ul><li>对该类中所有的 public 方法都生效</li></ul></li><li>接口<ul><li>不推荐</li></ul></li></ul></li></ul><h2 id="如何管理事务"><a href="#如何管理事务" class="headerlink" title="如何管理事务"></a>如何管理事务</h2><h2 id="Transactional-属性"><a href="#Transactional-属性" class="headerlink" title="@Transactional 属性"></a>@Transactional 属性</h2><ul><li><p>传播行为</p><p>需要主要，这些传播行为都是依赖异常检测的，所以分析实际问题时，需要考虑上异常的检查情况。</p><ul><li>以事务方式执行<ul><li>REQUIRED<ul><li>如果当前存在事务，就加入这个事务。</li><li>如果当前不存在事务，就新开启事务。</li></ul></li><li>REQUIRES_NEW<ul><li>如果当前存在事务，就把当前事务挂起。</li><li>如果当前不存在事务，就新开启事务。</li></ul></li><li>NESTED<ul><li>如果当前存在事务事务，就开启嵌套事务，即父子事务<ul><li>父事务提交，子事务才能提交，子事务不能单独提交</li><li>父事务回滚，子事务也要回滚，子事务可以单独回滚</li></ul></li><li>如果当前不存在事务，就新开启事务。</li></ul></li><li>MANDATORY<ul><li>如果当前存在事务，就加入这个事务。</li><li>如果当前不存在事务，就抛出异常。</li></ul></li></ul></li><li>以非事务方式执行<ul><li>SUPPORTS</li><li>NOT_SUPPORTED</li><li>NEVER</li></ul></li></ul></li><li><p>隔离级别</p><ul><li>DEFAULT<ul><li>使用底层数据库的默认隔离级别<ul><li>Mysql 默认可重复读</li><li>Oracle 默认提交读</li></ul></li></ul></li><li>未提交读</li><li>提交读</li><li>可重复读</li><li>可串行化</li></ul></li><li><p>超时时间</p><ul><li>默认值为-1（不会超时）</li><li>如果超过该时间限制但事务还没有完成，则自动回滚事务。</li></ul></li><li><p>是否为只读事务</p><ul><li>默认值为 false。</li><li>提供一些优化，例如 sql 合并，多条相关的 sql 只发出一条</li><li>比如在多条读sql情况下，要求他们看到的数据一致，则需要开启事务</li></ul></li><li><p>能够触发事务回滚的异常类型</p><ul><li>默认情况只有 Error 和 RuntimeException 会触发回滚</li></ul></li></ul><h2 id="Spring-事务失效场景"><a href="#Spring-事务失效场景" class="headerlink" title="Spring 事务失效场景"></a>Spring 事务失效场景</h2><ul><li>底层数据库不支持事务</li><li>事务所在类未被 Spring 容器管理</li><li>AOP 自调用问题</li><li>没有加在 public 方法上</li><li>没有正确设置传播行为和回滚异常类型属性</li></ul><h1 id="Spring-boot"><a href="#Spring-boot" class="headerlink" title="Spring boot"></a>Spring boot</h1><h2 id="Spring-boot-特点"><a href="#Spring-boot-特点" class="headerlink" title="Spring boot 特点"></a>Spring boot 特点</h2><ul><li>自动装配</li><li>嵌入式 Tomcat Web 服务器，不需要手动配置服务器</li><li>已经打包好的 starter</li></ul><h2 id="Spring-自动装配原理（-SpringBootApplication-原理）"><a href="#Spring-自动装配原理（-SpringBootApplication-原理）" class="headerlink" title="Spring 自动装配原理（@SpringBootApplication 原理）"></a>Spring 自动装配原理（@SpringBootApplication 原理）</h2><p>避免了繁琐的 xml 配置、Java 配置，大大简化了配置工作。</p><ul><li>@EnableAutoConfiguration<ul><li>开启自动装配</li><li>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中的配置信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。我们引入的各类 xxx-starter 包，就是实现了这套规范的 jar 包。</li></ul></li><li>@Configuration<ul><li>允许在上下文中注册额外的 bean 或导入其他配置类</li><li>如果我们加载所有引入包的，那系统未免太臃肿了。所以可以设置 @ConditionalOnXXX 注解，在指定条件满足时才会加载本配置类的内容。</li></ul></li><li>@ComponentScan<ul><li>扫描并加载指定路径下（默认扫描启动类所在包下的所有类），被 @Component、@Controller、@Service、@Repository 注解的类</li><li>可以自定义排除某些类</li></ul></li></ul><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/design-pattern/Singleton.png"></p><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>懒汉式 - 线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉式 - 线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加锁范围过大，影响直接获取，性能问题，不推荐使用</p></li><li><p>懒汉式 - 双重锁校验 - 线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 new Singleton() 会涉及指令重排，导致可能会有线程获取未初始化完成的对象，所以需要加 volatile 关键字，避免指令重排。</p><p>实现复杂，不推荐使用。</p></li><li><p>饿汉式 - 线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>丢失了延迟实例化带来的好处</p></li><li><p>静态内部类实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 Singleton 类被加载时，静态内部类不会被加载进内存。只有当调用静态内部类的方法，从而触发静态内部类被加载，此时才会初始化单例对象，并且 JVM 能确保只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p></li><li><p>枚举实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>  上述方法中只有枚举实现可以防止反射攻击，并且是线程安全的。枚举实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p></li></ul><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java并发</title>
    <link href="/2023/08/09/java%E5%B9%B6%E5%8F%91/"/>
    <url>/2023/08/09/java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm.png"></p><p>Java内存模型规定了所有变量（实例字段，静态字段和构成数组中的元素，不包括线程私有的局部变量和方法参数）都存储在主内存。每条线程都有自己的工作内存，用来保存被该线程使用的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间无法之间访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><h2 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/operate.png"></p><ul><li>lock（锁定)：锁定主内存变量，表示为线程独占状态</li><li>unlock（解锁)：释放主内存变量</li><li>read（读取)：把一个变量的值从主内存传输到线程的工作内存中</li><li>load（载入)：把 read 操作从主内存中得到的变量值放到工作内存中的变量副本中</li><li>use（使用)：执行引擎读取工作内存中的一个变量副本</li><li>assign（赋值)：执行引擎更新工作内存中的一个变量副本</li><li>store（赋值)：把一个变量副本从线程的工作内存传输到主内存中</li><li>write（赋值)：把 store 操作从工作内存中得到的变量值放到主内存中</li></ul><h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><ol><li>原子性<ul><li>内存交互操作具有原子性。对一个 int 类型的变量执行 assign 赋值操作，具备原子性。但对 64 位数据类型（long，double）的操作会划分为两次 32 位的操作来进行，不具备原子性</li><li> synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit</li></ul></li><li>可见性：可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的<ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存</li><li>final</li></ul></li><li>有序性：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序<ul><li>volatile</li><li>synchronized 保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码</li></ul></li></ol><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><ol><li><p>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Single-Thread-rule.png"></p></li><li><p> 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</p></li></ol><p>   <img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Monitor-Lock-Rule.png"></p><ol start="3"><li><p>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Volatile-Variable-Rule.png"></p></li><li><p>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Thread-Start-Rule.png"></p></li><li><p>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/Thread-Join-Rule.png"></p></li><li><p>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始</p></li><li><p>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</p></li></ol><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障，是一类同步屏障指令，是CPU或编译器在对内存随机访问的一个同步点，使得此点之前的所有读写操作操作都执行后才可以开始执行此点之后的操作。</p><ul><li>LoadLoad：保证 Load1 的读取操作在 Load2 及其之后的读取操作之前执行</li><li>LoadStore：在 Store2 及其后的写入操作执行之前，保证 Load1 的读取操作已读取结束</li><li>StoreStore：在 Store2 及其后的写入操作执行之前，保证 Store1 的写入操作已刷新到主内存</li><li>StoreLoad：在 Load2 及其后的读取操作执行之前 ，保证Store1 的写入操作已刷新回主内存</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>可见性：volatile保证被修饰的变量的可见性，但不保证是线程安全的，因为操作变量的运算不一定是线程安全的<ul><li>每次使用V前都必须先从主内存刷新最新值，使用LoadLoad、LoadStore实现</li><li>每次修改V后都必须立即同步回主内存，使用StoreLoad、StoreStore实现</li></ul></li><li>禁止指令重排：保证代码执行顺序和程序书写顺序一致</li></ul><h2 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h2><p>线程安全指的是多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><ol><li><p>不可变</p><ul><li><p>类型</p><ul><li><p>final 关键字修饰的基本数据类型</p></li><li><p>String</p></li><li><p>枚举类型</p></li><li><p>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</p></li><li><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p></li></ul></li></ul></li><li><p>阻塞同步（互斥同步）：</p><ul><li>属于悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作</li><li>主要问题是线程阻塞和唤醒所带来的性能问题</li><li>类型<ul><li>synchronized<ul><li>性能和ReentrantLock差不多</li><li>JVM实现</li><li>等待不可中断</li><li>不公平</li><li>不支持同时绑定多个条件</li></ul></li><li>ReentrantLock：同一个线程可以反复进入锁，在释放锁时，也必须释放相同的次数<ul><li>JDK实现</li><li>等待可中断</li><li>默认不公平，也可以公平</li><li>可以同时绑定多个条件</li></ul></li></ul></li></ul></li><li><p>非阻塞同步</p><ul><li>属于基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）</li><li>不需要阻塞线程</li><li>类型<ul><li>CAS：只有当 V 的值等于 A，才将 V 的值更新为 B<ul><li>原子类AtomicInteger：调用了 Unsafe 类的 CAS 操作</li><li>ABA问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。通过增加变量版本来解决。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比带有时间戳（版本）的原子类更高效</li></ul></li></ul></li></ul></li><li><p>无同步方案</p><ul><li><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</p></li><li><p>类型</p><ul><li><p>栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私</p></li><li><p>线程本地存储（Thread Local Storage）</p><ul><li><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。经典 Web 交互模型中的“一个请求对应一个服务器线程”处理方式，使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题</p></li><li><p>java.lang.ThreadLocal：每个线程都维护一个ThreadLocal.ThreadLocalMap对象。当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal -&gt; value 键值对插入到该 Map 中。ThreadLocal 有内存泄漏风险，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jmm/thread-local.png"></p></li></ul></li><li><p>可重入代码（纯代码）：可以在执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p></li></ul></li></ul></li></ol><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><ol><li>自旋锁<ul><li>进入阻塞状态的开销很大。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</li><li>自适应自旋，意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定</li></ul></li><li>锁消除<ul><li>消除不可能存在竞争的共享数据的锁。通过逃逸分析实现，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</li></ul></li><li>锁粗化<ul><li>如果一系列的连续操作都对同一个对象反复加锁和解锁，就会导致性能损耗，可以把加锁的范围扩展到整个操作序列的外部。</li></ul></li><li>轻量级锁<ul><li>锁的四个状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</li><li>虚拟机对象头数据称为 Mark Word，其中记录了该对象作为加锁对象的锁状态。</li><li>加锁：当前线程尝试获取一个锁对象时，如果锁对象是未锁定状态，那么当前线程就会在他的虚拟机栈桢中创建 Lock Record ，用于存放锁对象的 Mark Word 副本。然后，虚拟机会尝试使用 CAS 操作将锁对象的 Mark Word 更新为指向当前线程 Lock Record 的指针。如果 CAS 操作成功了，那么就代表当前线程获取了该对象上的锁，并且该对象处于轻量级锁状态。如果 CAS 操作失败了，虚拟机首先会检查该对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行。否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要尝试加重量级锁，锁对象状态变为重量级锁状态。</li><li>解锁：如果锁对象的 Mark Word 仍然指向线程的 Lock Record，那就尝试用CAS操作将线程的 Lock Record上的 Mark Word 副本拷贝回来。如果CAS成功，那么解锁成功。如果CAS失败，说明有其他线程尝试过获取该锁，那么就要在解锁的同时，唤醒被挂起的线程</li></ul></li><li>偏向锁<ul><li>偏向锁的思想是偏向于让第一个获取锁对象的线程，再次获取该锁时就不再需要进行CAS 操作、同步操作。</li><li>当锁对象第一次被某个线程获取时，进入偏向状态。同时使用 CAS 操作将线程 ID 记录到锁对象的 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何CAS、同步操作。当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向状态，膨胀到到未锁定状态或者轻量级锁状态。</li></ul></li></ol><h2 id="开发时加锁建议"><a href="#开发时加锁建议" class="headerlink" title="开发时加锁建议"></a>开发时加锁建议</h2><p>原理：降低各种意义的锁范围，包括时间、空间、类型，以降低锁冲突概率，提高系统并发能力</p><ol><li>减小锁持有时间</li><li>减小锁粒度</li><li>使用读写分离锁：适用于读多写少的场景，因为写会复制数据</li><li>锁粗化：减少频繁加锁的开销</li></ol><h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="实现线程"><a href="#实现线程" class="headerlink" title="实现线程"></a>实现线程</h2><ul><li><p>实现 Runnable 接口</p><ul><li>run() 没有返回值</li></ul></li><li><p>实现 Callable 接口</p><ul><li>call() 有返回值</li></ul></li><li><p>继承 Thread 类</p><ul><li>缺点<ul><li>run() 方法内部就是调用 Runnable 接口，所以更推荐实现 Runnable 接口，更加合理</li><li>实际只需要指定线程任务，继承整个类开销过大</li><li>Java 只支持单继承</li></ul></li></ul></li></ul><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><ul><li><p>一般线程执行完任务后就会结束</p></li><li><p>stop()</p><ul><li>Thread 方法</li><li>立即结束线程，并释放所持有的锁</li><li>不推荐使用</li></ul></li><li><p>interrupt()  设置中断标志</p><ul><li>Thread 方法</li><li>任务内部通过 interrupted() 判断中断标记，以便合理退出</li></ul></li><li><p>shoutdown()</p><ul><li>ExecutorService 方法</li><li>会等待任务都执行完毕之后再关闭，不会接受新任务</li></ul></li><li><p>shoutdownNow()</p><ul><li>ExecutorService 方法</li><li>尝试停止所有正在执行的任务，停止等待任务的处理，不会接受新任务</li></ul></li></ul><h2 id="基础机制"><a href="#基础机制" class="headerlink" title="基础机制"></a>基础机制</h2><ul><li>sleep()<ul><li>让线程休眠若干时间，如果休眠中被中断，会抛 InterruptedException 异常</li><li>睡眠时不会释放所持有的锁</li></ul></li><li>yield()<ul><li>会使当前线程让出 CPU，但让出后还会进行 CPU 竞争</li><li>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</li></ul></li><li>守护线程 Daemon<ul><li>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</li></ul></li></ul><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><ul><li>join()<ul><li>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</li><li>本质是让当前线程 wait() 目前线程</li></ul></li><li>wait() notify() notifyAll()<ul><li>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</li><li>它们都属于 Object 的一部分，而不属于 Thread。</li><li>只能用在 synchronized 方法或者 synchronized 块中使用，否则会在运行时抛出 IllegalMonitorStateException</li><li>等待时会释放所持有的锁</li></ul></li><li>await() signal() signalAll()<ul><li>JUC 中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</li><li>使用时，要求线程持有可重入锁</li><li>等待时会释放所持有的锁</li></ul></li></ul><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="可重入锁-ReetrantLock"><a href="#可重入锁-ReetrantLock" class="headerlink" title="可重入锁 ReetrantLock"></a>可重入锁 ReetrantLock</h2><p>见上</p><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>广义上说，信号量是对锁的拓展。无论是 synchronized 还是 ReetrantLock，都只允许同时一个线程访问资源，而信号量允许同时多个线程访问资源。</p><ul><li>获取资源 acquire()</li><li>释放资源 release()</li></ul><h2 id="读写分离锁-ReadWriteLock"><a href="#读写分离锁-ReadWriteLock" class="headerlink" title="读写分离锁 ReadWriteLock"></a>读写分离锁 ReadWriteLock</h2><p>略</p><h2 id="倒计时器-CountDownLatch"><a href="#倒计时器-CountDownLatch" class="headerlink" title="倒计时器 CountDownLatch"></a>倒计时器 CountDownLatch</h2><p>用来控制一个或者多个线程等待多个线程。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><h2 id="循环栅栏-CyclicBarrier"><a href="#循环栅栏-CyclicBarrier" class="headerlink" title="循环栅栏 CyclicBarrier"></a>循环栅栏 CyclicBarrier</h2><p>和 CountdownLatch 相似。区别是 CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><h1 id="并行模式"><a href="#并行模式" class="headerlink" title="并行模式"></a>并行模式</h1><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>当我们调用一个方法时，如果这个方法执行很慢，那我们就需要等待。但有时候，我们并不着急获取结果。此时，这个很慢的方法可以先返回一个伪结果，调用方拿到伪结果后先处理其他任务，在真正需要伪结果的数据时再去尝试获取。这样就充分利用了等待慢方法的时间，提高了系统的响应速度。</p><p>java 中的 Future 接口就定义了这个伪结果，通过 get() 可以获取真实数据。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&lt;V&gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><p>可以实现 Callable 接口，获取真实数据，设置进 FutureTask 内。将 FutureTask 通过 ExecutorService.submit() 方法提交给线程池执行。在需要真实数据的时候通过 get() 方法获取真实数据。</p><p>需要注意， FutureTask 实现的是 Runnable，即没有返回值，返回值是通过 get() 方法获取的，注意与 Callable 区分</p><h2 id="CompleteFuture"><a href="#CompleteFuture" class="headerlink" title="CompleteFuture"></a>CompleteFuture</h2><ul><li>实现了 Future 接口</li><li>高效的线程回调机制</li><li>线程编排</li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>线程复用：降低资源消耗、提高获取线程的速度</li><li>控制线程数量</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/juc/executor.png"></p><ul><li>Executor<ul><li>execute() 方法接收一个实现 Runnable 接口的对象，没有返回值</li></ul></li><li>ExecutorService<ul><li>submit() 方法接受一个实现 Callable 接口的对象，返回 Future 对象</li><li>添加了管理任务的生命周期方法</li></ul></li><li>ScheduleExecutorService<ul><li>schedule() 方法接受一个实现 Runnable 接口的对象，并设置延时时间或定期间隔，返回 SchduleFuture 对象</li><li>支持延时、定期执行任务</li></ul></li><li>Executors<ul><li>创建各类线程池的工厂类</li></ul></li></ul><h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><ul><li>Fixed<ul><li>固定数量：核心线程数 = 最大线程数 = n</li><li>无界队列：LinkedBlockingQueue</li></ul></li><li>Single<ul><li>固定数量1：核心线程数 = 最大线程数 = 1</li><li>无界队列：LinkedBlockingQueue</li></ul></li><li>Cached<ul><li>根据实际需要创建新线程：核心线程数 = 0，最大线程数 = Integer.MAX_VALUE</li><li>直接提交队列</li></ul></li><li>Scheduled<ul><li>固定数量：核心线程数 = n，最大线程数 = Integer.MAX_VALUE</li><li>支持延时、定期任务</li></ul></li><li>SingleScheduled<ul><li>固定数量1：核心线程数 = 1，最大线程数 = Integer.MAX_VALUE</li><li>支持延时、定期任务</li></ul></li></ul><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><ul><li>核心线程数</li><li>最大线程数</li><li>超过核心线程数的多余线程的存活时间</li><li>存活时间单位</li><li>任务队列<ul><li>直接提交队列 SynchronousQueue：没有容量，直接提交给线程处理。如果没有空闲线程，则尝试创建新线程执行任务。如果线程数达到最大线程数，则执行拒绝策略。</li><li>有界队列 ArrayBlockingQueue<ul><li>如果当前线程数小于核心线程数，则创建新线程执行任务</li><li>如果当前线程数大于核心线程数，则任务加入队列</li><li>如果任务队列已满，并且当前线程数小于最大线程数，则创建新线程执行任务</li><li>如果任务队列已满，并且当前线程数大于最大线程数，则执行拒绝策略</li></ul></li><li>无界队列 LinkedBlockingQueue<ul><li>如果当前线程数小于核心线程数，则创建新线程执行任务</li><li>如果当前线程数大于核心线程数，则任务加入队列</li><li>任务队列不会满，直到耗尽系统内存</li></ul></li><li>优先任务队列 PriorityBlockingQueue<ul><li>特殊的无界队列</li><li>无论是游街队列还是无界队列，都按先进先出规则处理任务，优先任务队列可以设置优先级</li></ul></li></ul></li><li>线程工厂</li><li>拒绝策略<ul><li>直接抛异常</li><li>在调用者线程中运行当前被丢弃的任务</li><li>丢弃最老的任务，并尝试再次提交当前任务</li><li>直接丢弃</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java面试题</title>
    <link href="/2023/08/01/java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/08/01/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="java-容器"><a href="#java-容器" class="headerlink" title="java 容器"></a>java 容器</h2><ul><li>Collection<ul><li>List<ul><li>ArrayList<ul><li>动态数组实现</li><li>优点：读速度快，随机搜索</li><li>缺点：写速度慢，涉及移动大量数组元素</li></ul></li><li>Vector<ul><li>synchronized实现的ArrayList的线程安全版本</li></ul></li><li>CopyOnWriteArrayList<ul><li>synchronized实现的线程安全列表</li><li>为了增加并发度，读写分离，写数据时会copy一份新数组，在新数组上修改，修改完后用新数组代替原数组。读数据总在原数组执行</li></ul></li><li>LinkedList<ul><li>双向链表实现，但实际使用中与ArrayList性能区别不大</li><li>优点：写速度快，O(1)</li><li> 缺点：读速度慢，只能顺序搜索</li></ul></li></ul></li><li>Queue<ul><li>LinkedList</li><li>PriorityQueue：堆</li><li>BlockingQueue：阻塞队列，用于线程池。当线程处理完队列中的任务时，会进行等待，当有新任务加入队列时，队列会将线程唤醒</li></ul></li><li>Set<ul><li>TreeSet：TreeMap</li><li>HashSet：HashMap</li><li>LinkedHashSet：LinkedHashMap</li></ul></li></ul></li><li>Map<ul><li>TreeMap：红黑树，有序</li><li>HashMap<ul><li>插入：hash()取模获得桶下标，利用拉链法解决hash冲突</li><li>查询：hash()取模获得桶下标，遍历下标对应的链表或红黑树，利用equals()找到目标元素</li><li>链表长度为8转红黑树，红黑树长度为6时转链表<ul><li>目的是优化查询速率，但又避免维护复杂数据结构</li><li>6与8是为了避免在临界值频繁转换数据结构</li></ul></li><li>桶大小为 2^n<ul><li>方便二进制取模 x &amp; (size-1)</li><li>方便扩容时快速计算新下标，例如现桶大小为2^5，扩容为2^6，那么判断元素第5位为1，新下标就是现下标*2，为0就等于现下标</li></ul></li><li>版本改进<ul><li>JDK 1.7<ul><li>链表</li><li>头插法：并发环境会造成环</li></ul></li><li>JDK 1.8<ul><li>链表 + 红黑树</li><li>尾插法：但是并发环境依然建议使用 ConcurrentHashMap</li></ul></li></ul></li></ul></li><li>LinkedHashMap<ul><li>利用双向链表维护了元素顺序<ul><li>FIFO</li><li>LRU</li></ul></li></ul></li><li>HashTable<ul><li>synchronized实现的HashMap的线程安全版本</li><li>对整个集合上锁</li></ul></li><li>ConcurrentHashMap<ul><li>1.8前<ul><li>先分组segment，每组有独立的桶</li><li>每个segment都是ReetrantLock的实现，对整个桶上锁</li></ul></li><li>1.8后<ul><li>类似于HashMap，但是添加元素时，若下标为null，则利用CAS加锁，若下标后面有链表或红黑树，则利用synchronized对头节点加锁</li><li>实际上也是分了组</li></ul></li></ul></li><li>WeakHashMap<ul><li>弱引用实现的HashMap，里面的元素可能在下次gc时被回收</li><li>应用：tomcat的ConcurrentCache缓存<ul><li>分代存储<ul><li>新生代数据利用WeakHashMap维护，可能会被回收</li><li>老年代数据利用ConcurrentHashMap维护，不会被回收</li><li>新加入的数据放进新生代，被读取后放入老年代</li><li>老年代空间不足都会被放回新生代，然后会回收</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="fail-fast-与-fail-safe"><a href="#fail-fast-与-fail-safe" class="headerlink" title="fail-fast 与 fail-safe"></a>fail-fast 与 fail-safe</h2><ul><li>fail-fast：遍历集合时，若同时修改集合，则会立即抛异常</li><li>fail-safe：修改集合会复制一份数据进行修改，不会影响查询</li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><p>I/O操作步骤：</p><ol><li>将数据从I/O设备读取到内核缓冲区</li><li>将数据从内核缓冲区拷贝到用户态应用程序缓冲区</li><li>应用程序从用户态应用程序缓冲区中直接使用数据</li></ol><h2 id="普通-BIO"><a href="#普通-BIO" class="headerlink" title="普通 BIO"></a>普通 BIO</h2><ul><li>第一步、第二步阻塞</li><li>面向流</li><li>优点<ul><li>程序简单</li></ul></li><li>缺点<ul><li>吞吐量低</li></ul></li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><ul><li>第一步非阻塞，第二步阻塞</li><li>面向块</li><li> I/O 多路复用</li><li>优点<ul><li>第一步非阻塞，吞吐量高较好</li><li> I/O 多路复用可以同时处理多个I/O设备请求</li><li> 使用到零拷贝</li></ul></li><li>缺点<ul><li>面向块编程，程序复杂 </li><li>I/O 多路复用轮询消耗CPU资源</li><li>第二步依然阻塞</li></ul></li></ul><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><ul><li><p>第一步、第二步非阻塞</p></li><li><p>优点</p><ul><li>吞吐量高</li></ul></li><li><p>缺点</p><ul><li>程序复杂 </li><li>1.7后才开始支持，底层操作系统支持也不普及</li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="为什么byte、short、boolean、char都使用int来存储"><a href="#为什么byte、short、boolean、char都使用int来存储" class="headerlink" title="为什么byte、short、boolean、char都使用int来存储"></a>为什么byte、short、boolean、char都使用int来存储</h2><p>由于java虚拟机的操作码只有一字节长，所以如果每种与数据类型相关的指令都需要支持所有运行时数据类型的话，会远远超出一字节所能表示的数量范围。因此，编译器会在编译期或运行期将byte、short、boolean、char类型数据都拓展为int类型数据存储，从而直接使用int类型的字节码指令。</p><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><ul><li>C#实现的泛型基于类型膨胀，是真实泛型：List&lt;Integer&gt;和List&lt;String&gt;就是两个类型，在系统运行期间，有自己的虚方法表和类型数据</li><li>Java实现的泛型基于类型擦除，是伪泛型：List&lt;Integer&gt;和List&lt;String&gt;都是List&lt;Object&gt;类型，在系统运行期间，在相应的使用位置加上强制转型</li></ul><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>转化为对应的包装与还原方法</p><h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><p>还原为迭代器实现</p><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>数据类型参数</p><h2 id="java-排序算法"><a href="#java-排序算法" class="headerlink" title="java 排序算法"></a>java 排序算法</h2><p>优化方向：</p><ul><li>稳定性考虑<ul><li>基本类型不考虑稳定性，使用快速排序</li><li>引用类型因为不清楚具体业务场景，考虑稳定性，使用归并排序</li></ul></li><li>利用 O(logN) 和 O(n^2) 各自的优势<ul><li>O(logN) 适合大数据量</li><li>O(n^2) 适合大数据量</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM面试题</title>
    <link href="/2023/07/30/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/07/30/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><h2 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h2><p>当前线程所执行字节码的行号指示器</p><h2 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h2><p>为Java方法服务。每个方法在执行时都会往栈中push一条栈桢：局部变量表、操作数栈、动态链接、方法出口等。若线程请求深度大于虚拟机所允许的深度，会产生StackOverslowError。</p><h2 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h2><p>和虚拟机栈类似，为Native方法服务。</p><h2 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h2><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。若方法区无法满足内存分配要求，则会抛出OutOfMemoryError。</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区的一部分。编译器生成的字面量和符号引用会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h2 id="堆（线程共享）"><a href="#堆（线程共享）" class="headerlink" title="堆（线程共享）"></a>堆（线程共享）</h2><p>用于存放对象实例。若堆无法满足内存分配要求，并且无法拓展堆大小，则会抛出OutOfMemoryError。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><ol><li>引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</li><li>可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。GC Roots 一般包含以下内容<ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul></li></ol><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型：</p><ul><li>强引用<ul><li>被强引用关联的对象不会被回收</li><li>使用 new 一个新对象的方式来创建强引用</li></ul></li><li>软引用<ul><li>被软引用关联的对象只有在内存不够的情况下才会被回收</li><li>使用 SoftReference 类来创建软引用</li></ul></li><li>弱引用<ul><li>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</li><li>使用 WeakReference 类来创建弱引用</li></ul></li><li>虚引用<ul><li>又一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</li><li>使用 PhantomReference 来创建虚引用。</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li><p>标记 - 清除</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/mark-clean.png"></p><ul><li>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</li><li>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</li><li>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表</li><li>缺点：<ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul></li></ul></li><li><p>标记 - 整理</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/mark-compact.png"></p><ul><li>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</li><li>在整理阶段，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li><li>优点：<ul><li>不会产生内存碎片</li></ul></li><li>缺点：<ul><li>需要移动大量对象，处理效率比较低。</li></ul></li></ul></li><li><p>复制</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/repeat.png"></p><ul><li>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</li><li>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。</li><li>缺点：<ul><li>内存利用率只有一半</li></ul></li></ul></li><li><p>分代收集</p><ul><li>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。<ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul></li></ul></li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/garbage-collector.jpg"></p><ol><li><p>Serial 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/Serial.jpg"></p><ul><li>串行，即垃圾收集器与用户程序交替执行</li><li>单线程</li><li>优点<ul><li>简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率</li></ul></li></ul></li><li><p>ParNew 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/ParNew.jpg"></p><ul><li>Serial 收集器的多线程版本<ul><li>串行，即垃圾收集器与用户程序交替执行</li><li>多线程</li></ul></li></ul></li><li><p>Parallel Scavenge 收集器</p><ul><li>与 ParNew 一样是多线程收集器</li><li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</li><li>GC 自适应的调节策略：拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</li></ul></li><li><p>Serial Old 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/Serial-Old.jpg"></p><ul><li>是 Serial 收集器的老年代版本</li><li>标记 - 整理算法</li><li>串行，即垃圾收集器与用户程序交替执行</li><li>单线程</li></ul></li><li><p>Parallel Old 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/Parallel-Old.jpg"></p><ul><li>是 Parallel Scavenge 收集器的老年代版本</li><li>标记 - 整理算法</li><li>串行，即垃圾收集器与用户程序交替执行</li><li>多线程</li></ul></li><li><p>CMS 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/CMS.jpg"></p><ul><li>标记 - 清除算法</li><li>流程：<ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul></li><li>缺点：<ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul></li></ul></li><li><p>G1 收集器</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/G1.jpg"></p><ul><li><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个年轻代或者老年代，而 G1 通过年轻代收集集合和混合收集集合，可以单独收集年轻代，或者对年轻代和老年代一起回收。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/generations.png"></p><p>G1 把堆划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离，他们都是一部分Region的集合。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/G1-heap-allocation.png"></p><p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个 Region 都记录了一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。需要注意，对年轻代进行整体收集，因此引用源自年轻代的对象，不需要在RSet中记录。只有老年代的分区可能会有RSet记录。</p></li><li><p>流程：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul></li><li><p>优点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul></li></ul></li></ol><h2 id="CMS与G1的并发标记算法-三色标记法"><a href="#CMS与G1的并发标记算法-三色标记法" class="headerlink" title="CMS与G1的并发标记算法 - 三色标记法"></a>CMS与G1的并发标记算法 - 三色标记法</h2><p>CMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。</p><ul><li>白色是未标记</li><li>灰色自身被标记，所有引用的对象没有完全被标记</li><li>黑色自身与所有引用对象都已标记</li></ul><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/g1-three-color.png"></p><ol><li>GC 开始前所有对象都是白色。</li><li>初始标记时，所有GC Roots直达的对象被压到栈中，待搜索，此时颜色是灰色。</li><li>然后依次从栈中取出灰色对象，搜索其子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。</li><li>当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</li></ol><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/three-color.gif"></p><p>漏标问题。在重新标记/最终标记的过程中，若删除了灰色到白色的引用，而是改为黑色指向白色，此时如果不对黑色重新扫描，则会漏标，会把白色回收掉。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/three-color-spill-tag-1.png"></p><p>产生漏标问题的条件有两个：</p><ul><li>黑色对象指向了白色对象</li><li>灰色对象指向白色对象的引用消失</li></ul><p>所以要解决漏标问题，打破两个条件之一即可：</p><ul><li>跟踪黑指向白的增加 incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描该对象。CMS采用该方法。</li><li>记录灰指向白的消失 SATB snapshot at the beginning：关注引用的删除，当灰–&gt;白消失时，要把这个白色推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。</li></ul><p>为什么G1采用SATB而不用incremental update？</p><p>因为采用incremental update把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。G1有RSet与SATB相配合。RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。</p><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><p>对象优先在 Eden 分配</p><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p>大对象是指需要连续内存空间的对象，直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制</p></li><li><p>长期存活的对象进入老年代</p><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，并且能被 Survivor 容纳，年龄就增加 1 岁，增加到一定年龄（默认15）则移动到老年代中。</p></li><li><p>动态对象年龄判定</p><p>虚拟机并不是永远要求对象的年龄必须达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保</p><p>把Survivor无法容纳的对象直接转移到老年代。</p><p>在 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者不允许冒险，那么就要进行一次 Full GC。</p></li></ol><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><ol><li><p>调用 System.gc()</p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足</p><p>常见原因：</p><ol><li>老大对象直接进入老年代：尽量不要创建过大的对象以及数组</li><li>长期存活的对象进入老年代：通过调节虚拟机参数，让对象在新生代多存活一段时间</li></ol></li><li><p>空间分配担保失败</p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p></li><li><p> JDK 1.7 及以前的永久代空间不足</p></li></ol><p>   在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 OutOfMemoryError。解决方法是增大永久代空间或转为使用 CMS GC。</p><ol start="5"><li><p>Concurrent Mode Failure</p><p>并发清除阶段产生的浮动垃圾触发 Full GC。</p></li></ol><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="new对象都做了什么"><a href="#new对象都做了什么" class="headerlink" title="new对象都做了什么"></a>new对象都做了什么</h2><ol><li>检查<ol><li>是否有常量</li><li>类是否加载过</li></ol></li><li>分配内存</li><li>初始化为零值</li><li>对象头设置</li><li>初始化代码中设置的值</li></ol><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/class-life.png"></p><ol><li><p>加载</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</li><li>在内存中生成一个代表该类的 Class 对象，存储在方法区，作为方法区中该类各种数据的访问入口。</li></ul></li><li><p>验证</p><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p></li><li><p>准备</p><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。初始值一般为 0 值。如果类变量是常量，那么它将初始化为字面量。</p><p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p></li><li><p> 解析</p></li></ol><p>   将常量池的符号引用替换为直接引用</p><ol start="5"><li><p>初始化</p><p>初始化阶段是虚拟机执行类构造器方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p><p>一些需要注意的：</p><ul><li>类构造器是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。</li><li>由于父类的类构造器方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类</li><li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成类构造器方法。但接口与类不同的是，执行接口的类构造器方法不需要先执行父接口的类构造器方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的类构造器方法。</li><li>虚拟机会保证一个类的类构造器方法在多线程环境下被正确的加锁和同步。</li></ul></li></ol><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><ol><li><p>主动引用</p><ul><li>使用 new 关键字实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，会先初始化主类</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ul></li><li><p>被动引用</p><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li><li>常量在编译阶段会存入<strong>调用类</strong>的常量池中，本质上并没有直接引用到<strong>定义常量的类</strong>，因此不会触发定义常量的类的初始化</li></ul></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li>启动类加载器，使用 C++ 实现，是虚拟机自身的一部分；</li><li>所有其它的类加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li><li>自定义类加载器</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/jvm/parent-delegation-model.png"></p><p>类加载器之间的层次关系，称为双亲委派模型。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系来实现，而不是继承关系。</p><p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><p>好处：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="静态多态：重载方法匹配优先级"><a href="#静态多态：重载方法匹配优先级" class="headerlink" title="静态多态：重载方法匹配优先级"></a>静态多态：重载方法匹配优先级</h2><p>静态分派：看静态类型能查找并匹配到的方法版本</p><ol><li><p>自动转型</p><p>byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double</p></li><li><p>接口</p><p> 匹配到多个接口，其优先级一样，编译器会报错</p></li><li><p>父类</p><p>按照继承关系从下到上</p></li><li><p>可变长参数</p></li></ol><h2 id="动态多态：重写方法匹配过程"><a href="#动态多态：重写方法匹配过程" class="headerlink" title="动态多态：重写方法匹配过程"></a>动态多态：重写方法匹配过程</h2><p>动态分派：看动态类型能查找并匹配到的方法版本。</p><p>其底层实现是在类方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口就和父类相同方法的地址入口一致，都指向父类的方法实现入口。如果子类重写了这个方法，那子类的虚方法表里面的地址入口就指向子类实现版本的方法入口。确定动态类型后，查找虚方法表，返回方法的直接引用。</p><p>先考虑方法重写，再考虑方法重载。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql面试题</title>
    <link href="/2023/07/24/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/07/24/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/architecture.png"></p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/process.png"></p><h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><ol><li><p>客户端</p><ol><li>数据库连接池：维护一定的连接数，方便系统获取连接，节省了不断创建与销毁连接的开销</li></ol></li><li><p>连接器</p><ol><li>建立连接、维持和管理连接<ol><li>连接类型：<ol><li>长连接：节省创建连接的消耗，但是服务器资源会被长时间占用，有可能导致OOM<ol><li>定期断开长连接</li><li>重新初始化连接资源</li></ol></li><li>短连接：频繁创建连接的消耗巨大</li></ol></li><li>I/O多路复模型</li><li>使用线程池为每个客户端连接分配一个线程，客户端的任何请求都由该线程完成</li></ol></li><li>身份认证</li></ol></li><li><p>客户端发送请求到服务器</p></li><li><p>缓存</p><ol><li>缺点<ol><li>要求sql完全一致才能使用到缓存</li><li>相关数据一旦被更新，缓存也会失效</li></ol></li><li>Mysql8.0后被删除</li></ol></li><li><p>解析器</p><ol><li>词法解析</li><li>语法解析</li></ol></li><li><p>优化器</p><ol><li>权限认证</li><li>生成执行计划<ol><li>基于成本估算选择最优执行计划<ol><li>I/O成本</li><li>CPU成本</li></ol></li><li>索引选择</li><li>关联选择</li></ol></li></ol></li><li><p>执行器</p><ol><li>根据执行计划调用存储引擎API完成SQL执行<ol><li>对于没有索引的表：依次查询每行数据</li><li>对于有索引的表：依次查询每行满足条件的数据</li></ol></li></ol></li><li><p>存储引擎：负责数据的存储和读取</p><ol><li><p>Innodb</p><ul><li><p>加载到缓冲池：MySQL 的数据最终是存储在磁盘中的，如果没有缓冲池，那么我们每次的数据库请求都会磁盘中查找，这样必然会存在磁盘I/O，肯定是无法接受的。缓冲池的作用就是我们第一次在查询的这块数据时候会将查询的结果存到缓冲池中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到缓冲池中</p></li><li><p>记录undo log：数据被加载到缓冲池后，会记录初始的undo log，内容是初始记录值。undo log的作用，就是查找数据的历史版本，以及事务失败时回滚。详情可以看之后的MVCC</p></li><li><p>在内存缓冲池中执行更新操作</p></li><li><p>更新后的数据记录到redo log buffer：数据的物理修改记录</p></li><li><p>redo log buffer刷盘，此时redolog处于prepare状态：若redo log刷盘成功，则此时Mysql奔溃，依然可以根据redo log恢复数据到缓冲池，即redo log具有crash-safe能了</p><ul><li>redolog 刷盘策略：<ul><li>不刷入磁盘</li><li>立即刷入磁盘</li><li>先刷到os cache</li></ul></li></ul></li><li><p>将binlog写入磁盘</p><ul><li><p>binlog刷盘策略：</p><ul><li>立即刷入磁盘</li><li>先刷到os cache</li></ul></li><li><p>binlog刷盘模式</p><ul><li>STATMENT：基于 SQL 语句的复制</li></ul></li></ul></li><li><p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p><ul><li>【缺点】：在某些情况下会导致主从数据不一致。比如带有limit的查询，可能由于使用到的索引不同，导致查询结果不一致。或者执行now()等</li></ul></li></ul><p>​    </p></li></ol><ul><li><p>ROW：基于数据行的复制</p><pre><code> - 【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</code></pre><ul><li><p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p><ul><li>MIXED：基于 STATMENT 和 ROW 两种模式的混合复制，一般的复制使用 STATEMENT 模式，对于 STATEMENT 模式无法复制的操作使用 ROW 模式</li></ul></li><li><p>【注意】：now()函数，mixed仍然会记录为SQL语句，即statement格式，因为它会在这句SQL前修改系统时间戳。</p></li></ul></li></ul><ul><li>将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中</li><li>最后在redo log中写入 commit 标记，这样就表示本次事务被成功提交了。</li><li>另外，缓冲池中的数据，会有有后台线程在合适的时机，利用undolog将最终数据进行刷盘</li></ul></li><li><p>服务器返回数据给客户端</p><ol><li>将结果集返回给客户端是一个增量、逐步返回的过程。一旦服务器开始生成第一条结果时，服务器就可以开始向客户端返回结果集了</li><li>服务器需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以客户端缓存结果集通常可以减少服务器压力，让查询早点结束，早点释放相应资源</li><li>如果要返回一个很大的结果集，客户端需要花更多的时间和内存来存储所有的结果集。所以如果能够尽早开始处理这些结果集，就能大大减少内存的消耗。但这样做的缺点是，对于服务器而言，需要查询完成后才能释放资源</li></ol></li></ol><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>写前日志，即更新操作，先写redolog到磁盘，并更新内存缓冲池的数据行。后续会有有后台线程在合适的时机进行刷盘。</p><h2 id="redolog与binlog的区别"><a href="#redolog与binlog的区别" class="headerlink" title="redolog与binlog的区别"></a>redolog与binlog的区别</h2><table><thead><tr><th>性质</th><th>redo Log</th><th>bin Log</th></tr></thead><tbody><tr><td>类型</td><td>物理性质记录</td><td>逻辑性质记录</td></tr><tr><td>文件大小</td><td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td><td>bin log 可通过配置参数max_bin log_size设置每个bin log文件的大小（但是一般不建议修改）。</td></tr><tr><td>实现方式</td><td>redo log是InnoDB引擎层实现的（也就是说是 Innodb 存储引擎独有的）</td><td>bin log是 MySQL 层实现的，所有引擎都可以使用 bin log日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。写满时会进行数据行刷磁盘。</td><td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>使用场景</td><td>redo log适用于崩溃恢复(crash-safe)</td><td>bin log 适用于主从复制和数据恢复</td></tr></tbody></table><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li>Innodb<ul><li>支持事务</li><li>二级索引叶子节点保存的是主键值</li><li>支持表级锁、行级锁</li></ul></li><li>MyISAM<ul><li>不支持事务</li><li>没有一二级索引的区别，B+树叶子节点保存的都是数据行指针</li><li>只支持表级锁</li><li>有压缩表技术</li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整型<ul><li>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，INT占32位</li><li>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的</li></ul></li><li>浮点型<ul><li>FLOAT、DOUBLE</li><li>DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分</li></ul></li><li>字符串<ul><li>CHAR：定长</li><li>VARCHAR：变长，只存储必要的内容</li></ul></li><li>时间<ul><li>DATETIME</li><li>TIMESTAMP：比 DATETIME 空间效率更高</li></ul></li></ul><h2 id="选择数据类型"><a href="#选择数据类型" class="headerlink" title="选择数据类型"></a>选择数据类型</h2><ul><li>更小：占用更少的磁盘、内存和CPU</li><li>简单</li><li>尽量避免NULL：对MySQL来说更难优化，使得索引、索引统计和值比较都更复杂</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>存储引擎用于快速找到记录的一种数据结构。Mysql索引是在存储引擎层，而不是服务层实现的。使用索引的优点是：</p><ul><li>减少了服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表<ul><li>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQl才能用索引来对结果排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一张表时，才能用索引做排序。ORDER BY子句也需要满足索引的最左前缀匹配</li></ul></li><li>可以将随机I/O变成顺序I/O</li><li>减少加锁行数<ul><li>InnoDB只有在访问行的时候才会对其加锁，而索引能减少nnoDB访问的行数，从而减少锁的数量</li></ul></li></ul><h2 id="索引选择性"><a href="#索引选择性" class="headerlink" title="索引选择性"></a>索引选择性</h2><p>索引选择性指的是不重复的索引值和数据表的记录总数的比值。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul><li>一级索引（主键索引）<ul><li>属于聚簇索引：索引的每个叶子结点都包含了主键值与数据页<ul><li>优点<ul><li>数据访问更快</li><li>把相关数据保存在一起，利用空间局部性原理，减少磁盘I/O</li><li>有利于I/O密集型应用</li></ul></li><li>缺点<ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据到InnoDB表中最快的方式</li><li>更新聚簇索引代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li><li>对于计算密集型应用，数据都存放在内存中，聚簇索引优势不再</li></ul></li></ul></li><li>类型<ul><li>B+树索引</li></ul></li></ul></li><li>二级索引<ul><li>二级索引叶子结点保存的不是数据页，而是主键值。通过二级索引查找行，存储引擎需要找到二级索引的叶子结点获得对应的主键值，再根据这个值去一级索引中查找对应的数据行</li><li>类型<ul><li>B+树索引</li><li>哈希索引：存储引擎会对所有的索引列计算一个哈希码，只有精确匹配索引所有列的查询才生效<ul><li>优点<ul><li>索引自身只需存储对应的哈希码，结构紧凑，速度快</li></ul></li><li>缺点<ul><li>不支持范围查找</li><li>不支持排序</li><li>不支持部分索引列匹配查找</li><li>不支持覆盖索引，只包含哈希值和主键，不存储字段值</li></ul></li><li>自适应哈希<ul><li>如果某些索引值被使用的非常频繁，InnoDB会在内存中自动基于B-Tree索引之上再创建一个哈希索引</li></ul></li></ul></li><li>空间索引</li><li>全文索引</li></ul></li></ul></li></ul><h2 id="为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值"><a href="#为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值" class="headerlink" title="为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值"></a>为什么Innodb的二级索引叶子节点不保存数据指针，而是主键值</h2><p>虽然使用主键值当做指针会让二级索引占用更多空间，但好处是，InnoDB在移动行时无需更新二级索引的这个指针。</p><h2 id="B-树索引的最左匹配原则"><a href="#B-树索引的最左匹配原则" class="headerlink" title="B+树索引的最左匹配原则"></a>B+树索引的最左匹配原则</h2><ul><li>按从左往右的顺序依次匹配</li><li>可以匹配列值得开头部分、范围值</li><li>匹配完范围值后，后续右边所有索引列无法再匹配。如果列的范围值数量有限，可以通过使用多个等于条件代替范围值</li></ul><h2 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h2><p>MySQL5.0之前，一个表一次查询只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描，然后将结果进行合并处理，然后再进行回表查询。</p><p>类型：</p><ul><li>intersect</li><li>union</li><li>sort-union：不能使用union的 OR 条件会使用sort-union</li></ul><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>B+树按照做做匹配原则查询索引，在旧版本的Mysql中，对于剩余不符合最左匹配的索引列，会在回表找到数据后再比较。而新版本的Mysql，可以先在索引的剩余列上比较，筛选完成后再回表找到数据后继续比较，减少回表查询的数据行数，这就是索引下推。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol><li>原子性（Atomicity）<ul><li>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</li><li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</li></ul></li><li>一致性（Consistency）<ul><li>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的</li></ul></li><li> 隔离性（Isolation）</li></ol><ul><li>一个事务所做的修改在最终提交以前，对其它事务是不可见的</li></ul><ol start="4"><li>持久性（Durability）<ul><li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失</li></ul></li></ol><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/acid.png"></p><h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><ul><li><p>修改丢失</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/update-lose.png"></p></li><li><p>脏读</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/dirty-read.png"></p></li><li><p>不可重复读</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/cannot-repeat-read.png"></p></li><li><p>幻读</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/phantom-read.png"></p></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁粒度：任何时候，在给定的资源上，锁定的数据量越少，则系统的并发成都越高，但是锁管理消耗资源的资源也越多。所谓锁策略，就是在锁的开销和数据安全性之间寻求平衡</p><ul><li><p>全局锁</p><ul><li>加锁时机和方式<ul><li>对于Innodb，使用一致性视图做全局备份。对于其他不支持一致性视图的存储引擎，只能使用全局锁，然后做全局备份</li></ul></li><li>主动加锁语法：Flush tables with read lock</li><li>类型：<ul><li>读锁：使整个数据库处于只读状态</li></ul></li></ul></li><li><p>表级锁</p><ul><li>表锁<ul><li>加锁时机和方式<ul><li>存储引擎不支持行锁或其他锁，只会加表锁</li><li>没有使用到索引，而是全表扫描，会加表锁</li></ul></li><li>主动加锁语法：lock tables … read/write</li><li>类型：<ul><li>读锁</li><li>写锁</li></ul></li></ul></li><li>意向锁：<ul><li>加锁时机和方式<ul><li>加行锁时，会加所在表的意向锁</li></ul></li><li>类型<ul><li>意向读锁</li><li>意向写锁</li></ul></li></ul></li><li>元数据锁MDL<ul><li>加锁时机和方式<ul><li>表更改SQL访问表时自动加MDL锁，事务结束时自动解锁</li></ul></li><li>类型：<ul><li>读锁：对表做增删改查操作时</li><li>写锁：对表做结构变更时</li></ul></li></ul></li></ul></li><li><p>行级锁</p><ul><li>加锁时机和方式<ul><li>未提交读<ul><li>隐式<ul><li>只加RL写锁，不加RL读锁，不加GL</li></ul></li><li>显式<ul><li>只加RL</li></ul></li></ul></li><li>提交读<ul><li>隐式<ul><li>只加RL写锁，不加RL读锁，不加GL</li></ul></li><li>显式<ul><li>一般情况下加锁原理等于“可重复读”，只是去掉了GL</li><li>外键场景依然有GL，但是实际使用中没有设置外键，所以暂不讨论</li><li>优化：语句执行过程加的RL，会在语句执行完成后把不满足条件的RL释放掉</li></ul></li></ul></li><li>可重复读<ul><li>隐式<ul><li>只加RKL写锁</li></ul></li><li>显式<ul><li>加锁的基本单位是NKL，是一个前开后闭的区间。例如数据是1，5，10，访问到10，会加NKL (5,10]</li><li>查找过程中访问到的索引及对象才会加锁<ul><li>意味着覆盖索引不会在主键索引上加锁</li></ul></li><li>索引上的等值查询，给唯一索引加锁的时候，会退化为RL<ul><li>范围查询的左边界包含=号，也算等值查询</li></ul></li><li>索引上的等值查询，向右遍历到最后一个值不满足条件的对象时，会退化为GL</li><li>特例：唯一索引上的范围查询，不论是否指定右边界，都会加锁到第一个不满足条件的对象</li><li>其他需要注意的点<ul><li>update、delete、select的加锁逻辑一致</li><li>包含limit的语句，在扫描过程中一旦满足了，limit条件，就立即返回，不会再向后查询，即不会继续加锁</li><li>虽然加NKL就等于加RL和GL，但需要注意，本质上还是两个锁，会先加GL，再加RL</li></ul></li></ul></li></ul></li><li>可串行化<ul><li>系统自动加RKL</li></ul></li></ul></li><li>主动加锁语法<ul><li>select … lock in share mode</li><li>select … for update</li></ul></li><li>类型：<ul><li>读锁</li><li>写锁</li></ul></li></ul></li><li><p>Next-key lock = Record Lock + Gap Lock</p><ul><li><p>可重复读模式查询默认是不加锁的，要使用RKL，需要主动加锁</p></li><li><p>Record Lock：锁定一个记录上的索引，而不是记录本身</p></li><li><p>间隙锁 Gap Lock：锁定索引之间的间隙，但是不包含索引本身</p><ul><li>间隙锁的作用是防止幻读，所以间隙锁与间隙锁之间不会互斥，间隙锁阻止的是往间隙内新插入数据</li></ul></li><li><p>在不考虑退化的场景下，加NKL就等于加RL和GL，但需要注意，本质上还是两个锁，会先加GL，再加RL</p></li></ul></li></ul><h2 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h2><p>Mysql的事务遵循两段锁加锁协议，它是保证可串行化调度的充分条件。可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>对于一个事务而言，会在事务开始后的任何需要加锁的位置加锁，但都会等到提交或回滚事务前的统一时刻，一起释放锁。</p><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>死锁指的是并发环境下，多个线程循环依赖彼此占有的资源，导致每个线程所需的资源都永远没法被满足，从而无限期等待下去的现象。</p><p>对于Mysql而言，解决死锁的方法有：</p><ul><li>设置锁超时时间<ul><li>默认时间50s。等待时间太长业务无法接受。等待时间太多会发生很多误伤。</li></ul></li><li>发起死锁监测，发现死锁后，主动回滚死锁循环中的某一个事务<ul><li>极端情况下，所有事务都针对某一行加锁，那么死锁检测总花费是O(n^2)行，会消耗大量CPU资源。<ul><li>限制并发度<ul><li>修改Mysql源码，针对同一行的加锁需要排队</li><li>业务上限制针对同一个key的访问并发度</li></ul></li><li>将业务的一行数据改为逻辑上的多行数据，从而分担压力</li></ul></li></ul></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ol><li>未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。<ol><li>解决问题：无</li><li>实现方式：不会隐式加读锁，会加写锁，直接返回最新值</li></ol></li><li>提交读（READ COMMITTED）：一个事务提交后，他所做的变更才会被其他事务看到<ol><li>解决问题：修改丢失、脏读</li><li>实现方式：隐式写锁+MVCC</li></ol></li><li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。<ol><li>解决问题：修改丢失、脏读、不可重复读</li><li>实现方式：隐式写锁+MVCC+RKL（主动加锁）</li></ol></li><li>可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。<ol><li>解决问题：修改丢失、脏读、不可重复读、幻读</li><li>实现方式：隐式读写锁</li></ol></li></ol><p>上述隔离级别都不影响显式加锁。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC作用于提交读和可重复读两个级别。</p><p>所谓MVCC，就是多版本并发控制。Mysql会维护一个全局版本号，每开启一个新事务都会将当前全局版本号赋值给这个事务，作为事务版本号，并且全局版本号递增。所谓多版本，就是每条记录更新时，都会记录一条undo log。我们可以通过记录最新值与undo log将记录回滚至任意版本。当没有任何事务需要这条undo log时，他就会被删除。在读取数据时，就会从当前版本开始往前依次查找最新一个可见版本并读取它。称之为一致性读视图。</p><p>读取数据时，根据读视图read view判断数据版本可见性：</p><ul><li>事务开启时，将当前正在活跃（已开启但还未提交）的版本记录下来，称为read view</li><li>获取read view中最小事务id和最大事务id</li><li>判断一个版本是否可见：<ul><li>若当前版本小于read view最小事务id，说明这个版本是所有未提交版本开始前就已经提交的，可以看见</li><li>若当前版本打于read view最大事务id，说明这个版本是所有未提交版本开始后就已经提交的，不可以看见</li><li>若当前版本大于等于read view最小事务id 并且 小于等于read view最大事务id：<ul><li>提交读：当前版本在read view中就不可见（因为还没提交），不在就可见</li><li>可重复读：不可见</li></ul></li></ul></li></ul><p>总结，在生成read view时确定可见性：</p><ul><li>版本未提交，不可见</li><li>版本已提交，但是在read view创建后提交，不可见</li><li>版本已提交，但是在read view创建前提交，可见</li></ul><p>另外，读写操作的情况也不一样：</p><ul><li>读操作：快照读<ul><li>提交读：视图在每个SQL执行时创建</li><li>可重复读：视图在事务启动时创建</li></ul></li><li>显式加锁的读操作、写操作：当前读<ul><li>总是读取已提交的最新版本</li></ul></li></ul><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>MVCC不能解决幻读问题：快照读不会产生幻读，但当前读会产生幻读</p><p>解决方案：</p><ul><li>提升隔离级别为可串行化</li><li>当前读 + RKL（主动加锁）</li></ul><h2 id="Autocommit"><a href="#Autocommit" class="headerlink" title="Autocommit"></a>Autocommit</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><p>如果关闭自动提交，那么隐式地开启事务，并不会自动提交，可能会造成长事务。</p><h2 id="如何提高事务并发度"><a href="#如何提高事务并发度" class="headerlink" title="如何提高事务并发度"></a>如何提高事务并发度</h2><ol><li>减小锁范围<ol><li>行锁 &lt; 表锁 &lt; 全局锁</li><li>MVCC相当于数据行版本锁</li><li>读写分离锁</li></ol></li><li>减少锁数量<ol><li>减少扫描的数据行数</li><li>修改隔离级别，RKL -&gt; RL</li><li>只在必要时加锁：快照读与当前读</li></ol></li></ol><h2 id="为什么不要使用长事务"><a href="#为什么不要使用长事务" class="headerlink" title="为什么不要使用长事务"></a>为什么不要使用长事务</h2><ol><li> 长时间占有锁</li><li>长时间占有连接和线程</li><li>长事务意味着服务器会存储很老的事务视图，他可能用到的回滚记录undolog都必须保留，不利于undolog释放，占用大量内存空间</li><li>同步到从库以后，从库也要执行很长时间，主从不一致时间变长</li></ol><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="1-通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL"><a href="#1-通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL" class="headerlink" title="1.通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL"></a>1.通过应用层分析、第三方工具、慢查询日志定位有问题的API、SQL</h2><h2 id="2-使用Explain分析SQL"><a href="#2-使用Explain分析SQL" class="headerlink" title="2.使用Explain分析SQL"></a>2.使用Explain分析SQL</h2><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h2 id="3-通用优化"><a href="#3-通用优化" class="headerlink" title="3.通用优化"></a>3.通用优化</h2><ol><li>避免长事务</li></ol><h2 id="4-优化数据访问量"><a href="#4-优化数据访问量" class="headerlink" title="4.优化数据访问量"></a>4.优化数据访问量</h2><ol><li>返回的数据过多<ol><li>返回必要的行：limit</li><li>返回必要的列：不要使用select *</li><li>拆分大查询</li></ol></li><li>检索的数据过多<ol><li>首先考虑在存储引擎层，使用索引过滤数据</li><li>然后考虑在服务层，使用覆盖索引返回记录，无需回表查询</li><li>最后才是在服务层，从数据表中过滤数据</li></ol></li></ol><h2 id="5-索引优化"><a href="#5-索引优化" class="headerlink" title="5.索引优化"></a>5.索引优化</h2><ol><li>主键索引设置<ol><li>推荐像雪花算法这样的自增ID生成器，这样局部性原理失效可以保证数据行按顺序写入，将随机I/O变为顺序I/O，又可以避免被猜到核心数据id。缺点是高并发工作负载时，InnoDB中按主键顺序插入可能会造成明显的争用</li><li>使用UUID作为聚簇索引会很糟糕，它使得聚簇索引的插入变得完全随机，使数据没有任何聚集特性<ol><li>局部性原理失效，造成大量磁盘I/O</li><li>不得不频繁地做页分裂操作，以便为新的行分配空间，这会导致移动大量的数据</li><li>由于频繁地页分裂，页也会变得稀疏，并被不规则填充，所以最终数据会有碎片</li></ol></li><li>整数类型通常是最佳选择，因为它们很快并且可以使用自增列。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢</li></ol></li><li>二级索引设置<ol><li>为哪些列建立索引：为频繁出现在WHERE、ORDER BY、GROUP BY等子句的列设置索引</li><li>如何建立索引<ol><li>有排序需求：按排序需求创建索引列</li><li>无排序需求：选择性大的条件放在前面</li><li>可以通过调整索引顺序，少维护一些索引</li><li>尽可能将范围查找的列放在索引的后面</li><li>若索引列是字符串类型，考虑前缀索引<ol><li>选择索引开始的部分字符，使其选择性接近于索引整个列，可以大大节约索引空间，提高索引效率</li><li>无法使用前缀索引做ORDER BY、GROUP BY、覆盖扫描</li></ol></li></ol></li></ol></li><li>使用索引<ol><li>只有独立列才能使用索引，不能是表达式的一部分，也不能是函数中的参数</li><li>若范围查询是可枚举的，可以使用IN代替范围查找</li><li>覆盖索引：索引包含所有需要查询的字段的值，优化器会在执行查询前判断是否有一个索引能进行覆盖<ul><li>优点<ul><li>避免二级索引对主键索引的回表查询</li><li>索引条目通常远小于数据行大小，减少了数据访问量</li></ul></li></ul></li></ol></li></ol><h2 id="6-优化关联查询"><a href="#6-优化关联查询" class="headerlink" title="6.优化关联查询"></a>6.优化关联查询</h2><ol><li>尽量在应用层做关联</li><li>拆分复杂关联查询<ol><li>利于使用索引</li><li>减少锁竞争</li><li>利于数据库拆分</li></ol></li></ol><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制：最终一致性"><a href="#主从复制：最终一致性" class="headerlink" title="主从复制：最终一致性"></a>主从复制：最终一致性</h2><ul><li><p>M-S架构</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/m-s.jpg"></p><ul><li><p>如何提供服务？</p><p>主库提供读写服务，备库是只读状态，只提供读服务。备库设置为只读，可以防止误操作、数据不一致，还可以用来判断主备角色。</p></li><li><p>如何同步数据？</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/master2slave.jpg"></p><ul><li>备库上执行change master命令，设置其主库地址、binlog起始请求位置等信息</li><li>主库执行更新命令（流程之前有），会写binlog</li><li>备库上执行start slave命令，开启同步，首先会和主库建立连接。连接建立后，主库开始按照备库传过来的起始地址，从本地读取binlog，发送给备库</li><li>备库拿到主库发送过来的binlog后，首先会写入到中转日志relay log，相当于缓存</li><li>会有专门的线程从relay log中读取日志，解析出里面的命令后执行</li></ul></li></ul></li><li><p>M-M架构</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/mysql/m-m.jpg"></p><ul><li><p>如何提供服务？</p><p>互为主备，都可以提供读写服务，但为了避免数据不一致，只有一个节点对外提供服务，备节点只做数据备份。主备切换时不需要修改主备关系，更加快速。</p></li><li><p>如何同步数据？</p><p>和M-S架构一样</p></li><li><p>循环复制问题</p><p>每个节点都有自己的唯一serverid。主库生成binlog时，会携带serverid。备库执行完主库传播过来的binlog后，再生成自己的binlog，会使用主库的serverid。主库接收备库的binlog时，发现里面的serverid等于自己的serverid，就不处理这条binlog</p></li></ul></li></ul><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul><li>恢复某行数据<ul><li>利用Flashback工具闪回数据<ul><li>原理是修改binlog拿回原库重放<ul><li>适合row格式</li><li>不适合statement、mixed格式，都会因为SQL语句及回放的位置导致数据不一致</li></ul></li><li>不建议直接在主库上闪回，而是先恢复出一个备份数据，或者是在从库上恢复数据，然后再拿着恢复好的数据，恢复主库</li></ul></li></ul></li><li>恢复表/库<ul><li>全量备份 + 实时备份binlog</li><li>延迟复制备库：一种特殊的备库，可以设置其备份主库的延迟时间，如1小时，那么在这1小时内发生的数据问题，都可以通过这个备库快速恢复。</li></ul></li></ul><h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><ul><li><p>如何判断主备延迟</p><p>每条binlog都会记录其在主库上的写入时间，备库执行binlog时，会计算当前时间与写入时间的差值，这就是主备延迟时间。需要注意，主备库机器时间不同不会影响主备延迟时间的计算，因为备库连接到主库时，会记录其与主库的系统时间差值，之后计算主备延迟时间时会自动扣减这个差值</p></li><li><p>主备延迟原因</p><ul><li>备库机器性能比主库差<ul><li>现在基本上都做对称部署</li></ul></li><li>备库压力大<ul><li>一主多从，分散压力</li><li>通过binlog输出到外部系统，坐统计类分析查询</li></ul></li><li>大事务<ul><li>分批执行大事务</li></ul></li><li>大表DDL</li><li>并行复制策略不合理</li></ul></li></ul><h2 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h2><ul><li>可靠性优先策略（建议）<ol><li>判断备库延迟时间，小于阈值时进行下一步</li><li>下线主库，readonly=true</li><li>等待备库延迟时间降为0，即同步完所有主库binlog</li><li>将备库升级为主库，即改为可读写状态</li><li>将业务请求切到新主库</li></ol></li><li>可用性优先策略<ol><li>下线主库，readonly=true</li><li>将备库升级为主库，即改为可读写状态</li><li>将业务请求切到新主库</li><li>binlog采用row模式，发现不一致时手动修复</li></ol></li></ul><h2 id="并行复制策略"><a href="#并行复制策略" class="headerlink" title="并行复制策略"></a>并行复制策略</h2><p>将relay log按照一定规则分发给多个线程并行执行数据同步工作</p><p>基本原则：</p><ul><li>更新同一行的事务必须被分发到同一个worker</li><li>同一事务的多条sql必须被分发到同一个worker</li></ul><p>分发策略：</p><ul><li>DATABASE 按库分发：将涉及相同库的SQL分发到同一worker上</li><li>COMMIT_ORDER<ul><li>binlog状态同时处于prepare的多个事务可以并行执行</li><li>binlog状态处于prepare可以与处于commit状态的事务并行执行</li></ul></li><li>WRITESET<ul><li>对于事务涉及更新的每一行，计算出hash值，组成writeset。如果两个事务的writeset没有交集，也就是说他们没有操作相同行，可以并行执行</li><li>hash是通过库名+表名+索引名+索引值计算出来的</li><li>要是同一行涉及多个唯一索引，那么就会生成多个hash值</li></ul></li><li>WRITESET_SESSION：WRITESET基础上，保证同一个线程上先后执行的事务，在备库执行时也保持这个顺序</li></ul><h2 id="一主多从情况下的主备切换"><a href="#一主多从情况下的主备切换" class="headerlink" title="一主多从情况下的主备切换"></a>一主多从情况下的主备切换</h2><p>由于多个从库都会同步主库数据，并且他们的同步进度并不一样。所以在切换新主库后，可能发生新主库与从库数据冲突的情况，解决方案是：</p><ul><li>切换过程中忽略指定报错</li><li>全局事务ID<ul><li>不同于事务id是在事务开始时分配的，全局事务id是在事务提交时分配的</li><li>组成：serverId+递增的唯一值</li></ul></li><li>使用<ul><li>每个Mysql实例都会维护一个GTID集合，表示该实例执行过的所有事务</li><li>备库指定新主库，并与新主库建立连接</li><li>备库将自己的GTID集合发给新主库</li><li>新主库计算自己的GTID集合与备库GTID集合的差集<ul><li>若新主库包含这个差集的所有binlog，则将第一个不在备库GTID集合中的binlog发给备库去执行，之后备库就从这个位置开始向后顺序读取新主库的binlog</li><li>若新主库没有包含这个差集的所有binlog，直接返回错误</li></ul></li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="统计行数"><a href="#统计行数" class="headerlink" title="统计行数"></a>统计行数</h2><ul><li>count(*)<ul><li>MyISAM<ul><li>将表行数存储起来，没有查询条件时可以直接返回</li></ul></li><li>InnoDB<ul><li>由于MVCC的存在，无法准确估计此次查询能看到的行的数量，所以没法将表行数存储起来</li><li>优化<ul><li>优先采用最小的索引树</li></ul></li></ul></li></ul></li><li>show tables status.TABLE_ROWS<ul><li>估算</li></ul></li><li>利用缓存系统保存行数<ul><li>缓存一致性问题</li></ul></li><li>数据库保存行数</li></ul><h2 id="count-vs-count-1-vs-count-主键-vs-count-字段"><a href="#count-vs-count-1-vs-count-主键-vs-count-字段" class="headerlink" title="count(*) vs count(1) vs count(主键) vs count(字段)"></a>count(*) vs count(1) vs count(主键) vs count(字段)</h2><ul><li>count(字段)<ul><li>满足条件的字段不为NULL的行数</li><li>搜索引擎按条件查询数据，将每一行的字段取出来交给服务层，服务层判断不为NULL后累计</li></ul></li><li>count(主键)<ul><li>满足条件的总行数</li><li>搜索引擎按条件查询数据，将每一行的id取出来交给服务层，服务层累计</li><li>相比于count(字段)，主键不可能为NULL</li></ul></li><li>count(1) <ul><li>满足条件的总行数</li><li>搜索引擎按条件查询数据，将每一行赋值为1交给服务层，服务层（不可能为NULL）累计</li><li>相比于count(主键)，减少了解析数据行取主键和将主键传输给服务层的过程</li></ul></li><li>count(*)<ul><li>满足条件的总行数</li><li>搜索引擎按条件查询数据，对于每一行不取值，直接交给服务层累计</li><li>MySQL支队count(*)做了这个优化，没有对count(主键)做优化</li></ul></li></ul><p>结论：</p><p>count(*) = count(1) &gt; count(主键) &gt; count(字段)，建议尽量使用count(*)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题</title>
    <link href="/2023/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/07/18/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h2><ul><li>select<ul><li>过程<ul><li>将描述符数组从用户空间拷贝到内核空间</li><li>内核空间遍历拷贝来的描述符，检查有无读写事件，若有，则处理，否则当前进程进入阻塞态</li><li>若设备驱动发现自身资源可读写，或超过一定时间，会唤醒select进程，重新执行步骤1</li></ul></li><li>优点<ul><li>实时性好，微秒级时延</li><li>可移植性好，几乎所有系统都支持</li></ul></li><li>缺点<ul><li>每次调用，都需把描述符数组从用户态拷贝到内核态，开销很大</li><li>每次调用，内核态都需要遍历描述符数组，开销很大</li><li>主动轮询效率低</li><li>描述符数组默认支持最多1024个</li></ul></li></ul></li><li>poll<ul><li>过程：和select类似</li><li>优点<ul><li>相比于select，定义了数据结构表达描述符，其构成链表，无最大链接限制</li><li>相比于select，提供了更多事件类型，对描述符的重复利用率更高</li></ul></li><li>缺点<ul><li>每次调用，都需把描述符数组从用户态拷贝到内核态，开销很大</li><li>每次调用，内核态都需要遍历描述符数组，开销很大</li><li>主动轮询效率低</li></ul></li></ul></li><li>epoll<ul><li>过程：向用户空间与内核空间共用的一块内存注册描述符，将其维护在红黑树的结构上，当有事件发生时，主动调用进程的回调函数处理</li><li>模式<ul><li>LT：进程可以不立即处理该事件，下次调用会再次通知</li><li>ET：进程必须立即处理事件，下次再调用时不会再得到通知（处理程序只关心本次事件，效率高）</li></ul></li><li>优点<ul><li>只有注册新描述符或修改描述符时，需把描述符数组从用户态拷贝到内核态，只会复制一次</li><li>相比于select，使用红黑树维护描述符，无最大链接限制</li><li>处理大量联接时，性能好</li></ul></li><li>缺点<ul><li>实时性一般，毫秒级时延</li></ul></li></ul></li></ul><h2 id="Seata-分布式事务架构"><a href="#Seata-分布式事务架构" class="headerlink" title="Seata 分布式事务架构"></a>Seata 分布式事务架构</h2><p>分布式事务顾名思义就是要在分布式系统中实现事务，它其实是由多个本地事务组合而成。对于分布式事务而言几乎满足不了 ACID。</p><p>包含的角色有：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/seata%E6%9E%B6%E6%9E%84.png"></p><ul><li>TC(Transaction Coordinator) 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li>TM(Transaction Manager) 事务管理器：定义全局事务。</li><li>RM(Resource Manager) 资源管理器：实际事务的执行者（管理分支事务处理的资源，驱动分支事务提交或回滚），与TC交谈以注册分支事务和报告分支事务的状态</li></ul><h3 id="解决方案：XA"><a href="#解决方案：XA" class="headerlink" title="解决方案：XA"></a>解决方案：XA</h3><p>优点：</p><ul><li>强一致性，满足ACID原则，但具体实现的2PC、3PC会有一致性问题</li><li>完全隔离</li><li>无代码侵入</li><li>常用数据库都支持，实现简单，没有代码侵入</li></ul><p>缺点：</p><ul><li>性能差</li><li>适用于数据库层面</li></ul><p>实现：</p><ol><li><p>2PC</p><p>执行过程：</p><ol><li><p>准备阶段</p><p>协调者命令参与者执行提交/回滚事务意外的动作，参与者发回执行结果。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/2pc-1.png"></p></li><li><p>提交阶段（不能保证一致性）</p><p>如果事务在每个参与者上都执行成功，协调者命令参与者提交事务；否则，协调者命令参与者回滚事务。不论提交还是回滚，执行失败会一直重试。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/2pc-2.png"></p></li></ol><p>问题：</p><ul><li><p>同步阻塞</p><ul><li><p>所有参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。</p><p>解决方案：</p><ul><li>第一阶段实现超时机制</li><li>第二阶段只能不断重试，实在不行需要人工介入</li></ul></li></ul></li><li><p>单点问题</p><ul><li><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。</p><p>解决方案：</p><ul><li>通过选举选择新的协调者，但是需要实现日志功能，帮助新上线的协调者获知现场信息。但是极端场景下仍然存在数据不一致的问题。</li></ul></li></ul></li><li><p>数据不一致：在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p></li></ul></li><li><p>3PC（不能保证一致性）</p><p>执行过程：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/3pc.png"></p><ol><li><p>准备阶段</p><p>先询问参与者是否有条件处理请求。</p></li><li><p>预提交阶段</p><p>协调者命令参与者执行提交/回滚事务意外的动作，参与者发回执行结果。</p></li><li><p>提交阶段</p><p>如果事务在每个参与者上都执行成功，协调者命令参与者提交事务；否则，协调者命令参与者回滚事务。不论提交还是回滚，执行失败会一直重试。</p><p>与2PC不同，如果参与者此时等待协调者发来命令超时，默认会自动提交，原因是事务执行到这个阶段大概率是要提交的。</p><p>优点：不会一直占有资源</p><p>缺点：数据不一致</p></li></ol><p>问题：</p><ul><li>引入了新阶段，是的提前统一所有参与者的状态，但依然不能保证数据一致性，并且处理链路变长，性能下降</li><li>没有太多具体应用</li></ul></li></ol><h3 id="解决方案：AT"><a href="#解决方案：AT" class="headerlink" title="解决方案：AT"></a>解决方案：AT</h3><p>与XA模式的区别是：</p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li><li>XA模式依赖数据库机制实现回滚；AT模式利用undo-log实现数据回滚。</li><li>XA模式强一致；AT模式最终一致</li></ul><p>优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li><li>利用全局锁实现读写隔离</li><li>没有代码侵入，框架自动完成回滚和提交</li></ul><p>缺点：</p><ul><li>两阶段之间属于软状态，属于最终一致</li><li>undo-log会影响性能，但比XA模式要好很多</li></ul><p>执行过程：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/AT.png"></p><ol><li>执行阶段<ol><li>TM 开启全局事务后，通知各个 RM 向 TC 注册全局事务</li><li>RM 执行各自的事务并提交，并记录undo-log</li><li>RM 向 TC 报告执行状态</li></ol></li><li>检查阶段<ol><li>若所有 RM 都执行成功，那么 TC 通知 RM 删除刚才执行事务的 undo-log。否则 TC 通知 RM 利用刚才执行事务的 undo-log 进行回滚。</li></ol></li></ol><h3 id="解决方案：TCC"><a href="#解决方案：TCC" class="headerlink" title="解决方案：TCC"></a>解决方案：TCC</h3><p>优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>适用范围广，不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li><li>可以跨数据库、跨系统</li></ul><p>缺点：</p><ul><li>需要协调者，具有单点问题</li><li>对业务侵入性强，每一种资源都需要实现 try/confirm/cancel 三种动作，部分场景难以实现</li><li>软状态，事务是最终一致</li><li>资源操作需要幂等</li></ul><p>实现：</p><ol><li><p>TCC</p><p>执行过程：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/tcc.png"></p><ol><li>try：资源锁定</li><li>confirm：资源核销</li><li>cancel：资源释放</li></ol></li></ol><h3 id="解决方案：SAGA"><a href="#解决方案：SAGA" class="headerlink" title="解决方案：SAGA"></a>解决方案：SAGA</h3><p>优点：</p><ul><li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不用编写TCC中的三个阶段，实现简单</li></ul><p>缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><p>执行过程：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/SAGA.png"></p><ol><li>各 RM 直接执行事务并提交</li><li>如果出现问题，那么编写回滚操作，按顺序逆向执行</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>AT 和 XA 都是基于数据库提供的事务能力实现分布式事务。TCC 和 SAGA 都是基于业务实现提交/回滚操作实现分布式事务</li><li>AT 和 TCC 都类似于预提交，之后会有一个统一的提交阶段。AT 和 SAGA 都是直接提交，出问题执行逆向回滚操作。</li></ol><h3 id="解决方案：其他"><a href="#解决方案：其他" class="headerlink" title="解决方案：其他"></a>解决方案：其他</h3><ol><li><p>本地消息表（最终一致性）</p><p>在写入业务数据表的时候，同时写入本地消息表，利用数据库实现的事务保证一致性。然后根据本地消息表的内容，调用具体操作。如果操作调用成功，那么直接修改本地消息表状态。否则需要重试。另外会有定时任务会去扫本地消息表，执行里面的未完成消息。</p></li><li><p>消息事务（最终一致性）</p><p>执行过程：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/distributed-transaction/mq.png"></p><ol><li>向 broker 发送事务消息（消费者不可见），broker 向发送方响应</li><li>事务消息发送成功后，发送方执行本地事务，并根据本地事务执行结果，向 broker 发送提交/回滚消息</li><li>若提交/回滚消息发送失败，即 broker 超时未接收到提交/回滚消息，broker 会调用提前设置好的查询接口，主动查询发送方的本地事务执行结果。一直不成功就会进入死信队列。</li><li>broker 总会获知发送方的本地事务执行结果。如果是提交消息，那么相当于提交消息的消费者成为下一次执行过程的发送方，执行事务的下一个操作。如果是回滚消息，消费者不会看到这条消息，直接丢弃就可以。</li></ol></li></ol><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="传统-I-O"><a href="#传统-I-O" class="headerlink" title="传统 I/O"></a>传统 I/O</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/zero-copy-1.png"></p><p>应用程序从I/O设备读取数据的过程是：</p><ol><li>将数据从 I/O 设备拷贝到内核缓冲区中，这个过程是 DMA 拷贝</li><li>将内核缓冲区中的数据拷贝到用户态的应用程序缓冲区中，这个过程是 CPU 拷贝</li></ol><p>很明显，这个过程不仅涉及两次数据拷贝，还涉及操作系统的内核态与用户态的切换。</p><p>同理，应用程序将数据输出到I/O设备的过程是：</p><ol><li>将用户态的应用程序缓冲区中的数据拷贝到内核缓冲区中，这个过程是 CPU 拷贝</li><li>将内核缓冲区中的数据拷贝到 I/O 设备，这个过程是 DMA 拷贝</li></ol><p>那么，如果我们是将数据从设备1传输到设备2，那就涉及4次数据拷贝，以及3次内核态与用户态的切换。</p><h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/zero-copy-2.png"></p><p>不需要将内核缓冲区中的数据拷贝到用户态的应用程序缓冲区中，而是直接将设备1的内核缓冲区数据拷贝到设备2的内核缓冲区，自然就节省了1次数据拷贝，以及1次内核态与用户态的切换。</p><h3 id="第二次优化：零拷贝"><a href="#第二次优化：零拷贝" class="headerlink" title="第二次优化：零拷贝"></a>第二次优化：零拷贝</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/zero-copy-3.png"></p><p>只将数据必要的描述符与长度信息拷贝到设备2的内核缓冲区，供输出数据使用，然后直接用这些元信息操作设备1的内核缓冲区数据，输出到设备2上。好处是：</p><ul><li>基本节省了1次拷贝过程</li><li>完全不需要 CPU 拷贝，节省了大量 CPU 资源。这也是零拷贝名称的由来。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis面试题</title>
    <link href="/2023/07/09/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/07/09/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="基础通用"><a href="#基础通用" class="headerlink" title="基础通用"></a>基础通用</h1><h2 id="1-业务使用场景"><a href="#1-业务使用场景" class="headerlink" title="1.业务使用场景"></a>1.业务使用场景</h2><p><strong>缓存</strong>：</p><p>对于我们的系统而言，缓存的目的是为了减少对底层数据库、RPC的访问，一是加快了访问速度，二是降低层次请求压力。</p><p>Redis适用于缓存的原因有：</p><ol><li>基于内存的数据库，处理速度快</li><li>有内置的数据过期、内存淘汰策略</li></ol><p>首先需要明确，由于Redis并不是内嵌在访问数据库的关键路径上，所以应用程序需要去处理缓存命中、缓存丢失、缓存更新，即Redis此时是作为旁路缓存在使用的。</p><p>Redis作为缓存有两种类型：</p><ul><li>只读缓存：只加速读请求。优点是写操作都在数据库完成，数据库提供数据可靠性保障，不会有数据丢失的风险。适合于数据一致性要求高的场景。缺点是相比于下面要讲的读写缓存，会降低一次读请求的处理速度。<ul><li>应用需要读数据时，会先访问Redis，若Redis有该数据，则直接返回。否则访问数据库，并更新缓存，然后返回。</li><li>应用需要写数据时，一般考虑先更新数据库，再删除缓存的方案。然后读请求会发生缓存缺失，访问数据库后更新缓存。</li></ul></li><li>读写缓存：可以加速读写请求。优点是读请求不会由于数据更新导致未命中。适合于对访问性能要求高的场景。缺点是高并发场景下保证数据一致性困难。<ul><li>应用需要读数据时，会先访问Redis，若Redis有该数据，则直接返回。否则访问数据库，并更新缓存，然后返回。</li><li>应用需要写数据时<ul><li>同步直写模式：数据同时写Redis和数据库，两边都完成后再给应用返回<ul><li>优点：数据可靠性高</li><li>缺点：降低写请求失败概率、处理性能</li></ul></li><li>异步写回模式：数据先写在缓存，等到合适的时机同步到数据库。一般Redis不实现这类缓存。<ul><li>优点：写请求处理性能好</li><li>缺点：有数据丢失、不一致风险，需要应用自己实现写回机制</li></ul></li></ul></li></ul></li></ul><p><strong>分布式锁</strong>：</p><ul><li><p>redis实现</p><p>回顾下临界资源访问的四个原则：</p><ol><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ol><p>实现分布式锁需要注意两个问题：</p><ol><li>加锁和解锁的过程需要具有原子性</li><li>分布式锁服务需要保障可靠性</li></ol><p>我们以单数量的锁为例，即每把锁同时只能被获取一次，看看单实例Redis实现分布式锁的过程：</p><p>加锁过程：</p><ol><li>读取锁变量</li><li>判断锁变量值</li><li>修改锁变量值</li></ol><p>加锁实现方案，使用SET命令进行加锁，使用NX选项判断key值不存在时才加锁，使用PX选项设置过期时间。这样，就实现了空闲让进、忙则等待、有限等待的原则。至于让权等待，对于Redis层而言，加锁失败不会阻塞后续命令处理。对于应用层而言，可以适当重试或直接抛异常。另外，我们最好给每把锁都设置合适的唯一key，防止客户端之间误操作。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> key <span class="hljs-comment">value NX PX 1000</span><br></code></pre></td></tr></table></figure><p>解锁过程：</p><ol><li>读取锁变量</li><li>判断锁变量值</li><li>删除锁变量</li></ol><p>解锁实现方案：</p><ul><li>使用lua脚本</li><li>使用事务+pipeline+watch</li></ul><p>我们再看下Redis集群实现的高可靠分布式锁方案Redlock：</p><ol><li>客户端获取当前时间</li><li>向所有实例发起加锁操作，并统计每个实例的耗时</li><li>若加锁成功，则直接返回：<ol><li>超过半数的实例加锁成功</li><li>获取锁的总耗时没有超过锁的有效时间</li></ol></li><li>若加锁失败，则释放所有实例上的锁</li></ol></li><li><p>Mysql实现</p><p>唯一索引</p><p>缺点：</p><ul><li>没有失效时间</li><li>唯一索引冲突立即报错，只能非阻塞</li><li>不可重入</li></ul></li><li><p>ETCD实现</p><p>加锁：</p><ul><li><p>创建租约（设置失效时间）</p><ul><li>lease.grant</li><li>lease.keepAliveOnce</li></ul></li><li><p>lock.lock 获取锁</p></li></ul><p>解锁：</p><ul><li>失效租约 lease.revokeLease</li><li>lock.unlock 释放锁</li></ul></li><li><p>zookeeper实现</p><p>加锁：</p><ul><li>设置临时目录，就拥有了过期时间</li><li>设置有序目录，获取目录后检查是否为最小id，若是则获取到锁，否则监控自己的前一个节点，当他失效时再次检查是否获取到锁</li></ul><p>解锁：</p><ul><li>会话结束，自动删除临时节点，触发后一个节点的通知</li><li>会话超时，自动删除临时节点，触发后一个节点的通知</li></ul></li></ul><p><strong>延迟队列</strong></p><p>todo</p><p><strong>消息队列</strong>：</p><p>可以使用LIST、STREAMS对象实现简单的消息队列，但我们的系统中使用的是kafka</p><h2 id="2-缓存与数据库的数据不一致"><a href="#2-缓存与数据库的数据不一致" class="headerlink" title="2.缓存与数据库的数据不一致"></a>2.缓存与数据库的数据不一致</h2><ul><li>只读缓存<ul><li>更新缓存：缓存被更新后不一定会马上被利用，所以一是浪费内存，二是很多时候缓存中的值是根据数据库值计算得出，白白浪费了计算资源。<ul><li>先更新缓存，再更新数据库<ul><li>异常情况<ul><li>部分失败场景：数据库更新失败时，缓存与数据库的数据不一致，若后续没有办法识别这一情况，则数据永久丢失：增加重试机制，降低失败可能性</li><li>读写并发场景：对业务无影响</li><li>写写并发场景：由于并发导致缓存与数据库更新顺序不一致，造成数据不一致：分布式锁</li></ul></li></ul></li><li>先更新数据库，再更新缓存<ul><li>异常情况<ul><li>部分失败场景：缓存更新失败时，缓存与数据库的数据不一致，后续请求会直接命中缓存，得到旧值：增加重试机制，降低失败可能性</li><li>读写并发场景：对业务影响小，可以忽略</li><li>写写并发场景：由于并发导致缓存与数据库更新顺序不一致，造成数据不一致：分布式锁</li></ul></li></ul></li></ul></li><li>删除缓存<ul><li>先删除缓存，再更新数据库<ul><li>异常情况<ul><li>部分失败场景：数据库更新失败，导致下次访问缓存缺失：增加重试机制，降低失败可能性</li><li>读写并发场景：线程A先删除缓存，此时线程B访问缓存，发生缓存丢失，于是访问数据库，更新缓存为旧值，最后线程A再更新数据库为新值。发生缓存不一致：延迟双删机制不能从根本上解决问题，还是需要分布式锁</li><li>写写并发场景：对业务无影响</li></ul></li></ul></li><li>先更新数据库，再删除缓存：推荐<ul><li>异常情况<ul><li>部分失败场景：Redis更新失败，导致Redis与数据库数据不一致，下次访问到Redis中的旧值：增加重试机制，降低失败可能性</li><li>读写并发场景：线程A先更新数据库为新值，此时线程B访问缓存，得到旧值，最后线程A再删除缓存：对业务影响小，可以忽略</li><li>写写并发场景：对业务无影响</li></ul></li></ul></li></ul></li><li>综上所述：<ul><li>部分失败问题：增加重试机制，降低失败可能性。重试可以升级为异步重试，利用消息队列，提高消息的可靠性。异步重试又可以再一次升级为订阅数据库变更日志，放入MQ中，异步执行第二步操作，好处是应用程序主体不关心重试的动作。</li><li>缓存被旧值回写的问题：延迟双删，但延迟双删无论如何优化，都不能很好的把握延迟的时间，所以还是推荐“先更新数据库，再删除缓存”的策略</li><li>写写并发导致的缓存与数据库写顺序不一致问题：删除缓存策略对业务无影响。更新缓存策略，本质上需要并发控制，即通过分布式锁解决</li></ul></li></ul></li><li>读写缓存<ul><li>同步直写模式：Redis与数据库数据一致。应用程序需要保证写Redis和写数据库的原子性，异常情况与只读缓存差不多，但是此时需要保证写Redis与写数据库都成功，否则进行数据回滚，所以不存在上述问题。</li><li>异步写回模式：会发生数据丢失。Redis不适用这种模式</li></ul></li></ul><p>无论哪种模式，都需要给缓存数据设置合理的过期时间，防止错误数据长时间影响业务。如果要追求强一致性，引入分布式事务，那势必会影响性能，与缓存的初衷不符。</p><h2 id="6-缓存雪崩"><a href="#6-缓存雪崩" class="headerlink" title="6.缓存雪崩"></a>6.缓存雪崩</h2><p>缓存雪崩是指大量请求无法在缓存中处理，进而发送到数据库，导致数据库压力激增。原因：</p><ol><li>大量数据同时过期<ol><li>避免给大量数据设置相同的过期时间，可以增加小幅度的随机值</li><li>对非核心数据的请求可以服务降级</li><li>新上线的业务或数据</li></ol></li><li>缓存实例大量故障<ol><li>事前预防，利用主从复制机制、分片机制提高缓存系统可用性</li><li>服务熔断、限流，避免拖垮整个服务</li><li>数据预热</li></ol></li></ol><h2 id="7-缓存击穿"><a href="#7-缓存击穿" class="headerlink" title="7.缓存击穿"></a>7.缓存击穿</h2><p>缓存击穿是指针对某个访问非常频繁的热点数据，无法在缓存中进行处理，进而大量请求发送到数据库，导致数据库压力激增。原因：</p><ol><li>热点数据过期<ol><li>不设置过期时间</li></ol></li></ol><h2 id="8-缓存穿透"><a href="#8-缓存穿透" class="headerlink" title="8.缓存穿透"></a>8.缓存穿透</h2><p>缓存穿透是指要访问的数据既不在缓存中，也不在数据库，如此一来，缓存就成了摆设，并且每次请求都会访问缓存和数据库。</p><p>原因：</p><ol><li>业务层误操作</li><li>恶意访问没有的数据</li></ol><p>解决方案：</p><ol><li>设置缓存空值或缺省值</li><li>利用布隆过滤器做数据存在性检查</li><li>请求前置进行安全性、合法性检查</li></ol><h2 id="10-缓存无底洞"><a href="#10-缓存无底洞" class="headerlink" title="10.缓存无底洞"></a>10.缓存无底洞</h2><p>对于分片级群，范围查询或更新会涉及多个集群实例，有时候我们为了提升查询的效率，选择增加集群节点，反而使查询性能下降。</p><p>原因：</p><ol><li>多个实例的交互涉及多个网络I/O，客户端或中间件还需要管理并合并数据，增加实例后，会有更多的网络I/O，性能可能反而下降</li></ol><p>解决方案：</p><ol><li>尽量避免范围查询</li><li>经常用到的范围查询，其涉及的键想办法映射到少数几个固定节点上</li><li>优化连接的使用效率，使用长连接、连接池、NIO等技术</li></ol><h2 id="11-Redis为什么快"><a href="#11-Redis为什么快" class="headerlink" title="11.Redis为什么快"></a>11.Redis为什么快</h2><p>Redis可以达到微妙级别的请求处理速度，我们以请求的处理流程视角来分析这个问题：</p><ol><li>新版本的Redis客户端具有缓存功能，可以快速返回查询结果</li><li>新版本的Redis客户端使用RESP3协议，有利于服务器更快速地解析命令</li><li>Redis服务器采用Reactor模式的网络处理模型，可以高效的处理套接字请求，而不会导致服务器主进程被网络I/O阻塞</li><li>Redis是内存数据库，所有操作都在内存上完成，内存本身的访问速度很快。</li><li>Redis实现了很多高性能的数据结构，而处理Redis命令的底层就是操作这些数据结构。<ol><li>利用HashTable存储对象键值对，可以达到平均O(1)的时间复杂度</li></ol></li></ol><h2 id="12-Redis潜在的慢操作有哪些"><a href="#12-Redis潜在的慢操作有哪些" class="headerlink" title="12.Redis潜在的慢操作有哪些"></a>12.Redis潜在的慢操作有哪些</h2><p> 首先我们要知道如何判断Redis变慢了。我们可以测量低压力，无干扰情况下的系统基线性能，以此为依据，查看实际运行中的Redis响应速度，是否超出基线的两倍甚至更多。</p><p>然后介绍一些常见的拖慢Redis处理速度的原因：</p><ol><li>数据结构方面：<ol><li>利用HashTable存储对象键值对：<ol><li>当产生hash冲突时会降低本次的查询速度</li><li>rehash过程中，每处理一次请求，会将当前下标的链表迁移到备用桶上去，一定程度上降低了本次请求的速度</li></ol></li><li>范围操作比较耗时，如：HGETALL、SMEMBERS等，可以用SCAN系列的命令分批查询</li></ol></li><li>请求处理方面：<ol><li>处理请求<ol><li>Redis将套接字产生的文件事件放放入一个队列内，使用单线程依次处理。如果每个请求耗时较高，就会影响其后的所有命令处理。常见的耗时请求有：<ol><li>操作bigkey</li><li>复杂度较高的命令：集合全量查询和聚合操作</li><li>Redis采用惰性过期机制，是主线程处理请求时删除过期数据的。如果此时有大量过期数据，会有阻塞风险</li><li>主线程执行内存淘汰策略。如果写入请求时当前内存已经超过限制，那么就会进行内存淘汰，会有阻塞风险</li></ol></li><li>虽然Redis采用I/O多路复用技术，使得服务器可以同时监听多个套接字的事件，但是，依然是由主进程读写客户端数据。Redis6.0版本解决了这个问题。</li><li>操作系统内存不足导致内存置换</li></ol></li><li>磁盘<ol><li>AOF开启always机制，每次写入操作都会将其写进磁盘，而磁盘处理速度远远慢于内存处理速度，会降低命令执行速度。另外，AOF重写进程或者系统其他进程都会抢占磁盘I/O，从而阻塞AOF刷盘。</li><li>生成RDB文件，进行AOF重写虽然都是子进程负责，但是子进程是由主进程fork出来，而大内存会导致fork操作复制PCB阻塞</li><li>异步RDB、AOF重写都会fork子进程，此时会采用写时复制机制。若是开启了内存大页，那么写时复制就会拷贝很大的一块内存，影响主进程处理速度。</li></ol></li></ol></li></ol><h2 id="13-Redis为什么使用单线程"><a href="#13-Redis为什么使用单线程" class="headerlink" title="13.Redis为什么使用单线程"></a>13.Redis为什么使用单线程</h2><p>理论上，在资源分配合理的情况下，随着服务器线程数的增加，即处理请求操作的资源实体的增加，系统吞吐率也会随之增加。但实际上，一开始线程数增加确实会增加系统吞吐率，但逐渐往后，线程数与吞吐率并不是线性关系，吞吐率的增长会逐渐放缓甚至下降。一个关键原因是实际业务场景存在许多临界资源，他们需要被互斥访问，这就对提出了对临界资源访问控制的要求。一般我们的做法是加各种锁，但这会增加系统设计的复杂度。所以为了避免这些问题，Redis才用了单线程的模式。</p><p>另外，单线程的Redis依然具有很快的处理速度。（原因见1）。</p><h2 id="14-并发控制"><a href="#14-并发控制" class="headerlink" title="14. 并发控制"></a>14. 并发控制</h2><ol><li>串行处理</li><li>加锁</li><li>原子操作<ol><li>原子命令</li><li>lua脚本</li></ol></li><li>事务</li></ol><h2 id="15-事务及ACID属性的支持"><a href="#15-事务及ACID属性的支持" class="headerlink" title="15.事务及ACID属性的支持"></a>15.事务及ACID属性的支持</h2><p>Redis如何实现事务：</p><ol><li>MULTI显式开启事务</li><li>输入命令，缓存在事务队列中，暂不执行</li><li>EXEC执行事务队列中的所有命令</li><li>DISCARD放弃事务，清空事务队列</li></ol><p>WATCH机制：在事务执行前，监控一个或多个键的变化情况，当执行EXEC命令时，会校验这些被监控的键有没有被修改，若被修改过，就放弃执行事务。</p><p>另外，可以配合使用pipeline，在客户端缓存完整地事务队列，一次性发送给Redis，减少网络I/O，减少产生冲突的可能性。</p><p>ACID属性的支持：</p><ol><li>原子性：事务中的操作要么全做，要么全不做<ol><li>命令入队时就报错，保证原子性</li><li>命令执行时报错，不保证原子性</li><li>EXEC命令执行时实例崩溃，开启了AOF日志，保证原子性</li><li>EXEC命令执行时实例崩溃，没有开启AOF日志，不保证原子性</li></ol></li><li>一致性：事务的执行使数据库从一个一致性状态转移到另一个一致性状态<ol><li>命令入队时就报错，保证一致性</li><li>命令执行时报错，保证一致性</li><li>EXEC命令执行时实例崩溃，开启了RDB或AOF日志，保证一致性</li><li>EXEC命令执行时实例崩溃，没有开启AOF日志，保证一致性</li></ol></li><li>隔离性：并发执行的事务之间互不影响<ol><li>EXEC命令执行前，开启WATCH机制，保证隔离性</li><li>EXEC命令执行前，没有开启WATCH机制，不保证隔离性</li><li>EXEC命令执行后，保证隔离性</li></ol></li><li>永久性：事务对数据库的修改一旦提交，其影响是永久保留的<ol><li>无论采用何种持久化机制，都无法保证永久性</li></ol></li></ol><h1 id="数据类型与数据结构"><a href="#数据类型与数据结构" class="headerlink" title="数据类型与数据结构"></a>数据类型与数据结构</h1><h2 id="1-Redis有哪些数据类型及底层数据结构"><a href="#1-Redis有哪些数据类型及底层数据结构" class="headerlink" title="1.Redis有哪些数据类型及底层数据结构"></a>1.Redis有哪些数据类型及底层数据结构</h2><p>我学习、使用过的Redis数据类型分为四大类：</p><ol><li>基本数据类型<ol><li>字符串对象string<ol><li>常用命令：GET、SET、INCR、DECR</li><li>底层数据结构：sds，有不同编码格式：整数int、浮点数或小字符串embstr、大字符串raw</li></ol></li><li>列表对象list<ol><li>常用命令：LPUSH、LPOP、RPUSH、RPOP</li><li>底层数据结构：元素个数少或元素总长元素度小时用ziplist、否则用linkedlist</li></ol></li><li>哈希对象hash<ol><li>常用命令：HSET、HGET、HDEL、HEXISTS</li><li>底层数据结构：元素个数少或元素总长度小时用ziplist、否则用hashtable</li></ol></li><li>集合对象set<ol><li>常用命令：SADD、SPOP</li><li>底层数据结构：元素个数少或元素总长度小时用intset、否则用hashtable</li></ol></li><li>有序集合对象zset<ol><li>常用命令：ZADD、ZREM、ZRANGE</li><li>底层数据结构：元素个数少或元素总长度小时用ziplist、否则用skiplist</li><li>score相同，使用字典序，升序排列</li></ol></li></ol></li><li>Redis 拓展数据类型<ol><li>位图BitMap，底层用SDS字符串实现，利用其二进制安全的特性，使用每一个比特位存储二值状态数据。常见命令有：SETBIT、GETBIT、BITCOUNT（利用SWAR算法快速计算）、BITOP（AND、OR、NOT、XOR）</li><li>布隆过滤器BloomFilter：利用位图和多个hash函数，辅助判断元素是否已经存在。存在误判率。当布隆过滤器判断存在时，可能由于其他元素将当前元素的所有位都置为了1，所以会误判。但是判断不存在不会出现误判。</li><li>HyperLogLog：利用HyperLogLog算法进行基数统计。常见命令有：PFADD、PFCOUNT</li><li>GEO：主要用于存储地理位置信息。<ul><li>GEOHash编码：由于经纬度范围[-180, 180]，所以可以利用二分查找，将经纬度信息转换为二分查找的搜索路径的二进制编码，再将经纬度各自的二进制编码进行整合（经度编码全部放在偶数位，纬度编码全部放在奇数位），就将其映射成了一维空间上的连续编码，方便我们利用zset查询相邻地理位置。</li></ul></li><li>Streams：消息队列，实现基本的消息保存与消费，阻塞读取，生成消息唯一ID供幂等消费，保障消息可靠性</li></ol></li><li>自定义数据类型及数据结构</li></ol><p>Redis 底层数据类型有：</p><ol><li>简单动态字符串SDS，其特点有：<ol><li>记录了字符串未使用长度和已使用长度，可以在O(1)时间内得到字符串的这些长度值</li><li>随着字符串内容长度的变化，动态进行空间的重新分配，保证不会出现字符串内容溢出。具体策略是：<ol><li>字符串增长时<ul><li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li><li>当修改后的SDS长度小于1MB时，申请空间大小为当前空间的两倍，否则申请空间大小为当前空间大小再加1MB</li></ul></li><li>字符串减短时<ul><li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li></ul></li></ol></li><li>二进制安全</li><li>依然以’\0’结尾，可以直接使用C语言的字符串代码库</li></ol></li><li>老版本的双向链表LinkedList，目前已经被快速链表QuickList代替</li><li>字典HashTable<ol><li>其插入数据的过程是：<ol><li>利用hash函数获取key对应的hash值，对其进行二进制取模 &amp;(size-1)获取桶下标</li><li>将键值对对象添加进桶对应的链表内（头插法），即Redis用拉链法解决hash冲突</li></ol></li><li>当桶负载因子过大或者过小时，会进行rehash操作：<ol><li>为备用桶分配内存空间：扩大时分配第一个大于等于已使用空间*2的2^n，缩小时分配第一个大于等于已使用空间的2^n</li><li>伴随每次客户请求，除了正常处理请求外，还会将当前迁移下标链表内的所有键值对全部迁移到备用桶上面去，完成后迁移下标+1。迁移过程中，新插入的数据都会直接在备用桶完成，查询操作会先查当前桶，再查备用桶 </li><li>所有数据全部迁移完成后，将备用桶升级为当前桶，删除并释放当前桶的内存空间</li></ol></li></ol></li><li>跳表SkipList： 是一个多层级的单链表结构，其元素按照score从小到大的顺序，从前往后顺序排列，每个元素都会从第0层开始，有一定概率被连续分配到多个层级，层级越往上被分配的概率越小。如此一来，我们可以将高层链表看作低层链表的索引，从高往低快速检索数据。插入元素流程：<ol><li>利用随机函数，获取当前元素的层高（Redis每层概率0.25）</li><li>从元素的最高层开始（没有链表就新建一个），利用大小关系检索score，并将元素插入到本层的适当位置</li><li>上一层插入完成后转入下一层，一次完成插入，直到第0层完成</li></ol></li><li>整数集合IntSet。存储整数元素的数组，特点是：<ol><li>灵活：支持不同类型的整数</li><li>节约内存：定义了多种编码，并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li><li>一旦编码升级，就不会降级了</li></ol></li><li>压缩列表ZipList。已经被ListPack替代。<ol><li>优点<ul><li>节省空间</li></ul></li><li>缺点<ul><li>因为需要遍历访问，不适合保存过多元素</li><li>由于每个元素需要保存前一个节点的长度，根据前一个元素的长度大小，可能会占用1B或5B不定。当元素更新时，因为可能会引发连锁更新，所以不适合保存过大元素</li></ul></li></ol></li><li>快速链表QuickList。简单说，快速链表=双向链表+压缩列表，即双向链表的每个节点是一个压缩列表。这么做的目的是在获得压缩列表节约空间的好处同时，解决压缩列表无法存储过多元素的问题，并且控制了连锁更新的范围。</li><li>紧凑链表ListPack。本质上说，quickList并没有从根本上解决zipList连锁更新的问题，他只是将连锁更新的范围控制在一个节点内。并且，链表指针也会消耗内存空间，这不符合压缩列表的初衷。因此，紧凑链表ListPack重新设计了编码规范，元素不再存储前一个节点的大小，从根本上解决了连锁更新的问题。</li></ol><h1 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h1><h2 id="1-Redis-I-O网络模型"><a href="#1-Redis-I-O网络模型" class="headerlink" title="1.Redis I/O网络模型"></a>1.Redis I/O网络模型</h2><p>一般，我们处理一个请求会有以下几个阶段：</p><ol><li>监听客户端请求 listen</li><li>和客户端建立连接 accept</li><li>接收并客户端请求 recv</li><li>解析客户端请求 parse</li><li>处理客户端请求 process</li><li>客户端返回结果，即向socket写回数据 send</li></ol><p>Redis正是基于事件的回调机制，可以针对不同事件的发生，调用相应的处理函数，监听了多个套接字。</p><p>首先我们要知道，Redis服务器主进程就是一个事件循环处理函数，依次处理文件事件与时间事件，而文件事件指的就是接收客户端的命令请求，以及向客户端发送命令回复。Redis的文件事件处理器由四部分组成：套接字、I/O多路复用程序、文件事件分派器、文件事件处理器：</p><ul><li>套接字<ul><li>文件事件是对套接字操作的抽象。每当一个套接字准备好执行链接应答、写入、读取、关闭等操作时，就会产生一个文件事件。</li></ul></li><li>I/O多路复用程序<ul><li>基于操作系统提供的select/epoll机制，同时监听多个套接字，既实现了高性能的网络通信模型，又可以很好地与Redis服务器中同样以单线程运行的模块对接。</li><li>尽管由于服务器连接的多个套接字会并发地产生文件事件，但I/O多路复用程序总是会将所有产生事件的套接字，按照先后顺序、同步、每次一个的方案依次加入队列中，然后将套接字传送给文件事件分派器。只有当上一个套接字产生的事件被处理完毕后，I/O多路复用程序才会向文件事件分派器传送下一个套接字。</li></ul></li><li>文件事件分派器<ul><li>接收I/O多路复用程序传送来的套接字，根据套接字产生的事件的类型，为其关联不同的事件处理器进行处理。</li><li>文件事件类型：<ul><li>AE_READABLE：当套接字变得可读时（客户端对套接字执行connect、write、close操作），套接字产生AE_READABLE事件</li><li>AE_WRITABLE：当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件</li><li>当一个套接字同时产生AE_READABLE、AE_WRITABLE两类事件时，服务器会先处理AE_READABLE事件，再处理AE_WRITABLE事件。</li></ul></li></ul></li><li>文件事件处理器<ul><li>执行实际的处理动作。</li><li>分类：<ul><li>连接应答处理器：当服务器初始化的时候，会降<strong>服务器监听套接字的AE_READABLE事件</strong>与连接应答处理器关联起来。当有客户端连接服务器监听套接字时，套接字就会产生AE_READABLE事件，从而引发连接应答处理器的执行，并执行相应的套接字应答操作。</li><li>命令请求处理器：当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将<strong>客户端套接字的AE_READABLE事件</strong>和命令请求处理器关联起来。当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，从而引发命令请求处理器的执行，并执行相应的套接字读取操作。</li><li>命令回复处理器：当服务器有命令回复需要传输给客户端的时候，服务器会将<strong>客户端套接字的AE_WRITABLE事件</strong>和命令响应处理器关联起来。当客户端准备好接收服务器的命令回复的时候，套接字就会产生AE_WRITABLE事件，从而引发命令回复处理器的执行，并执行相应的套接字写入操作。</li><li>其他</li></ul></li></ul></li></ul><p>我们讲一次完整的客户端与服务器的交互过程：</p><ol><li>假设Redis服务器已经启动完成，那么此时服务器监听套接字的AE_READABLE事件会与连接应答处理器关联起来，并处于监听状态。</li><li>客户端向服务器发起建立 socket 连接的请求，监听套接字会产生AE_READABLE事件，触发连接应答处理器执行。连接应答处理器会对客户端的连接请求进行应答，创建客户端套接字及客户端状态，并将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，并处于监听状态。</li><li>客户端建立连接后，向服务器发送命令，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行。命令请求处理器读取客户端命令，然后传递给相关程序去执行。</li><li>执行命令获得相应的命令回复后，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器执行。命令回复处理器将命令回复全部写入到套接字中后，就会解除客户端套接字的 AE_WRITEABLE 事件与命令回复处理器的关联。</li><li>命令回复会由套接字负责传输给客户端。</li></ol><h2 id="2-Redis6-0版本引入的多线程模型"><a href="#2-Redis6-0版本引入的多线程模型" class="headerlink" title="2.Redis6.0版本引入的多线程模型"></a>2.Redis6.0版本引入的多线程模型</h2><h1 id="持久化和内存"><a href="#持久化和内存" class="headerlink" title="持久化和内存"></a>持久化和内存</h1><h2 id="1-持久化机制都有哪些？各自的优缺点？如何使用？"><a href="#1-持久化机制都有哪些？各自的优缺点？如何使用？" class="headerlink" title="1.持久化机制都有哪些？各自的优缺点？如何使用？"></a>1.持久化机制都有哪些？各自的优缺点？如何使用？</h2><p>由于Redis是内存数据库，所以一旦服务器宕机，那么内存中的数据将会全部丢失。因此，Redis实现了RDB快照和AOF日志两类数据持久化机制：</p><ul><li><p>RDB快照</p><ul><li>作用是将服务器某个时刻的完整状态保存到磁盘中。save命令由主线程执行持久化，会阻塞主线程处理命令，此时数据不会被修改，可以正常进行快照持久化。bgsave命令会fork出子进程，主进程继续处理命令，子进程负责持久化。由于写时复制的原因，主进程在处理写命令时，会复制一份数据修改，不会影响子进程的快照持久化。我们可以配置多个save选项（服务器在x秒之内，对数据库至少进行了y次修改），服务器会定期检查，其中有一个选项被满足，就会触发RDB持久化。</li><li>优点<ul><li>保证了数据可靠性</li><li>数据恢复速度快</li><li>bgsave命令可以创建子进程执行持久化</li><li>RDB文件的内容为二进制的数据，占用内存更小，更紧凑，可以更快的传输到远程服务器进行服务恢复，更适合做为备份文件。压缩后更是如此。</li></ul></li><li>缺点<ul><li>因为RDB文件只能保存某个时间间隔的数据，如果中途服务被意外终止了，则会丢失一段时间内的数据</li><li>save命令由主线程执行持久化，会阻塞主线程处理命令</li><li>bgsave命令的子进程是由主进程fork出来，而大内存会导致fork操作复制PCB阻塞</li></ul></li></ul></li><li><p>AOF日志</p><ul><li><p>AOF日志就是命令执行记录，类似于Mysql的binlog。但不同于Mysql的WAL写前日志模式，AOF是写后日志模式，即写命令先执行，再追加到AOF文件末尾。之所以如此，一是因为可以保证记录到AOF文件内的命令都是正确的，在数据恢复时不会出错。二是为了加快主线程执行命令的速度，在命令执行完成再将AOF写入缓冲区，等待合适的时机落到磁盘。AOF持久化有三个步骤：命令追加到内存缓冲区、将缓冲区命令同步到内存AOF文件末尾、将内存AOF文件同步到磁盘。</p></li><li><p>AOF有三种写回策略</p><ul><li>always：由主进程立即将aofBuf缓冲区内的所有数据写入内存AOF文件，并同步到磁盘AOF文件。</li><li>everysec：将aofBuf缓冲区内的所有数据写入内存AOF文件，如果上次文件同步距今时间已超过一秒，那么由子线程负责将内存AOF文件同步到磁盘AOF文件中。</li><li>no：将aofBuf缓冲区内的所有数据写入内存AOF文件，何时将内存AOF文件同步到磁盘AOF文件中，以及具体操作，均由操作系统决定并执行，Redis服务器什么也不做。</li></ul></li><li><p>AOF重写：随着服务器不断执行接收到的一条条写命令，AOF文件的内容会越来越多，还包含了大量的冗余指令。AOF重写的原理就是，通过特定指令读取数据库当前状态，以替换原有的AOF文件，达到最小化AOF文件的效果。为了不让AOF这类日志操作影响正常的命令处理，Redis将AOF重写功能交由子进程执行，这样做的好处是：</p><ul><li>子进程处理AOF重写期间，主进程还可以继续响应命令</li><li>由于fork会写时复制父进程的当前数据，所以避免了父子进程的数据访问冲突，即在不加锁的情况下保证了数据安全</li></ul><p>如果父进程在AOF期间修改了数据，那么对子进程是不可见的，即产生了数据的不一致性。解决方案是，在AOF重写时，会在主进程设置一个AOF重写缓冲区，专门记录子进程运行期间产生的不可见的数据更改。此时服务器会将命令写入AOF缓冲区和AOF重写缓冲区。当子进程处理完重写操作，生成好了新的AOF文件时，会发送一个信号给父进程，父进程在接收到这个信号后，会阻塞命令处理，并将AOF重写缓冲区内的命令追加到新AOF文件末尾，最后替代现有AOF文件，就完成了整个AOF 会重写操作。</p></li><li><p>AOF缓冲区和AOF重写缓冲区的区别：</p><ul><li>目的不同。AOF缓冲区的目的是伴随着命令的处理，不断地追加AOF文件的。AOF重写缓冲区的目的是解决子进程AOF重写期间造成的数据不一致。</li><li>使用方式不同。前文说过，AOF缓冲区会根据具体策略，选择不同时机写入磁盘。AOF重写缓冲区是在子进程处理完成后，一次性追加到新的AOF文件末尾的。</li><li>“内容不一致”。AOF缓冲区会根据策略选择不同时机写入磁盘，意味着有可能出现缓冲区内容不断变化。AOF重写缓冲区，他的职责是记录所有子进程处理期间的命令，不会发生上述情况。</li></ul></li><li><p>优点</p><ul><li>保证了数据可靠性</li><li>每次持久化的数据量不大</li></ul></li><li><p>缺点</p><ul><li>无论何种写回策略，都有一定的命令丢失风险</li><li>always策略也会阻塞主进程</li><li>如果AOF重写不合理，那么会导致AOF文件过大，数据恢复速度慢</li><li>AOF重写子进程是由主进程fork出来，而大内存会导致fork操作复制PCB阻塞</li><li>由于父子进程写时复制的原因，在AOF重写期间，主进程处理bigkey需要重新申请内存空间，存在阻塞风险</li><li>完全使用AOF日志，一条一条命令地恢复数据，会比较慢</li></ul></li><li><p>Redis4.0提供了混合使用RDB和AOF的功能，即使用RDB快照做全量备份，使用AOF日志做增量备份</p></li></ul></li></ul><h2 id="2-过期机制"><a href="#2-过期机制" class="headerlink" title="2.过期机制"></a>2.过期机制</h2><p>删除策略有以下三种：</p><ul><li>定时删除（Redis未采用）<ul><li>在设置键的过期时间的同时，同时设置一个定时器，到了指定时间时间时，定时器会立即执行对键的删除操作。</li></ul></li><li>惰性删除<ul><li>放任过期键不理会，但是每当服务器处理键的查询命令时，都会先判断该键是否已经过期。如果已经过期，则删除该键，返回空或报错；如果没有过期，则执行正常查询命令。</li><li>极端情况下，可能出现无用数据占用大量内存的情况。</li><li>最节省CPU，只有在过期键真正需要被删除的时候才会执行删除操作。</li></ul></li><li>定期删除<ul><li>每隔一段时间，就检查数据库，删除其中过期的数据。至于要隔多久检查、每次检查多少数据，都可以配置。</li><li>相对节省内存</li><li>可以通过控制执行周期间隔和每次执行的规模来决定对于内存和CPU的影响</li></ul></li></ul><p>RDB对于过期键的处理：</p><ul><li><p>生成RDB文件时，不会保存已经过期了的键到RDB文件</p></li><li><p>载入RDB文件时：</p><ul><li><p>对于主服务器，程序会对RDB文件中的键进行检查，已经过期的键不会载入到数据库中。</p></li><li><p>对于从服务器，RDB文件保存的所有数据，不论是否已经过期，都会载入到数据库中。旧版本从库对于过期数据直接返回，不会惰性删除。旧版本从库对于过期数据返回空值，也不会惰性删除</p></li></ul></li></ul><p>AOF对于过期键的处理：</p><ul><li><p>写入AOF文件时，如果某个键已经过期，但是它还没有被删除，那么依然会像处理未过期的键一样，将其写入到AOF文件中。随后当这个键被服务器删除时，会追加一条针对这个键的删除操作到AOF文件。之所以这样。是因为可以在不会影响AOF文件所表达出的数据库状态的情况下，保持AOF写入原则，忠实地记录写命令的执行情况。</p></li><li><p>AOF重写时，程序会对服务器的键进行检查，已经过期的键不会保存到重写后的AOF文件中。对于AOF重写，它所想要的效果是用最少的命令表达当前数据库的状态，很显然就不需要写入过期键到AOF重写文件内了。</p></li></ul><h2 id="3-内存淘汰策略"><a href="#3-内存淘汰策略" class="headerlink" title="3.内存淘汰策略"></a>3.内存淘汰策略</h2><p><strong>淘汰策略分类</strong>：</p><ul><li>不进行数据淘汰：一旦缓存被写满，再有写请求进来时，不再提供服务，直接返回错误</li><li>进行数据淘汰<ul><li>只对设置了过期时间的数据进行淘汰<ul><li>valatile-ttl：根据设置的过期时间，越早过期的数据先被删除</li><li>valatile-random：随机选择</li><li>valatile-lru</li><li>valatile-lfu</li></ul></li><li>对所有数据进行淘汰<ul><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ul></li></ul></li></ul><p><strong>简单介绍LRU算法</strong>：</p><p>最近最少使用，即将内存中最近未被使用的数据删除。由于传统LRU算法需要维护链表，会带来额外的空间开销，所以Redis简化了LRU算法的实现。Redis会维护每个键的lru时间，即最近一次访问时间。第一次决定要淘汰数据时，会随机挑选出N个数据，利用他们的lru字段做lru算法，将lru最小的数据淘汰出去。当需要再次决定淘汰数据时，会挑选小于集合中最小lru的数据进入集合，然后再将lru最小的数据淘汰出去。</p><p><strong>简单介绍LFU算法</strong>：</p><p>由于LRU算法只考虑数据最近一次访问时间，当有大量数据作扫描式单词查询操作时，由于这些数据刚刚被访问过，所以他们的lru时间戳都很大，但是他们之后肯定不会被再次访问，就造成了缓存污染。为了应对此类问题，引入了LFU算法。</p><p>Redis实现的LFU基于LRU，利用键lru字段后8位记录访问次数，在淘汰数据时，先将访问次数小的淘汰出去，如果访问次数相同，再将最后一次访问时间早的淘汰出去。为了避免8位的访问次数很快被记满，一是采用非线性递增的方式增加访问次数，二是未被访问的数据，其访问次数会根据时间进行衰减。</p><p><strong>如何选择淘汰策略</strong>：</p><ol><li>根据是否有始终会被频繁访问（置顶数据）决定淘汰数据的数据集</li><li>优先建议使用lru</li><li>如果业务数据的访问频率区别不大，没有明显的冷热数据之分，建议选择random</li></ol><h2 id="4-内存碎片"><a href="#4-内存碎片" class="headerlink" title="4.内存碎片"></a>4.内存碎片</h2><p>内存碎片指的是操作系统内存中存在一些不连续的、大小不一的、无法被有效利用的空闲空间。</p><p>Redis形成内存碎片的原因有：</p><ul><li>内因：操作系统自身的内存管理策略</li><li>外因：Redis自身的负载特征<ul><li>键值对本身大小不一</li><li>键值对会被修改或删除</li></ul></li></ul><p>解决方案就是内存自动清理机制，可以根据内存碎片大小或比例自动开启清理，并设置清理占用的CPU比例自动停止清理，以避免长时间阻塞主进程</p><h2 id="5-缓冲区"><a href="#5-缓冲区" class="headerlink" title="5.缓冲区"></a>5.缓冲区</h2><p>Redis缓冲区类型：</p><ul><li>客户端与服务端<ul><li>输入缓冲区</li><li>输出缓冲区</li></ul></li><li>主从库<ul><li>复制缓冲区（等同于客户端的输出缓冲区）</li><li>复制积压缓冲区</li></ul></li><li>持久化<ul><li>AOF缓冲区</li><li>AOF重写缓冲区</li></ul></li></ul><p>缓冲区溢出原因及解决方案：</p><ul><li>命令发送过快过大<ul><li>普通客户端<ul><li>避免bigkey</li></ul></li><li>复制缓冲区<ul><li>避免主库过大，产生过大的RDB文件</li></ul></li></ul></li><li>命令处理过慢<ul><li>减少阻塞主进程的操作</li></ul></li><li>缓冲区空间过小<ul><li>配置合理缓冲区大小</li></ul></li></ul><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="1-主从模型"><a href="#1-主从模型" class="headerlink" title="1.主从模型"></a>1.主从模型</h2><p>Redis通过读写分离的主从模式，增加了数据的冗余副本，保证了服务可靠性。一个主库会有多个从库。读命令主、从库都可以处理，写命令只能主库处理，处理完成后再将其同步给各个从库。</p><p>主从复制功能的实现，分为三个阶段：</p><ul><li><p>建立连接，协商同步</p></li><li><p>同步：用于将从库状态更新至主库当前状态</p><ul><li>全量同步<ul><li>过程：主库通过BGSAVE命令，使用子进程生成RDB文件，并在此过程中使用复制缓冲区记录从现在开始执行的所有写命令。之后将这个RDB文件传输给从库，从库接收到文件后，先清理自己的所有服务器状态，然后载入RDB文件，将自己的状态更新至主库的RDB文件状态。从库载入完RDB文件后，主库进入阻塞，将自己复制缓冲区内的所有写命令传输给从库，从库应用这些命令后，主从库的状态就完全一致了。</li><li>使用场景：从库初次复制主库、从库改变复制的主库</li></ul></li><li>增量同步<ul><li>过程：主库进行命令传播期间，不仅会将写命令发送给所有从库，还会将其保存在一个先进先出的环形的复制积压缓冲区内。从库断线重连主库后，会发送自己之前的复制偏移量给主库，主库判断该偏移量是否存在于复制积压缓冲区内，若存在，则将该偏移量之后的写命令同步给从库，否则进行全量同步</li><li>使用场景：主从库因为网络问题断线一段时间，恢复连接后，继续复制主库</li></ul></li></ul></li><li><p>命令传播</p><ul><li>目的：当主库状态被修改，导致主从库状态不一致时，让主从库的状态重新回到一致状态。</li><li>过程：主库接收到写命令后，不仅执行命令响应客户端，还会将命令发送给从库，从库应用这条命令使主从库状态恢复一致</li></ul></li></ul><h2 id="2-为什么采用读写分离的方式"><a href="#2-为什么采用读写分离的方式" class="headerlink" title="2.为什么采用读写分离的方式"></a>2.为什么采用读写分离的方式</h2><p>如果各从库都能处理写命令，那么由于数据同步的延迟性，会导致针对同一数据各库之间的状态不一致。如果非要保持多个库数据的一致性，要么放弃一部分数据，以某一个版本为准，要么在各实例间加锁，增加复杂性和性能开销。而只有主库负责写命令就没有这些问题。</p><h2 id="3-全量同步的缺点"><a href="#3-全量同步的缺点" class="headerlink" title="3.全量同步的缺点"></a>3.全量同步的缺点</h2><ol><li>BGSAVE的fork操作可能会阻塞主进程</li><li>BGSAVE会耗费大量CPU、内存、磁盘I/O</li><li>主库将RDB文件传输给从库，会耗费大量网络资源</li><li>从库接收并载入RDB文件期间无法处理请求</li></ol><p>解决方法：主-从-从模式，减少单一主库的复制压力，将其分散到多个从库上面去。</p><h2 id="4-如何避免增量复制退化为全量复制"><a href="#4-如何避免增量复制退化为全量复制" class="headerlink" title="4.如何避免增量复制退化为全量复制"></a>4.如何避免增量复制退化为全量复制</h2><ol><li>设置合理的复制积压缓冲区大小，其与主库的写命令速度、大小，主从库之间的网络传输速度有关</li><li>使用切片集群分担单一主库的写操作压力</li></ol><h2 id="5-复制时检测命令丢失"><a href="#5-复制时检测命令丢失" class="headerlink" title="5.复制时检测命令丢失"></a>5.复制时检测命令丢失</h2><p>主库根据从库返回的命令偏移量，判断是否有命令丢失，并将这些命令重新传播给从库。其过程与增量同步一致，但区别在于此时没有发生从库的断线重连。</p><h2 id="6-为什么不使用AOF文件进行复制"><a href="#6-为什么不使用AOF文件进行复制" class="headerlink" title="6.为什么不使用AOF文件进行复制"></a>6.为什么不使用AOF文件进行复制</h2><ol><li>RDB文件是经过压缩的二进制文件，而AOF文件是写命令的文本文件，所以RDB文件的恢复速度比AOF文件快<ol><li>传输效率</li><li>从库的解析加载效率</li></ol></li><li>假设使用AOF做全量同步，需要打开AOF功能，若策略不当会增加刷盘的可能性。而RDB文件只有在定时备份或全量同步时才会生成RDB文件。所以在对丢失数据不敏感的场景，不需要开启AOF功能，也就更不必为了数据复制开启了。</li></ol><h2 id="7-复制缓冲区和复制积压缓冲区的区别"><a href="#7-复制缓冲区和复制积压缓冲区的区别" class="headerlink" title="7.复制缓冲区和复制积压缓冲区的区别"></a>7.复制缓冲区和复制积压缓冲区的区别</h2><p>作用不同。</p><p>复制缓冲区replication buffer其实就是命令发送的写缓冲区，所有客户端发送命令时都会有这个缓冲区，只不过此时是专门用于命令传播的，所以起了这个名字。</p><p>复制积压缓冲区是为了解决命令丢失或做增量同步的。</p><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><h2 id="1-哨兵机制"><a href="#1-哨兵机制" class="headerlink" title="1.哨兵机制"></a>1.哨兵机制</h2><p>由于Redis采用主从库的读写分离模式，所以一旦主库挂掉，那么集群将无法对外提供写服务，并且从库也无法进行数据同步，这是无法接受的。因此有了哨兵机制，用于监控任意数量的主库，以及其下的所有从库，实现主从库自动切换机制。其功能有：</p><ol><li>监控：判断主库是否下线</li><li>选主：选择从库称为新主库</li><li>通知：把新主库通知给旧主库、其他从库和客户端</li></ol><h2 id="2-哨兵集群的组建方式"><a href="#2-哨兵集群的组建方式" class="headerlink" title="2.哨兵集群的组建方式"></a>2.哨兵集群的组建方式</h2><p>哨兵实例之间通过发布/订阅机制，可以自动互相发现，从而组成哨兵集群。具体说就是所有哨兵实例都会订阅主库的哨兵频道，就可以获得其他哨兵发布的消息。并且，哨兵在和主库建立连接后，就会在该频道上发布自己的位置信息，供其他哨兵实例知晓。</p><p>哨兵通过向主库发送INFO命令，获取从库列表，从而建立起和所有从库的连接。</p><p>哨兵本质上是一个特殊的Redis进程，也对外提供发布/订阅机制。所以，客户端可以通过哨兵配置文件，和哨兵实例建立连接，从而订阅相关频道，获取主从切换的关键事件通知。</p><h2 id="3-监控"><a href="#3-监控" class="headerlink" title="3.监控"></a>3.监控</h2><ol><li>主观下线：哨兵进程会通过PING命令来监控他自己和主、从库的网络连接情况，若PING命令超时，则将该实例标记为主观下线。如果是从库主观下线，直接标记就行。如果是主库主观下线，哨兵还不能进行选主，因为他自己和主库的网络问题不能说明主库在整个网络中的健康情况。</li><li>客观下线：某个哨兵实例判断主库主观下线后，会向其他哨兵实例发送命令，用于获取其他实例对主库的下线判断情况，当前哨兵统计其他实例的响应情况，判断下线数量是否大于等于阈值，若大于，则将主库标记为客观下线。阈值的一般原则是集群的大多数。</li></ol><h2 id="4-选举哨兵代理人"><a href="#4-选举哨兵代理人" class="headerlink" title="4.选举哨兵代理人"></a>4.选举哨兵代理人</h2><p>选举原则：</p><ul><li>当某个哨兵实例将主库标记为客观下线后，会向其他实例发送选举命令，请求为自己投票。若当前实例在本纪元没有为其他实例投过票，则会为自己投上一票</li><li>每轮新发起的投票，不论选举是否成功，都会将纪元+1</li><li>每个实例在每个纪元只能给一个实例投票</li><li>实例接收到投票响应后，会判断纪元是否一致，一致才会采用投票结果</li><li>获得半数以上赞成票，并且大于等于阈值的实例，称为哨兵首领，由他主持接下来的主从切换任务</li><li>若当前纪元没有实例成为首领，则每个实例都会等待随机时间后发起新一轮的选举</li></ul><h2 id="4-选主"><a href="#4-选主" class="headerlink" title="4.选主"></a>4.选主</h2><p>遍历首领哨兵实例的从库列表：</p><ol><li><p>筛选：把不符合条件的从库去掉</p><ol><li>正常在线：处于下线或断线状态的从库</li><li>通信状态良好：最近5秒内没有回复过首领哨兵INFO命令的从库</li><li>数据较新：与已下线主库连接断开超过 判断主观下线时间*10 的从库</li></ol></li><li><p>打分：选择得分最高的从库作为新主库</p><ol><li>配置的优先级最高</li><li>复制偏移量最大</li><li>id最小</li></ol></li></ol><h2 id="5-通知"><a href="#5-通知" class="headerlink" title="5.通知"></a>5.通知</h2><ul><li>向新主库发SLAVEOF命令，修改其为主库</li><li>向已下线主库的所有从库发送SLAVEOF命令，修改其主库为新选择的主库</li><li>监控旧主库，当旧主库重新上线时，向其发送SLAVEOF命令，成为新主库的从库</li></ul><h2 id="6-主从切换过程中，集群可以提供服务吗"><a href="#6-主从切换过程中，集群可以提供服务吗" class="headerlink" title="6.主从切换过程中，集群可以提供服务吗"></a>6.主从切换过程中，集群可以提供服务吗</h2><p>从切换过程中，集群能正常处理读请求，但是不能处理写请求。对于写延迟不敏感的业务，为了不让业务感受到异常，可以在客户端或者中间件缓存写请求，等新库上线后再将写请求发送过去。</p><h2 id="7-客户端应该如何获取主库地址"><a href="#7-客户端应该如何获取主库地址" class="headerlink" title="7.客户端应该如何获取主库地址"></a>7.客户端应该如何获取主库地址</h2><ol><li>不要写死主库地址</li><li>推：通过订阅哨兵的频道，被动等待通知</li><li>拉：主动从哨兵处获取当前主库的地址</li></ol><h2 id="8-哨兵实例是不是越多越好"><a href="#8-哨兵实例是不是越多越好" class="headerlink" title="8.哨兵实例是不是越多越好"></a>8.哨兵实例是不是越多越好</h2><p>不是。哨兵实例越多，误判率越低。但是哨兵在判断客观下线和选举时，都需要与其他哨兵通信并协商，若哨兵实例越多，则这些过程所需通信越多，达成一致的时间可能越久。从而主从切换的时间会变长，客户端容易请求缓冲溢出，造成请求丢失。另外，若客户端对命令响应时间有要求，会造成超时报错。</p><h1 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h1><h2 id="为什么要使用分片集群"><a href="#为什么要使用分片集群" class="headerlink" title="为什么要使用分片集群"></a>为什么要使用分片集群</h2><p>为了应对大数据存储导致的性能问题，可以采用两种拓展方法：</p><ul><li>纵向拓展：升级单实例配置<ul><li>优点<ul><li>简单直接</li></ul></li><li>缺点<ul><li>单实例内存过大时，数据持久化过程中的fork操作会阻塞较长时间</li><li>受到硬件和成本限制</li></ul></li></ul></li><li>横向拓展<ul><li>优点<ul><li>拓展性好</li><li>成本低</li></ul></li><li>缺点<ul><li>集群管理复杂</li></ul></li></ul></li></ul><h2 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h2><p>Redis Cluster定义了16384个哈希槽，并将集群的每一个数据映射到其中的某一个槽上，即持有该槽的实例保存该槽对应的所有数据。</p><p>在创建集群时，可以根据各实例的实际资源情况，通过ADDSLOTS命令，分配一个或多个槽给某个实例。</p><h2 id="处理客户端请求"><a href="#处理客户端请求" class="headerlink" title="处理客户端请求"></a>处理客户端请求</h2><ul><li>集群建立时，每个实例只知道自己负责的槽信息。但是，集群实例之间会建立连接，互相同步信息，最终所有实例都知道自己和其他实例负责的槽信息</li><li>客户端与集群建立连接后，集群实例会将所有槽的分配信息发送给客户端，客户端缓存</li><li>根据键值对，可以直接计算出其对应的槽下标，然后根据客户端缓存的槽分配信息，发送命令到对应实例</li><li>若槽就是当前实例负责，则直接处理请求</li><li>若槽已经被重新分配到其他实例，由于集群实例之间会同步到最新的槽分配信息，所以当前实例知道该槽现在位于哪个实例，于是向客户端返回重定向错误命令MOVED，指示客户端向新实例请求对应数据，并且客户端会更新自己的槽分配信息缓存，下次该槽直接请求新实例</li><li>若槽数据正在被迁移到新实例，有两种情况：<ul><li>客户端请求的数据还在当前实例，则当前实例直接处理命令</li><li>客户端请求的数据已经被迁移到新实例，向客户端返回临时重定向错误命令ASK，指示客户端向新实例请求对应数据。客户端会先向新实例发送ASKING命令，代表新实例将允许客户端发送的下一条命令（其他情况将不允许），然后客户端再将请求发送到新实例，由新实例处理并返回响应。与MOVED命令不用，此时客户端不会更新自己的槽分配信息缓存，下次该槽依然当前实例</li></ul></li></ul><h2 id="为什么是16384个槽"><a href="#为什么是16384个槽" class="headerlink" title="为什么是16384个槽"></a>为什么是16384个槽</h2><p>Redis Cluster采用CRC16算法转换字符串键为16位整数，即包含2^16=65535个整数，Redis作者给出的原因是：</p><ol><li>16384个槽分配信息大约2kb，而65535个槽分配信息大约有8kb。由于每秒实例与实例之间、实例与客户端之间要交换槽分配信息，所以8kb太大了，会占用大量网络资源，而2kb可以接受</li><li>集群主库的数量不可能超过1000个，所以没必要有那么槽</li><li>实例是通过bitmap保存所有实例的槽分配情况的，bitmap在传输过程中会压缩，N个节点的bitmap填充率为 slots/N，当slots很大时，压缩率就会降低</li></ol><p>综上所述，最终作者决定决定使用16384个槽</p><h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>由Redis集群管理软件redis-trib负责执行重新分片，迁移单个槽的过程如下：</p><ol><li>让目标实例准备好从源实例导入属于槽的数据</li><li>让源实例准备好向目标实例导出属于槽的数据</li><li>获得指定数量个属于槽的数据键</li><li>对于步骤3中获取到的每个数据键，依次将每个键值对从源实例发送至目标实例</li><li>重复步骤3、4，直至所有属于槽的数据都被迁移完</li><li>向集群中任一实例发送消息，告知槽已经由目标实例维护，最终这一信息会被集群中所有实例获知</li></ol><h2 id="为什么采用哈希槽而不是直接记录数据与实例的关系"><a href="#为什么采用哈希槽而不是直接记录数据与实例的关系" class="headerlink" title="为什么采用哈希槽而不是直接记录数据与实例的关系"></a>为什么采用哈希槽而不是直接记录数据与实例的关系</h2><p>直接记录数据与实例的关系，意味着必须维护一张关系表：</p><ol><li>一旦对应关系发生变化，就要修改表。如果是单线程执行，则性能慢。如果是多线程，就涉及并发控制，增加系统复杂度，而Redis本身是单线程的，没有设计这些功能。</li><li>当数据量非常大时，映射表会非常庞大，无论是客户端还是集群实例，都会被占用很大一块内存空间。而采用哈希槽，相当于在数据与实例之间增加了中间层，只需要维护固定数量的映射关系即可，并且使用特定算法实现数据与槽的映射关系，相当于用时间换空间</li><li>由于Redis Cluster采用无中心化的架构，所以每个实例、客户端都需要维护槽与实例的映射关系，并且相互之间需要同步最新信息，那么要是采用数据与实例的映射表，必然占用大量网络资源</li><li>当集群在扩容、缩容、数据均衡时，都会进行数据迁移。以槽为单位进行迁移，会降低这个过程的复杂度，易于维护管理</li></ol><h2 id="分片集群高可用"><a href="#分片集群高可用" class="headerlink" title="分片集群高可用"></a>分片集群高可用</h2><p>分片集群的每个实例都可以设置主从复制模式，即设置多个从库。这些从库会复制主库的数据，以及槽分配信息。实例与其从库的关系，最终也会被集群中的所有实例知道并记录。</p><ol><li>监控<ol><li>疑似下线：集群中的各实例之间会向彼此发送PING命令进行在线检测，若超时未回复，则会被当前实例标记为疑似下线状态</li><li>已下线：集群实例之间会彼此同步信息，这里面就包含了对其他实例的下线状态判断信息，收到同步信息的实例会将其保存下来。若某实例A发现，超过半数的实例都对实例B判断为疑似下线，那么实例A就会将实例B标记为已下线状态，并且会广播整个集群，所有收到这条广播消息的实例也会将实例B标记为已下线状态</li></ol></li><li>选举<ol><li>当某个从库收到他自己主库的已下线广播消息时，会向其他主库发送选举命令，请求为自己投票</li><li>每轮新发起的投票，不论选举是否成功，都会将纪元+1</li><li>每个有投票权的主库（负责处理槽）在每个纪元只能给一个从库投票</li><li>从库接收到投票响应后，会判断纪元是否一致，一致才会采用投票结果</li><li>获得半数以上（有投票权的主库）赞成票的从库，成为新主库</li><li>若当前纪元没有从库成为新主库，则每个参与选举的从库都会等待随机时间后发起新一轮的选举</li></ol></li><li>故障转移<ol><li>被选举中的从库，执行SLAVEOF no one命令，成为新主库</li><li>新主库会下线所有对老主库的槽分配信息，转而分配给自己</li><li>向集群广播消息，通知自己接替了老主库负责的所有槽，成为新主库</li><li>开始接收读写命令，故障转移完成</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基数统计算法</title>
    <link href="/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>基数指的是一个集合中不重复的元素的个数。例如集合{2,1,1,3,2,1}，其基数集合就是{1,2,3}的长度，即3。基数计数，或称基数统计，指的就是计算出集合的基数。常见的基数统计的使用场景就是统计网站访问UV。</p><p>下面介绍几种基数估计的算法。</p><h1 id="LogLog-Counting"><a href="#LogLog-Counting" class="headerlink" title="LogLog Counting"></a>LogLog Counting</h1><p>回顾一些高中知识。我们假设抛出一枚硬币，其正面朝上的概率是1/2，反面朝上的概率也是1/2，不存在其他情况。显然，每次抛硬币都是相互独立的。那么如果我们一直抛硬币k次都为正面，这个事件出现的概率就是1/2^k。但是，如果我们真的抛硬币k次，一定会发生上述事件吗？很明显不一定，但是根据概率论，只要我们的样本足够大，那么出现这个事件的概率就趋近于1/2^k。既然该事件出现的概率是1/2^k，那么就可以说，如果我们至少抛2^k次硬币，一定会发生该事件。</p><p>假设我们的集合是一个二进制数组，类似[0,0,…,1,0,1,…]这样，那么我们就可以将这个数据从左往右视作抛硬币的过程。我们假设0代表硬币反面，1代表硬币正面，如果从左往右连续出现了k个1，那么出现这种数据情况的概率是多少呢？如前所述，是1/2^k。即这个数字的出现，就代表了我们进行了2^k次抛硬币的行为。如果我们将基数集合中的每个元素，视作一次抛硬币，那么我们就可以说基数为2^k个。</p><p>我们再假设，我们有一个固定长度的二进制数组，长度为n，初始全为0。我们还有一个很牛的Hash函数，可以将数据很分散的映射到这个数组上，使其置为1，并且Hash还是还能保证每一位出现0、1的概率都是1/2。那么，当这个数据的基数远远大于n时，一定会出现数组全为1的情况。换言之，我们就可以通过数组中1的个数来推断基数了。这等同于，我们查找数组中最右边的1，并将其左边所有位都视为1来估计基数。</p><p>至此，我们就可以讲讲LLC算法了。</p><p>LLC将数据依次通过Hash函数转成固定长度L的二进制串a，Hash函数保证每一位出现0、1的概率都为1/2，并且相同元素产生的二进制串相同，那么我们记a中最左边的1的下标为ia。最终，我们会得到imax=max(ia, ib, …, in)，那么根据之前的介绍，我们就估计出不同元素的个数为2^imax。</p><p>显然，这个过程会因为数据特性产生很多意外情况，于是LLC将二进制串进行分桶，各个桶分别计算自己的imax，即各自的基数，最终结果为这些技术的几何平均数。</p><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>其原理与LLC一致，只是最终使用调和平均数代替几何平均数。原因是调和平均数具有更优秀的抗干扰能力，会忽略一些尖刺数据的影响。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm</a></p><p><a href="http://antirez.com/news/75"><a href="http://antirez.com/news/75">Redis new data structure: the HyperLogLog</a></a></p><p><a href="https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/">HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</a></p><p><a href="https://agkn.wordpress.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a></p><p><a href="https://zhuanlan.zhihu.com/p/271186546">基数估计算法</a></p><p><a href="https://seeing-theory.brown.edu/cn.html">看见统计</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork函数以及Copy-On-Write机制</title>
    <link href="/2023/06/09/fork%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8ACopy-On-Write%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/09/fork%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8ACopy-On-Write%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>fork操作的含义是根据当前进程，拷贝出一份“一模一样”的新进程来。fork是类Unix系统创建进程的主要手段。在详解fork操作之前，我们需要先具备一些基本知识，熟悉这些的小伙伴可以跳过。</p><h1 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一.预备知识"></a>一.预备知识</h1><h2 id="1-进程组成"><a href="#1-进程组成" class="headerlink" title="1.进程组成"></a>1.进程组成</h2><p>进程是程序关于某数据集的一次运行活动。进程包括：</p><ul><li>进程控制块（PCB）：进程存在的唯一标志。进程管理工作所需的信息都存放在PCB中，操作系统不直接操作进程本身，而是通过操作PCB控制进程<ul><li>进程标识信息<ul><li>进程标识符PID</li><li>用户标识符UID</li><li>…</li></ul></li><li>处理器状态信息：各种寄存器的值，用于实现进程切换时保存上下文信息<ul><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>上下文数据：进程执行时处理器的寄存器中的数</li><li>记账信息：包括处理器时间综合、使用的时钟数综合、时间限制、记帐号等</li><li>…</li></ul></li><li>进程控制信息<ul><li>进程当前状态</li><li>进程优先级</li><li>正在使用的文件信息</li><li>正在使用的内存区域</li><li>正在使用的I/O设备</li><li>CPU、磁盘、网络流量使用情况统计</li><li>…</li></ul></li></ul></li><li>文本区域/代码段（text region）：存储处理器执行的代码。</li><li>数据区域/数据段（data region）：存储变量和进程执行期间使用的动态分配的内存</li><li>堆栈（stack region）：存储着活动过程调用的指令和本地变量</li></ul><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/composition.png"></p><p>下面这张图是进程的虚拟内存地址空间的分配模型图。进程的虚拟内存地址空间分为用户空间和内核空间。用户空间存放着这个进程的代码段和数据段，以及运行时的堆和用户栈。内核空间存放着内核的代码和数据，以及内核为这个进程创建的相关数据结构，比如页表数据结构等。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/PCB.png"></p><h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2.虚拟内存"></a>2.虚拟内存</h2><p>随着应用程序的体积越来越庞大，想要将完整的应用程序完整地装载进内存并运行起来越来越不现实。虚拟内存的技术带来的效果就是，使应用程序认为它在使用一块比实际物理内存大得多的虚拟内存，而不需要考虑具体实现细节。</p><p>至于实现方式，简单说就是根据时空局部性原理，将应用程序在此时运行真正需要的数据加载进内存，其余数据暂不关心，等到真正需要时再置换进内存。</p><h2 id="3-内存分页"><a href="#3-内存分页" class="headerlink" title="3.内存分页"></a>3.内存分页</h2><p>内存分页技术是一种实现虚拟内存的技术。它将虚拟内存进行等分（与具体应用程序无关），称之为“页”。将物理内存也进行等分（与页大小一致），称之为“块”，也叫做“页框”。在应用程序运行过程中，动态地将所需要的页加载进真正的物理内存中，即以页为单位，加载进页框中。通过一个映射记录“页表”，记录实时的页与页框的对应关系，辅助应用程序与操作系统查找到虚拟内存中的物理内容。</p><h1 id="二-fork操作原理"><a href="#二-fork操作原理" class="headerlink" title="二.fork操作原理"></a>二.fork操作原理</h1><p>开篇说过，fork操作的含义是根据当前进程，拷贝出一份“一模一样”的新进程来，其作用就是创建新进程。被拷贝的当前进程称之为“父进程”，拷贝出来的新进程称之为“子进程”。对于Linux系统而言，所有进程都是通过init进程fork而来的，即init进程是所有进程的祖先进程。</p><p>一个进程调用fork后，操作系统会转入内核态，做以下几件事（考虑COW的情况）：</p><ol><li><p>分配新的内存块和内核数据结构给子进程</p></li><li><p>将父进程部分数据结构内容拷贝至子进程：PCB（大略上，除了进程标识重新分配以外，其他很多资源都需要复制）。代码段、数据段、堆栈的复制采用COW写时复制技术进行复制（这里面就包含了虚拟内存分页会使用到的页表数据结构），即父子进程的虚拟地址不同（子进程分配了新的内存页），但其对应的物理地址相同。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/fork-COW.jpg"></p></li><li><p>添加子进程到系统进程列表当中</p></li><li><p>fork返回，开始进程调度：父子进程的执行并没有固定的先后顺序，完全看操作系统的进程调度策略</p></li></ol><p>子进程执行起来后的局部变量，和父进程是独立的。我们看下面的例子</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span>  </span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>   </span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start \n&quot;</span>);<br>    i=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-comment">// 在父进程中，fork返回新创建的子进程的进程ID</span><br>    <span class="hljs-comment">// 在子进程中，fork返回它的子进程的进程ID，因为没有，所以返回0</span><br>    <span class="hljs-comment">// 如果出现错误，fork返回一个负值</span><br>    <span class="hljs-comment">// fpid这个局部变量，在父子进程中根据fork()函数返回值的不同而不同</span><br>    <span class="hljs-comment">// 由于fork前i=0已经确定了，所以子进程中也是i=0，这是从父进程复制而来的</span><br>    fpid=fork();<br><br>    <span class="hljs-comment">// 父进程正常执行下面的代码</span><br>    <span class="hljs-comment">// 拷贝出来的子进程也会执行下面的代码</span><br>    <span class="hljs-keyword">if</span> (fpid &lt; <span class="hljs-number">0</span>)   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建进程失败!/n&quot;</span>);   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fpid == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是子进程，由父进程fork出来/n&quot;</span>);   <br>    &#125;  <br>    <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是父进程/n&quot;</span>); <br>    &#125;  <br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end \n&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br></code></pre></td></tr></table></figure><p>创建好子进程后，父进程要执行这段代码，子进程也要执行这段代码。子进程不会像线程那样从run方法处开始执行，而是会从父进程调用fork函数的返回位置开始执行：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/fork.png"></p><h1 id="三-exec操作原理"><a href="#三-exec操作原理" class="headerlink" title="三.exec操作原理"></a>三.exec操作原理</h1><p>看完上面fork操作的原理，我们知道了怎样创建一个新进程。但是，为什么我们需要创建两个一模一样的进程呢？或者说，我们大多数情况下并不需要两个一模一样的进程，我们更需要的是执行新任务的新进程。这就用到了exec函数族，其中包括6个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...<span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...<span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[],<span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。大白话说，就是在函数外在包装（比如PID）不变的情况下，完全更改内部逻辑。exec系列函数在执行时会直接替换掉当前进程的物理地址空间。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/exec.png"></p><p>总结一下，fork会产生一个和父进程完全相同的子进程，但子进程在此后一般会调用exec，执行自己真正想要的功能。因为执行了exec，数据都被清空了，所以fork新创建子进程时复制过去的数据是没用的。因此，我们引入Copy On Write写时复制技术，在复制父进程时并不真正意义上的复制，而是子进程共享父进程的部分内存空间，这样一是复制速度快，二是避免无用复制，浪费资源。只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><h2 id="四-Copy-On-Write写时复制"><a href="#四-Copy-On-Write写时复制" class="headerlink" title="四.Copy On Write写时复制"></a>四.Copy On Write写时复制</h2><p>写时复制COW，是计算机编程中使用的一种资源管理技术。其效果是，如果一个资源被拷贝但没有被修改，则不会立即创建一个新的资源副本，而是在父子进程之间共享。只有在第一次修改资源时，才会复制资源，即COW是一种可以推迟甚至避免拷贝资源的技术。对部分资源的修改不会改变其他资源，没有修改的资源仍然是父子进程之间共享。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/OS/process/COW.png"></p><p>对于fork而言：</p><ul><li>子进程exec之前，刚被创建出来的父子进程完全共享代码段、数据段、堆栈的物理空间。</li><li>子进程exec之后，由于两者执行的代码不同，子进程的代码段也会分配新的物理空间。</li></ul><h3 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h3><p>以页表为例，fork之后，内核会把父进程中所有的物理页框的权限都设为read-only，然后子进程的虚拟内存地址指向父进程的物理内存地址。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到物理页框是read-only的，于是触发页异常中断（page-fault），陷入到内核的一个中断例程。在这个中断例程中，内核就会把触发的异常的物理页框复制一份，子进程的虚拟内存地址指向这个新页框的物理地址，于是父子进程的虚拟内存地址各自指向了不同的物理地址。</p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><ul><li>减少了不必要的资源分配</li><li>降低了复制大量资源时带来的瞬间延时</li></ul><h3 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3.缺点"></a>3.缺点</h3><ul><li>少量增加了资源修改操作时的开销</li><li>如果在fork之后，父子进程都还需要继续进行写操作，会产生大量的分页错误</li></ul><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E8%A1%8C%E7%A8%8B">维基百科-进程</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503">百度百科-进程</a></li><li><a href="https://lfool.gitbook.io/operating-system/di-er-zhang-jin-cheng-guan-li/1.-jin-cheng-de-gai-nian-zu-cheng-te-zheng">进程的概念 &amp; 组成 &amp; 特征</a></li><li><a href="https://blog.csdn.net/pange1991/article/details/84770181">进程和线程的区别（操作系统级别解析）</a></li><li><a href="https://misakifx.github.io/2020/02/17/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">【操作系统原理】第二章-进程和线程 </a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">维基百科-虚拟内存</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E6%80%A7">维基百科-局部性原理</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E5%88%86%E9%A0%81">维基百科-分页</a></li><li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)">维基百科-fork（系统调用）</a></li><li><a href="https://blog.csdn.net/Dawn_sf/article/details/78709839">操作系统 — fork()函数的使用与底层原理</a></li><li><a href="https://blog.csdn.net/wu_zf/article/details/7640970">linux中fork函数及子进程父进程进程先后</a></li><li><a href="https://blog.csdn.net/daocaokafei/article/details/116785985">「进程管理」fork之后子进程到底复制了父进程什么？</a></li><li><a href="https://en.wikipedia.org/wiki/Exec_(system_call)">维基百科-exec（系统调用）</a></li><li><a href="https://en.wikipedia.org/wiki/Copy-on-write">维基百科-写时复制</a></li><li><a href="https://zhuanlan.zhihu.com/p/148683698?utm_id=0">Copy On Write机制了解一下</a></li><li><a href="https://www.cnblogs.com/wuchanming/p/4495479.html">Linux进程管理——fork()和写时复制</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础-单机数据库</title>
    <link href="/2023/05/31/Redis%E5%9F%BA%E7%A1%80-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/05/31/Redis%E5%9F%BA%E7%A1%80-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>Redis 服务器内会保存服务器信息与客户端信息，所以如无特殊说明，下文涉及的服务端状态指服务端保存的服务器的信息（保存在redis.h/RedisServer结构内），客户端状态指服务端保存的客户器的信息（保存在redis.h/RedisClientr结构内）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisServer</span> </span>&#123;<br>    <span class="hljs-comment">// 保存所有数据库具体信息的数组</span><br>    RedisDb[] db;<br>    <span class="hljs-comment">// 数据库数量</span><br>    <span class="hljs-keyword">int</span> dbnum;<br>    <span class="hljs-comment">// 距离上次持久化之后，所有数据库的修改次数</span><br>    <span class="hljs-keyword">long</span> dirty;<br>    <span class="hljs-comment">// 为防止持久化失败，在持久化之前复制dirty值，用于恢复</span><br>    <span class="hljs-keyword">long</span> dirtyBeforeBgsave;<br>    <span class="hljs-comment">// 上次执行SAVE或BGSAVE命令的时间戳</span><br>    <span class="hljs-keyword">long</span> lastsave;<br>    <span class="hljs-comment">// 是否可以执行RDB持久化的判断条件</span><br>    SaveParam[] saveParams;<br>    <span class="hljs-comment">// AOF缓冲区</span><br>    <span class="hljs-comment">// sds实现的动态字符串</span><br>    String aofBuf;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisClient</span> </span>&#123;<br>    <span class="hljs-comment">// 当前客户端的状态</span><br>    <span class="hljs-comment">// CLIENT_DIRTY_CAS表示事务被破坏</span><br>    <span class="hljs-keyword">int</span> flags;<br>    <span class="hljs-comment">// 当前客户端选择使用的数据库</span><br>    RedisDb db;<br>    <span class="hljs-comment">// 监视的所有键</span><br>    list&lt;string&gt; watchedKeys;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一-数据库"><a href="#一-数据库" class="headerlink" title="一.数据库"></a>一.数据库</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDb</span> </span>&#123;<br>    <span class="hljs-comment">// 键空间，保存了当前数据库的所有键值对</span><br>    Hash dict;<br>    <span class="hljs-comment">// 当前数据库被监听的所有键及监视他们的client</span><br>    <span class="hljs-comment">// key=键</span><br>    <span class="hljs-comment">// value=list&lt;client&gt;</span><br>    Hash watchedKeys;<br>    <span class="hljs-comment">// 保存本数据库中所有设置过过期时间的键及其过期时间戳</span><br>    <span class="hljs-comment">// key=键</span><br>    <span class="hljs-comment">// value=过期时间戳（精度：毫秒）</span><br>    Hash expires;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><p>类似于其他的数据库，如Mysql或Oracle等，一个服务端往往有多个数据库，Redis也是一样。服务器状态里的RedisServer.db保存了所有数据库的指针，RedisServer.dbnum当前的数据库数量（默认值为16，即Redis服务器默认创建16个数据库，默认值由配置文件里的database决定）。不同数据库之间的数据是独立的。</p><p>RedisDb就是具体某个数据库的信息。</p><p>客户端状态里的RedisClient.db表示当前客户端正在使用的数据库，可以通过SELECT命令切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 切换到1号数据库，数据库下标从0开始（数组下标）</span><br>SELECT <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="2-数据库键空间"><a href="#2-数据库键空间" class="headerlink" title="2.数据库键空间"></a>2.数据库键空间</h2><p>之前我们介绍过Redis的hash对象，对于每个数据库而言，它们就是通过一个hash对象来维护当前数据库的所有键值对的，称之为“键空间”。需要特别注意，之前我们说Redis不允许对象类型嵌套使用，即只能是list&lt;string&gt;、map&lt;string,string&gt;、set&lt;string&gt;、zset&lt;string&gt;，加上string这五种对象类型。但是，键空间这个hash对象是个例外，它的key是string对象类型，value是我们刚才说的五种对象类型。</p><p>有了之前hash对象的知识，我们很容易想象<em>键命令</em>是如何实现的：</p><ul><li>添加新键</li><li>删除键</li><li>更新键</li><li>查询键</li><li>其他<ul><li>清空当前数据库的所有键 FLUSHDB</li><li>随机返回某个键 RANDOMKEY</li><li>当前数据库的键数量 DBSIZE</li><li>是否存在某个键 EXISTS</li><li>重命名键 RENAME</li><li>查询所有键 KEYS</li><li>…</li></ul></li></ul><p>另外，当我们通过键命令读写键空间时，服务器还会额外执行一些操作：</p><ul><li>读写键之后，服务器会根据键是否存在，更新当前数据库的hit（键命中次数）、miss（键未命中次数）值</li><li>读写键之后，服务器会更新键对象的lru时间</li><li>读写键值之前，若键已经过期，服务器会删除键，然后执行剩余操作</li><li>修改（增删改）键之后，服务器会修改监视了当前键（WATCH命令）的客户端状态，表示其事务被破坏</li><li>修改（增删改）键之后，服务器的脏键计数器加1（RedisServer.dirty++），这个脏键计数器会触发服务器的持久化及复制操作</li><li>修改（增删改）键之后，若服务器开启了通知功能，那么服务器将按照配置发送相应通知</li></ul><h1 id="二-键的生存周期"><a href="#二-键的生存周期" class="headerlink" title="二.键的生存周期"></a>二.键的生存周期</h1><p>redisDb.expires字典保存了本数据中所有设置过过期时间的键，及其过期时间戳，称之为过期字典。其中，字典key是键指针，字典value是这个键的过期时间戳，单位毫秒。</p><h2 id="1-设置过期时间"><a href="#1-设置过期时间" class="headerlink" title="1.设置过期时间"></a>1.设置过期时间</h2><p>Redis中设置键过期的命令有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">EXPIRE key n<span class="hljs-comment">// 设置键n秒后过期</span><br>PEXPIRE key n<span class="hljs-comment">// 设置键n毫秒后过期</span><br>EXPIREAT key n<span class="hljs-comment">// 设置键某个时间戳过期，单位：秒</span><br>PEXPIREAT key n<span class="hljs-comment">// 设置键某个时间戳过期，单位：毫秒</span><br></code></pre></td></tr></table></figure><p>在Redis底层实现里，上述四个命令，最终都会转换成<em>PEXPIREAT</em>命令实现，不难想象，该命令的实现原理就是往redisDb.expires字典中插入数据。</p><p>我们单独讨论一下<em>SETEX</em>命令及Redis实现分布式锁的原理：<a href="http://www.jonxzzz.com/2023/06/04/Redis%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis应用-分布式锁 </a></p><h2 id="2-删除过期时间"><a href="#2-删除过期时间" class="headerlink" title="2.删除过期时间"></a>2.删除过期时间</h2><p>Redis中删除键过期的命令有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PRESIST key<span class="hljs-comment">// 删除该键之前设置过的过期时间</span><br></code></pre></td></tr></table></figure><p>该命令的实现原理就是删除redisDb.expires字典中对应数据。</p><h2 id="3-获取过期时间"><a href="#3-获取过期时间" class="headerlink" title="3.获取过期时间"></a>3.获取过期时间</h2><p>Redis中查询键还有多久过期的命令有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TTL key<span class="hljs-comment">// 返回键的剩余生存时间（time to live，TTL），单位：秒</span><br>PTTL key<span class="hljs-comment">// 返回键的剩余生存时间（time to live，TTL），单位：毫秒</span><br></code></pre></td></tr></table></figure><p>该命令的实现原理就是查询redisDb.expires字典中该键的过期时间戳，返回当前时间戳与过期时间戳的差值。</p><h2 id="4-判断键是否过期"><a href="#4-判断键是否过期" class="headerlink" title="4.判断键是否过期"></a>4.判断键是否过期</h2><p>其实通过上述TTL、PTTL的实现已经可以用来判断一个键是否过期了，但是对于Redis内部而言，调用一个命令的成本肯定要大于自己重新写一段代码。Redis判断一个键是否过期，就是对比当前时间戳和过期时间戳的大小。</p><h2 id="5-过期键删除策略"><a href="#5-过期键删除策略" class="headerlink" title="5.过期键删除策略"></a>5.过期键删除策略</h2><p>抛开Redis不谈，数据库对于过期键的删除策略有以下三种：</p><ul><li>定时删除<ul><li>在设置键的过期时间的同时，同时设置一个定时器，到了指定时间时间时，定时器会立即执行对键的删除操作。</li><li>最节省内存，不会出现无用数据占用内存的情况。</li><li>最消耗CPU。首先，每个过期键都需要一个定时器去处理它；其次，与处理服务器请求相比，处理过期数据非常不重要；最后，对于Redis而言，它的定时器实现需要用到时间事件，而Redis对于时间事件的实现是无序链表，查找到一个需要执行的事件时间复杂度是O(N)，这显然不够高效。</li></ul></li><li>惰性删除<ul><li>放任过期键不理会，但是每当服务器处理键的查询命令时，都会先判断该键是否已经过期。如果已经过期，则删除该键，返回空或报错；如果没有过期，则执行正常查询命令。</li><li>极端情况下，可能出现无用数据占用大量内存的情况。</li><li>最节省CPU，只有在过期键真正需要被删除的时候才会执行删除操作。</li></ul></li><li>定期删除<ul><li>每隔一段时间，就检查数据库，删除其中过期的数据。至于要隔多久检查、每次检查多少数据，都可以配置。</li><li>折中方案</li><li>可以通过控制执行周期间隔和每次执行的规模来决定对于内存和CPU的影响</li></ul></li></ul><p>Redis的实现方式是同时使用惰性删除和定期删除两种策略。我们主要看下定期删除的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个全局变量</span><br><span class="hljs-comment">// 代表数据库下标</span><br><span class="hljs-comment">// 用来记录Redis服务器清理过期键的进度</span><br><span class="hljs-keyword">int</span> current_db = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 每次Redis的周期函数serverCron执行时，都会调用本函数完成对数据库中的过期键清理</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activeExpireCycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 本次需要处理的数据库数量</span><br>    <span class="hljs-keyword">int</span> db_number = server.dbnum &lt; DEFAULT_DB_NUMBERS ? server.dbnum : DEFAULT_DB_NUMBERS;<br>    <span class="hljs-comment">// 遍历数据库</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i: du_numbers) &#123;<br>        <span class="hljs-comment">// 已经检查完一轮服务器的所有数据库，重新再来一遍</span><br>        <span class="hljs-keyword">if</span> (current_db == server.dbnum) &#123;<br>            curent_db = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取本次需要处理的数据库</span><br>        redisDb = server.db[current_db++];<br>        <br>        <span class="hljs-comment">// 遍历该数据库的部分数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j: DEFAULT_KEY_NUMBERS) &#123;<br>            <span class="hljs-comment">// 该数据库没有过期键，直接跳过</span><br>            <span class="hljs-keyword">if</span> (redisDb.expires.size == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 随机处理一个设置了过期时间的键</span><br>            key = redisDb.expires.get_random_key();<br>            <br>            <span class="hljs-comment">// 该键已经过期，删除它</span><br>            <span class="hljs-keyword">if</span> (is_expire(key)) &#123;<br>                <span class="hljs-comment">// 删除键并发送通知</span><br>                deleteExpiredKeyAndPropagat(key)<br>            &#125;<br>            <br>            <span class="hljs-comment">// 达到了本次的处理时间上限，立即结束</span><br>            <span class="hljs-keyword">if</span> (reach_time_limit()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Redis通过约束每次处理的数据库数量、键数量、总的处理时间，防止对于过期键的处理过多的影响服务器。</p><h2 id="6-RDB对于过期键的处理"><a href="#6-RDB对于过期键的处理" class="headerlink" title="6.RDB对于过期键的处理"></a>6.RDB对于过期键的处理</h2><p>生成RDB文件时，不会保存已经过期了的键到RDB文件。</p><p>载入RDB文件时：</p><ul><li>对于主服务器，程序会对RDB文件中的键进行检查，已经过期的键不会载入到数据库中。</li><li>对于从服务器，RDB文件保存的所有数据，不论是否已经过期，都会载入到数据库中。</li></ul><p>在这期间，如果我们从主服务器读取该键，是不会有返回值的。但是如果我们从从服务器读取该键，会返回之前已经过期的值，因为他还没有被删除，而且从服务器也不会惰性删除它。</p><p>随后，只有当主服务器删除掉这个过期键时，会发送一条DEL删除命令到从服务器，从服务会执行命令，从而删除该键。</p><p>之后讨论RDB和主从服务器时我们就知道原因啦。</p><h2 id="7-AOF对于过期键的处理"><a href="#7-AOF对于过期键的处理" class="headerlink" title="7.AOF对于过期键的处理"></a>7.AOF对于过期键的处理</h2><p>写入AOF文件时，如果某个键已经过期，但是它还没有被删除，那么依然会像处理未过期的键一样，将其写入到AOF文件中。随后当这个键被服务器删除时，会追加一条针对这个键的删除操作到AOF文件。</p><p>AOF重写时，程序会对服务器的键进行检查，已经过期的键不会保存到重写后的AOF文件中。</p><p>之后讨论AOF时我们就知道原因啦。</p><h1 id="三-通知机制"><a href="#三-通知机制" class="headerlink" title="三. 通知机制"></a>三. 通知机制</h1><p>客户端通过订阅频道，可以获知数据库中键的变化情况，以及命令的执行情况。从Redis服务器角度看，就是成功执行了某些命令、修改键值、事件发生之后，通知给客户端。</p><p>其原理就是通过<em>SUBSCRIBE</em>命令订阅固定的频道，然后由Redis发布消息，客户端接受消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// __&#123;通知类型&#125;@&#123;数据库id&#125;__&#123;键正则&#125;</span><br>SUBSCRIBE __keyspace@0__:message<br><span class="hljs-comment">// __&#123;通知类型&#125;@&#123;数据库id&#125;__&#123;命令名&#125;</span><br>SUBSCRIBE __keyevente@0__:del<br></code></pre></td></tr></table></figure><p>通知类型有：</p><ol><li>键空间通知：某个键执行了什么命令</li><li>键事件通知：某个命令作用到哪些键</li></ol><p>当命令成功执行后，会调用notifyKeyspaceEvent()方法进行通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// type：通知类型，这里主要是用于区分通用、SET等等，不是上述的键空间和键事件两类</span><br><span class="hljs-comment">// event：命令名</span><br><span class="hljs-comment">// key：键名</span><br><span class="hljs-comment">// dbid：数据库id</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyKeyspaceEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, String event, String key, <span class="hljs-keyword">int</span> dbid)</span> </span>&#123;<br>    <span class="hljs-comment">// 配置不允许发送此类通知，直接返回</span><br>    <span class="hljs-keyword">if</span>(server.notify_keyspace_events &amp; type == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置允许发送键空间通知</span><br>    <span class="hljs-keyword">if</span>(server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE == <span class="hljs-number">1</span>) &#123;<br>        String channel = String.format(<span class="hljs-string">&quot;__keyspace@%d__%s&quot;</span>, dbid, key);<br>        <span class="hljs-comment">// PUBLISH发布命令的底层实现</span><br>        <span class="hljs-comment">// 当前键执行了什么命令</span><br>        pubsubPublishMessage(channel, event);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置允许发送键事件通知</span><br>    <span class="hljs-keyword">if</span>(server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT == <span class="hljs-number">1</span>) &#123;<br>        String channel = String.format(<span class="hljs-string">&quot;__keyevente@%d__%s&quot;</span>, dbid, event);<br>        <span class="hljs-comment">// 当前命令作用到哪些键</span><br>        pubsubPublishMessage(channel, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>server.notify_keyspace_events是redis配置。</p><p>关于发布订阅及其原理我们随后会专门讲解。</p><h1 id="四-RDB持久化"><a href="#四-RDB持久化" class="headerlink" title="四.RDB持久化"></a>四.RDB持久化</h1><p>RDB持久化的作用是将Redis在内存中的数据库状态保存到磁盘中去，做数据备份，防止数据丢失。所谓数据库状态，指的是某个时刻Redis服务器中所有非空数据库及其键值对。</p><h2 id="1-RDB创建"><a href="#1-RDB创建" class="headerlink" title="1.RDB创建"></a>1.RDB创建</h2><h3 id="1-1-手动执行"><a href="#1-1-手动执行" class="headerlink" title="1.1.手动执行"></a>1.1.手动执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生成RDB文件：由主进程执行，即会阻塞主进程响应客户端任何命令，直到RDB文件创建完成</span><br>SAVE<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生成RDB文件：由主进程fork出的子进程执行，即不会阻塞主进程响应客户端任何命令</span><br>BGSAVE<br></code></pre></td></tr></table></figure><p>BGSAVE命令执行期间，服务器会：</p><ol><li><p>拒绝执行SAVE命令：都会调用rdbSave()方法，其间访问的资源会产生竞争。</p></li><li><p>拒绝执行BGSAVE命令：都会调用rdbSave()方法，其间访问的资源会产生竞争。</p></li><li><p>等到BGSAVE命令执行完成后，再执行BGREWRITEAOF命令：虽然不会产生资源竞争，但出于性能考虑，同时进行大量磁盘读写操作也不明智。</p></li></ol><p>另外，若先执行BGREWRITEAOF命令，则会拒绝执行BGSAVE命令，原因也是同时进行大量磁盘读写操作不利于性能。</p><h3 id="1-2-关键细节"><a href="#1-2-关键细节" class="headerlink" title="1.2.关键细节"></a>1.2.关键细节</h3><p>虽然BGSAVE命令采用子进程执行持久化工作，大大减少了主进程的阻塞时间，但是，为了创建出子进程，fork()操作本身也会阻塞主进程。主要原因是fork()出来的子进程需要拷贝进程必要的数据，如内存页表。以内存页表为例，它的作用是记录虚拟内存与物理内存的映射关系，那么，当我们的内存特别大时，这个页表也相应的很大，可想而知拷贝工作会消耗大量CPU，从而增大fork()阻塞时间。</p><p>另外，真正的内存数据在fork()时反而不会被立即拷贝，这主要是操作系统的写时复制（Copy on Write）机制。详情请看<a href="/2023/06/09/fork%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8ACopy-On-Write%E6%9C%BA%E5%88%B6/" title="[fork函数以及Copy-On-Write机制]">[fork函数以及Copy-On-Write机制]</a></p><h3 id="1-3-自动定期执行"><a href="#1-3-自动定期执行" class="headerlink" title="1.3.自动定期执行"></a>1.3.自动定期执行</h3><p>Redis周期函数会定期检查数据库，将其与服务器配置的save选项作比较，只要配置的条件中有一条被满足，就会触发执行BGSAVE命令。下面是默认的save配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务器在900秒之内，对数据库至少进行了1次修改</span><br>save <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-comment">// 服务器在300秒之内，对数据库至少进行了10次修改</span><br>save <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-comment">// 服务器在60秒之内，对数据库至少进行了10000次修改</span><br>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>该配置在Redis启动时会被读取写入到redisServer对象中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisServer</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 距离上次持久化之后，所有数据库的修改次数</span><br>    <span class="hljs-keyword">long</span> dirty;<br>    <span class="hljs-comment">// 为防止持久化失败，在持久化之前复制dirty值，用于恢复</span><br>    <span class="hljs-keyword">long</span> dirtyBeforeBgsave;<br>    <span class="hljs-comment">// 上次执行SAVE或BGSAVE命令的时间戳</span><br>    <span class="hljs-keyword">long</span> lastsave;<br>    <span class="hljs-comment">// 是否可以执行RDB持久化的判断条件</span><br>    SaveParam[] saveParams;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaveParam</span> </span>&#123;<br>    <span class="hljs-comment">// 时间区间，单位：秒</span><br>    <span class="hljs-keyword">long</span> seconds;<br>    <span class="hljs-comment">// 检查的修改次数</span><br>    <span class="hljs-keyword">int</span> changes;<br>&#125;<br></code></pre></td></tr></table></figure><p>上文我们说过，当修改（增删改）键之后，服务器的脏键计数器加1（RedisServer.dirty++）。</p><p>Redis的周期函数是这样检查是否触发了RDB持久化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serverCron</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历所有条件</span><br>    <span class="hljs-keyword">for</span>(SaveParam param: server.saveParams) &#123;<br>        <span class="hljs-keyword">long</span> save_interval = now() - server.lastsave;<br>        <br>        <span class="hljs-comment">// 若数据库被修改次数&gt;=条件允许的修改次数</span><br>        <span class="hljs-comment">// 并且距离上次RDB持久化的时间间隔&gt;条件时间</span><br>        <span class="hljs-comment">// 那么就触发RDB持久化</span><br>        <span class="hljs-keyword">if</span>(server.dirty &gt;= param.changes &amp;&amp; save_interval &gt; param.seconds) &#123;<br>            BGSAVE();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-RDB载入"><a href="#2-RDB载入" class="headerlink" title="2.RDB载入"></a>2.RDB载入</h2><p>RDB文件的载入工作没有专门的命令，因为其是在服务器启动时自动执行的。</p><p>结合之后要讲的AOF持久化，Redis载入数据的过程是这样的：</p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/load-rdb.png" width="50%"><p>RDB载入期间，服务器暂不提供任何服务，即一直处于阻塞状态，直到载入工作完成。</p><h2 id="3-RDB文件结构"><a href="#3-RDB文件结构" class="headerlink" title="3.RDB文件结构"></a>3.RDB文件结构</h2><p>RDB文件格式是非常紧凑的二进制格式，默认经过LZF算法压缩。如果不在乎最终的RDB文件大小，更关心RDB创建时的CPU消耗，那么可以通过配置文件的rdbcompression参数控制开关是否压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启RDB文件压缩功能</span><br>rdbcompression yes<br></code></pre></td></tr></table></figure><p>另外还有配置参数rdbchecksum，用来控制创建和载入RDB文件时是否校验文件是否损坏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启RDB文件损坏校验功能</span><br>rdbchecksum yes<br></code></pre></td></tr></table></figure><h2 id="4-RDB持久化的优缺点"><a href="#4-RDB持久化的优缺点" class="headerlink" title="4.RDB持久化的优缺点"></a>4.RDB持久化的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1.优点"></a>4.1.优点</h3><ul><li>RDB文件的内容为二进制的数据，占用内存更小，更紧凑，可以更快的传输到远程服务器进行服务恢复，更适合做为备份文件。压缩后更是如此。</li><li>BGSAVE命令可以更大程度的提高Redis服务器的运行速度，因为每次持久化时主进程都会fork() 一个子进程，由子进程进行数据持久化工作，主进程并不会执行磁盘I/O等操作。</li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2.缺点"></a>4.2.缺点</h3><ul><li>因为RDB文件只能保存某个时间间隔的数据，如果中途服务被意外终止了，则会丢失一段时间内的数据;</li><li>fork() 本身会造成阻塞，如果数据集很大且CPU性能不佳，则可能导致Redis服务器停止为客户端服务几毫秒甚至一秒钟。</li></ul><h1 id="五-AOF持久化"><a href="#五-AOF持久化" class="headerlink" title="五.AOF持久化"></a>五.AOF持久化</h1><p>AOF（Append Only File）是通过保存Redis 服务器所执行的<strong>写命令</strong>来记录数据库状态的，被写入AOF文件的命令都是以Redis的命令请求协议格式保存的，即是纯文本格式（不同于RDB文件的二进制文本格式）。服务器在启动时，可以通过加载并执行AOF文件内的所有命令来还原服务器被关闭前的数据库状态。</p><h2 id="5-1-AOF生成"><a href="#5-1-AOF生成" class="headerlink" title="5.1.AOF生成"></a>5.1.AOF生成</h2><p>AOF持久化功能依次分为三部分：</p><ol><li>命令追加：当服务器的AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以命令请求协议的格式被追加到redisServer.aofBuf缓冲区内。</li><li>文件写入 -&gt; 文件同步：每次事件循环函数处理完所有事件之后，都会调用flushAppendOnlyFile()函数，根据条件，考虑是否将redisServer.aofBuf缓冲区内的数据写入到内存中的AOF文件内，以及是否将内存AOF文件同步到磁盘AOF文件。<ol><li>服务器配置appendfsync决定了何时进行文件同步：<ol><li>always：由主进程立即将redisServer.aofBuf缓冲区内的所有数据写入内存AOF文件，并同步到磁盘AOF文件。</li><li>everysec：将redisServer.aofBuf缓冲区内的所有数据写入内存AOF文件，如果上次文件同步距今时间已超过一秒，那么由子线程负责将内存AOF文件同步到磁盘AOF文件中。</li><li>no：将redisServer.aofBuf缓冲区内的所有数据写入内存AOF文件，何时将内存AOF文件同步到磁盘AOF文件中，以及具体操作，均由操作系统决定并执行，Redis服务器什么也不做。</li></ol></li><li>这三种配置的优缺点分别是：<ol><li>always<ol><li>优点：最安全，即使服务器被关闭，也只会都是一条命令</li><li>缺点：每次执行写命令都需要写入磁盘，写入命令执行效率最低</li></ol></li><li>everysec<ol><li>优点：折中方案，安全性尚可，只会丢失一秒内的命令</li><li>缺点：写入命令执行效率足够快</li></ol></li><li>no<ol><li>优点：写入命令执行效率最高</li><li>缺点：风险最高，丢失的命令数量取决于操作系统的设置</li></ol></li></ol></li></ol></li></ol><p>至于为什么会出现文件写入与文件同步这两个阶段，也是出于效率考虑，现代操作系统做出的优化。操作系统通常会将写入磁盘的文件数据先暂存在一个内存缓冲区中，等到缓冲区满或超过了时间限制后，才真正地将缓冲区内的文件数据写入到磁盘。但正如前所述，这样做也带来了文件数据丢失的风险。</p><h2 id="5-2-AOF载入与数据还原"><a href="#5-2-AOF载入与数据还原" class="headerlink" title="5.2.AOF载入与数据还原"></a>5.2.AOF载入与数据还原</h2><p>步骤如下：</p><ol><li>由于Redis命令只能在客户端上下文中执行，所以创建一个不带网络连接的伪客户端，通过读取AOF文件中的命令代替本来由网络连接传输过来的命令，然后执行。其执行效果与带网络连接的普通客户端完全一样。</li><li>从AOF中读取一条写命令。</li><li>使用伪客户端执行被读取出来的写命令。</li><li>重复执行步骤2和3，直到AOF文件中的所有写命令都被处理完。</li></ol><p>至此，就通过AOF文件还原出了数据库状态。</p><h2 id="5-3-AOF重写"><a href="#5-3-AOF重写" class="headerlink" title="5.3.AOF重写"></a>5.3.AOF重写</h2><p><strong>为什么会有AOF重写？</strong>因为随着服务器不断执行接收到的一条条写命令，AOF文件的内容会越来越多，不仅对Redis服务器，甚至会对宿主机造成影响。并且，载入AOF所需要的时间也会越来越久。更要命的是，这里面还包含了大量的冗余指令。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">RPUSH list <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-string">&quot;B&quot;</span><br>RPUSH list <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-string">&quot;D&quot;</span><br>RPUSH list <span class="hljs-string">&quot;E&quot;</span> <span class="hljs-string">&quot;F&quot;</span><br>LPOP list<br>LPOP list<br></code></pre></td></tr></table></figure><p>上面的6条指令可以帮助我们还原list的最终状态，但是，我们真的需要这六条指令吗？换个角度想，我们只是需要记录下当前的数据库状态，即想要通过一条指令可以还原出[“C”, “D”, “E”, “F”]这个list，那么下面这条指令的含义是不是等于上面6条之和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RPUSH list <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-string">&quot;D&quot;</span> <span class="hljs-string">&quot;E&quot;</span> <span class="hljs-string">&quot;F&quot;</span><br></code></pre></td></tr></table></figure><p>这就是AOF重写的原理，即通过特定指令读取数据库当前状态，以替换原有的AOF文件，达到最小化AOF文件的效果。特点是：</p><ul><li>新老两份AOF文件表达的数据库状态完全一致</li><li>完全与原有的AOF文件无关，只与数据库当前状态有关</li></ul><p>整个AOF重写的过程用伪代码表达如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aofRewrite</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建新AOF文件</span><br>    File file = createFile();<br>    <br>    <span class="hljs-keyword">for</span> (RedisDb db: redisServer.db) &#123;<br>        <span class="hljs-comment">// 忽略空数据库</span><br>        <span class="hljs-keyword">if</span> (db.isEmpty()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 写入db选择命令</span><br>        f.writeCommand(SELECT, db.id);<br>        <br>        <span class="hljs-keyword">for</span> (String key: db.keys()) &#123;<br>            <span class="hljs-comment">// 忽略已经过期的key</span><br>            <span class="hljs-keyword">if</span> (key.isExpire) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">switch</span> (key.type) &#123;<br>                    STRING: rewriteString(file, key);<br>                    LIST: rewriteList(file, key);<br>                    SET: rewriteSet(file, key);<br>                    ZSET: rewriteZset(file, key);<br>                    HASH: rewriteHash(file, key);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 写入key的过期时间</span><br>            <span class="hljs-keyword">if</span> (key.hasExpireTime()) &#123;<br>                rewriteExpireTime(key)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 新文件写入完毕，关闭</span><br>    file.close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteString</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用GET命令获取value</span><br>    String value = GET(key);<br>    <span class="hljs-comment">// 使用SET命令重写</span><br>    f.writeCommand(SET, key, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteList</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用LRANGE命令获取所有values</span><br>    String[] values = LRANGE(key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 使用RPUSH命令重写</span><br>    f.writeCommand(RPUSH, key, values);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteSet</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用SMEMBERS命令获取所有values</span><br>    String[] values = SMEMBERS(key);<br>    <span class="hljs-comment">// 使用SET命令重写</span><br>    f.writeCommand(SADD, key, values);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteZset</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用GET命令获取所有values、scores</span><br>    String[] valueAndScores = ZRANGE(key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;WITHSCORES&quot;</span>);<br>    <span class="hljs-comment">// 使用SET命令重写</span><br>    f.writeCommand(ZADD, key, valueAndScores);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteHash</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用HGETALL命令获取所有values</span><br>    String[] value = HGETALL(key);<br>    <span class="hljs-comment">// 使用HMSET命令重写</span><br>    f.writeCommand(HMSET, key, values);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewriteExpireTime</span><span class="hljs-params">(File file, String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取过期时间戳timestamp，单位：毫秒</span><br>    <span class="hljs-keyword">long</span> timestamp = getExpireTime(key);<br>    <span class="hljs-comment">// 使用PEXPIREAT命令重写</span><br>    f.writeCommand(PEXPIREAT, key, timestamp);<br>&#125;<br></code></pre></td></tr></table></figure><p>在处理集合类型的数据时，为了防止单个key多包含的元素过多，造成客户端缓冲区aofBuf溢出，会循环分批处理这个key中的元素（默认配置64个元素），即最终效果是写入多条命令。</p><p>之前我们提到过，写入AOF时，如果key已经过期，但还没有被删除，那么依然会将其写入到AOF文件内，等到它真正被删除时，再往AOF文件内追加一条DEL删除命令。之所以这样。是因为可以在不会影响AOF文件所表达出的数据库状态的情况下，保持AOF写入原则，忠实地记录写命令的执行情况。</p><p>另外，对于AOF重写，它所想要的效果是用最少的命令表达当前数据库的状态，很显然就不需要写入过期键到AOF重写文件内了。</p><p>触发AOF重写有两种方式：</p><ul><li>执行BGREWRITEAOF命令</li><li>serverCron周期扫描，检查是否符合条件，若符合所有条件则执行AOF重写<ul><li>没有子进程运行（RDB saving、AOF rewriting、其他）</li><li>当前AOF内存文件大小大于阈值，并且，当前AOF内存文件大小与最后一次AOF重写时的文件大小的比值，大于阈值时可以重写</li></ul></li></ul><h2 id="5-4-AOF后台执行重写"><a href="#5-4-AOF后台执行重写" class="headerlink" title="5.4.AOF后台执行重写"></a>5.4.AOF后台执行重写</h2><p>为了不让AOF这类日志操作影响正常的命令处理，Redis决定将AOF重写功能交由子进程执行（fork操作与前文同理），这样做的好处是：</p><ul><li>子进程处理AOF重写期间，主进程还可以继续响应命令</li><li>由于fork会写时复制父进程的当前数据，所以避免了父子进程的数据访问冲突，即在不加锁的情况下保证了数据安全</li></ul><p>如果父进程在AOF期间修改了数据，那么对子进程是不可见的，即产生了数据的不一致性。解决方案是，当Redis fork出子进程准备进入AOF重写时，会在主进程设置一个AOF重写缓冲区，专门记录子进程运行期间产生的不可见的数据更改。此时服务器处理命令的行为是：</p><ol><li>执行客户端命令</li><li>将命令追加到AOF缓冲区（前文介绍的，用于生成AOF文件，不要和AOF重写弄混）</li><li>将命令追加到AOF重写缓冲区</li></ol><p>当子进程处理完重写操作，生成好了新的AOF文件时，会发送一个信号给父进程，父进程在接收到这个信号后，会阻塞命令处理，进行以下行为：</p><ol><li>将AOF重写缓冲区的所有命令追加到新AOF文件末尾，这样一来，新的AOF文件就与当前数据库状态完全一致了</li><li>对新文件进行改名，原子地覆盖现有AOF文件</li></ol><p>至此，AOF重写大功告成。我们还需要回答几个问题：</p><p><strong>为什么不能用AOF缓冲区，要新开辟一片AOF重写缓冲区？</strong></p><p>一，目的不同。AOF缓冲区的目的是伴随着命令的处理，不断地追加AOF文件的。AOF重写缓冲区的目的是解决子进程AOF重写期间造成的数据不一致。</p><p>二，使用方式不同。前文说过，AOF缓冲区会根据具体策略，选择不同时机写入磁盘。AOF重写缓冲区是在子进程处理完成后，一次性追加到新的AOF文件末尾的。</p><p>三，“内容不一致”。AOF缓冲区会根据策略选择不同时机写入磁盘，意味着有可能出现缓冲区内容不断变化。极端一点，有可能在子进程AOF重写期间，AOF缓冲区就因为不断地写入内存，而产生变化。反观AOF重写缓冲区，他的职责是记录所有子进程处理期间的命令，所以不会发生上述情况。</p><p><strong>为什么不直接重写原AOF文件，而是等重写的最后再用生成好的新文件替换原AOF文件？</strong></p><p>一，子进程复用原AOF文件，必然会在某些时候和父进程产生争抢，从而影响父进程性能，这和我们一开始用子进程负责AOF重写的初衷不符。</p><p>二，若AOF重写过程中失败，复用原文件会对其产生污染，导致AOF功能不可用。</p><h1 id="六-事件"><a href="#六-事件" class="headerlink" title="六.事件"></a>六.事件</h1><p>Redis服务器主进程就是一个事件循环处理函数，依次处理文件事件与时间事件：</p><ul><li>文件事件：负责接收客户端的命令请求，以及向客户端发送命令回复。Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件完成一系列网络通信操作。</li><li>时间事件：负责处理像serverCron()函数这样需要定时运行的函数，时间事件就是对这类定时操作的抽象。</li></ul><h2 id="6-1-文件事件"><a href="#6-1-文件事件" class="headerlink" title="6.1.文件事件"></a>6.1.文件事件</h2><h3 id="6-1-1-基于Reactor-I-O多路复用模式的文件事件处理器"><a href="#6-1-1-基于Reactor-I-O多路复用模式的文件事件处理器" class="headerlink" title="6.1.1.基于Reactor I/O多路复用模式的文件事件处理器"></a>6.1.1.基于Reactor I/O多路复用模式的文件事件处理器</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/event-loop.png"></p><p>文件事件处理器由四部分组成：套接字、I/O多路复用程序、文件事件分派器、文件事件处理器：</p><ul><li>套接字<ul><li>文件事件是对套接字操作的抽象。每当一个套接字准备好执行链接应答、写入、读取、关闭等操作时，就会产生一个文件事件。</li></ul></li><li>I/O多路复用程序<ul><li>同时监听多个套接字，既实现了高性能的网络通信模型，又可以很好地与Redis服务器中同样以单线程运行的模块对接。</li><li>尽管由于服务器连接的多个套接字会并发地产生文件事件，但I/O多路复用程序总是会将所有产生事件的套接字，按照先后顺序、同步、每次一个的方案依次加入队列中，然后将套接字传送给文件事件分派器。只有当上一个套接字产生的事件被处理完毕后，I/O多路复用程序才会向文件事件分派器传送下一个套接字。</li></ul></li><li>文件事件分派器<ul><li>接收I/O多路复用程序传送来的套接字，根据套接字产生的事件的类型，为其关联不同的事件处理器进行处理。</li><li>文件事件类型：<ul><li>AE_READABLE：当套接字变得可读时（客户端对套接字执行connect、write、close操作），套接字产生AE_READABLE事件</li><li>AE_WRITABLE：当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件</li><li>当一个套接字同时产生AE_READABLE、AE_WRITABLE两类事件时，服务器会先处理AE_READABLE事件，再处理AE_WRITABLE事件。</li></ul></li></ul></li><li>文件事件处理器<ul><li>执行实际的处理动作。</li><li>分类：<ul><li>连接应答处理器：当服务器初始化的时候，会降<strong>服务器监听套接字的AE_READABLE事件</strong>与连接应答处理器关联起来。当有客户端连接服务器监听套接字时，套接字就会产生AE_READABLE事件，从而引发连接应答处理器的执行，并执行相应的套接字应答操作。</li><li>命令请求处理器：当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将<strong>客户端套接字的AE_READABLE事件</strong>和命令请求处理器关联起来。当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，从而引发命令请求处理器的执行，并执行相应的套接字读取操作。</li><li>命令回复处理器：当服务器有命令回复需要传输给客户端的时候，服务器会将<strong>客户端套接字的AE_WRITABLE事件</strong>和命令响应处理器关联起来。当客户端准备好接收服务器的命令回复的时候，套接字就会产生AE_WRITABLE事件，从而引发命令回复处理器的执行，并执行相应的套接字写入操作。</li><li>其他</li></ul></li></ul></li></ul><h3 id="6-1-2-一次完整的客户端与服务器连接事件示例"><a href="#6-1-2-一次完整的客户端与服务器连接事件示例" class="headerlink" title="6.1.2.一次完整的客户端与服务器连接事件示例"></a>6.1.2.一次完整的客户端与服务器连接事件示例</h3><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/event-loop-demo.png"></p><ol><li>假设Redis服务器已经启动完成，那么此时服务器监听套接字的AE_READABLE事件会与连接应答处理器关联起来，并处于监听状态。</li><li>客户端向服务器发起建立 socket 连接的请求，监听套接字会产生AE_READABLE事件，触发连接应答处理器执行。连接应答处理器会对客户端的连接请求进行应答，创建客户端套接字及客户端状态，并将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，并处于监听状态。</li><li>客户端建立连接后，向服务器发送命令，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行。命令请求处理器读取客户端命令，然后传递给相关程序去执行。</li><li>执行命令获得相应的命令回复后，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器执行。命令回复处理器将命令回复全部写入到套接字中后，就会解除客户端套接字的 AE_WRITEABLE 事件与命令回复处理器的关联。</li><li>命令回复会由套接字负责传输给客户端。</li></ol><h2 id="6-2-时间事件"><a href="#6-2-时间事件" class="headerlink" title="6.2.时间事件"></a>6.2.时间事件</h2><p>时间事件的具体定义结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct aeTimeEvent &#123;<br>    <span class="hljs-comment">/* 全局唯一ID */</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> id; <span class="hljs-comment">/* time event identifier. */</span><br>    <span class="hljs-comment">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span><br>    <span class="hljs-keyword">long</span> when_sec; <span class="hljs-comment">/* seconds */</span><br>    <span class="hljs-comment">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span><br>    <span class="hljs-keyword">long</span> when_ms; <span class="hljs-comment">/* milliseconds */</span><br>    <span class="hljs-comment">/* 时间处理器 */</span><br>    aeTimeProc *timeProc;<br>    <span class="hljs-comment">/* 事件结束回调函数，析构一些资源*/</span><br>    aeEventFinalizerProc *finalizerProc;<br>    <span class="hljs-comment">/* 私有数据 */</span><br>    <span class="hljs-keyword">void</span> *clientData;<br>    <span class="hljs-comment">/* 前驱节点 */</span><br>    struct aeTimeEvent *prev;<br>    <span class="hljs-comment">/* 后继节点 */</span><br>    struct aeTimeEvent *next;<br>&#125; aeTimeEvent;<br></code></pre></td></tr></table></figure><p>时间事件分类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。</li></ul><p>区分时间事件类型的方法是通过时间事件处理器的返回值：</p><ul><li>如果返回值是 <code>AE_NOMORE</code>，那么这个事件是一个定时事件，该事件在到达后会被删除，之后不会再重复。</li><li>如果返回值是非 <code>AE_NOMORE</code> 的值，那么这个事件为周期性事件，当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 when 属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新下去。</li></ul><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/time-event-list.png"></p><p>Redis服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器处理。新产生的时间事件总是插到链表头。由于正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能。</p><p>综上所述，处理时间事件的函数如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">processTimeEvents</span><span class="hljs-params">(aeEventLoop *eventLoop)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maxId = eventLoop-&gt;timeEventNextId-<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/* 遍历服务器中的所有时间事件 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-function">timeEvent in <span class="hljs-title">allTimeEvent</span><span class="hljs-params">()</span>) </span>&#123;<br>        <span class="hljs-keyword">long</span> now_sec, now_ms;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> id;<br><br>        <span class="hljs-comment">/* 删除需要删除的时间事件 */</span><br>        <span class="hljs-keyword">if</span> (timeEvent.id == AE_DELETED_EVENT_ID) &#123;<br>            <span class="hljs-comment">// 从链表中删除</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* id 大于最大maxId,是该循环周期生成的时间事件，不处理 */</span><br>        <span class="hljs-keyword">if</span> (timeEvent.id &gt; maxId) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        aeGetTime(&amp;now_sec, &amp;now_ms);<br>        <span class="hljs-comment">/* 事件已经到达，调用其timeProc函数 */</span><br>        <span class="hljs-keyword">if</span> (timeEvent.whenSec &lt;= now)<br>        &#123;<br>            <span class="hljs-keyword">int</span> retval = timeEvent.timeProc(eventLoop, id, timeEvent.clientData);<br>            <br>            <span class="hljs-comment">/* 如果返回值不等于 AE_NOMORE,表示是一个周期性事件，修改其whenSec和whenMs属性*/</span><br>            <span class="hljs-keyword">if</span> (retval != AE_NOMORE) &#123;<br>                aeAddMillisecondsToNow(retval, timeEvent.whenSec, timeEvent.whenMs);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* 一次性事件，标记为需删除，下次遍历时会删除*/</span><br>                timeEvent.id = AE_DELETED_EVENT_ID;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>serverCron函数默认每100ms执行一次，可以通过修改hz配置来调整其执行周期，它的职责包括：</p><ul><li>更新服务器的各类统计信息</li><li>清理过期键值对</li><li>关闭和清理连接失效的客户端</li><li>尝试进行RDB或AOF持久化</li><li>如果服务器是master，那么对slave进行定期同步</li><li></li></ul><h1 id="七-客户端"><a href="#七-客户端" class="headerlink" title="七.客户端"></a>七.客户端</h1><h1 id="八-服务端"><a href="#八-服务端" class="headerlink" title="八.服务端"></a>八.服务端</h1><p><strong>todo list</strong></p><ul><li><input disabled="" type="checkbox"> 图完善</li><li><input disabled="" type="checkbox"> 源码解读</li><li><input disabled="" type="checkbox"> 最新版本Redis由获取客户端目标数据库的命令了吗？</li><li><input disabled="" type="checkbox"> 为什么Redis不允许对象类型嵌套使用？</li><li><input disabled="" type="checkbox"> Redis最新的时间事件实现</li><li><input disabled="" type="checkbox"> 新版本Redis实现的notifyKeyspaceEvent，有采样机制，会导致大量key过期时阻塞</li><li><input disabled="" type="checkbox"> RDB文件结构及解析工具</li><li><input disabled="" type="checkbox"> 详细说copy on write机制</li><li><input disabled="" type="checkbox"> aof延迟</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础-基本数据结构与对象</title>
    <link href="/2023/05/30/Redis%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/30/Redis%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>我们使用redis时，最直观接触到的就是redis对象及其命令。那我们今天就一起了解下这些对象的实现细节。</p><h1 id="一-基本数据结构"><a href="#一-基本数据结构" class="headerlink" title="一.基本数据结构"></a>一.基本数据结构</h1><h2 id="1-简单动态字符串-SDS"><a href="#1-简单动态字符串-SDS" class="headerlink" title="1.简单动态字符串 SDS"></a>1.简单动态字符串 SDS</h2><p>redis是用C语言实现的，我们需要先认识一下C语言里面的字符串（以下简称C字符串）。</p><p>“Redis\0”这是一个C语言字符串，它具有以下特点：</p><ul><li>必须以 ‘\0’ 空字符结尾</li><li>系统不维护该字符串的长度（不像java的String类型有length），获取字符串长度必须遍历整个字符串，即时间复杂度为 O(n)</li><li>每次更改（缩短或增长）字符串都需要重新内存分配，否则可能造成内存泄漏或缓冲区溢出</li><li>只能保存文本数据</li><li>C语言有相关代码库，支持各类字符串操作</li></ul><p>对于redis而言，只有像log这类字符串一定没有变化的场景会使用C字符串实现以外，其余大多数场景都使用它自己的SDS来实现字符串，例如：</p><ul><li>命令里的key和value SET name “xqz”</li><li>各类嵌套对象 [“a”, “b”]</li><li>缓冲区：AOF缓冲区、客户端的输入输出缓冲区</li><li>等等</li></ul><p>SDS的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDS</span> </span>&#123;<br><span class="hljs-comment">// 记录buf中已经被使用的长度</span><br>  <span class="hljs-keyword">int</span> len;<br>  <span class="hljs-comment">// 记录buf中没有被使用的长度</span><br>  <span class="hljs-keyword">int</span> free;<br>  <span class="hljs-comment">// 实际存储字符串的地方</span><br>  <span class="hljs-comment">// 其末尾以&#x27;\0&#x27;结尾，不记录在上述两个长度内，即SDS实际字符长度为 len+free+1</span><br>  <span class="hljs-keyword">char</span>[] buf;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们可以解释 SDS 名称的由来：</p><ul><li>简单：相比于C字符串，要获取SDS内的字符串长度，可以直接通过len字段，时间复杂度为 O(1)</li><li>动态：每次对 SDS增长时，redis都会自己检查free是否充足，如果不够，那么就会自动进行内存分配以获取足够的空间，即redis保证了不会发生缓冲区溢出</li></ul><p>那么，我们又引申出一个小问题，那就是sds的内存分配策略：</p><ul><li>字符串增长时<ul><li>空间预分配：sds不仅仅申请刚刚可用的新空间，他还会额外申请一些预留空间，以减少重新进行内存分配的次数</li><li><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/sds_edit.png"></li></ul></li><li>字符串减短时<ul><li>惰性空间分配：不会立即重新进行内存分配（释放多余空间），而是提供api，供具体场景在合适的时机释放空闲空间</li></ul></li></ul><p>总结，SDS相比于C字符串的特点是：</p><ul><li>实际也以 ‘\0’ 空字符结尾</li><li>获取字符串长度的时间复杂度为 O(1)</li><li>每次更改（缩短或增长）字符串，调用者不需要重新内存分配，redis会保证不造成内存泄漏或缓冲区溢出</li><li>sds的所有api都是二进制安全的，即sds不仅可以保存文本数据，还可以保存任意格式的二进制数据</li><li>因为实际以 ‘\0’ 字符结尾，可以使用C语言相关代码库</li></ul><h2 id="2-双向链表LinkedList（已经被快速链表代替）"><a href="#2-双向链表LinkedList（已经被快速链表代替）" class="headerlink" title="2.双向链表LinkedList（已经被快速链表代替）"></a><del>2.双向链表LinkedList（已经被快速链表代替）</del></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> </span>&#123;<br>  <span class="hljs-comment">// 头节点指针</span><br>  ListNode head;<br>  <span class="hljs-comment">// 尾节点指针</span><br>  ListNode tail;<br>  <span class="hljs-comment">// 链表总长度</span><br>  uint64 len;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 前一个节点指针</span><br>  ListNode pre;<br>  <span class="hljs-comment">// 后一个节点指针</span><br>  ListNode next;<br>  <span class="hljs-comment">// 指向具体内容的指针</span><br>  Object value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-键值对映射HashTable（字典）"><a href="#3-键值对映射HashTable（字典）" class="headerlink" title="3.键值对映射HashTable（字典）"></a>3.键值对映射HashTable（字典）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dict</span> </span>&#123;<br>  <span class="hljs-comment">// 为对象多态服务，DictType保存了针对每种不同类型键值对的特定函数</span><br>  DictType type;<br>  <span class="hljs-comment">// 为对象多态服务，保存了不同特定函数的可选参数</span><br>  Object privData;<br>  <span class="hljs-comment">// ht[0]指向正在使用的hash表，ht[1]正常情况下指向null，rehash过程中指向即将迁移过去的hash表</span><br>  DictHt[] ht;<br>  <span class="hljs-comment">// rehash索引</span><br>  <span class="hljs-keyword">int</span> rehashidx;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictHt</span> </span>&#123;<br>  <span class="hljs-comment">// hash桶，存储具体数据</span><br>  DictEntry[] table;<br>  <span class="hljs-comment">// 桶大小</span><br>  uint64 size; <br>  <span class="hljs-comment">// 桶已使用大小</span><br>  uint64 used;<br>  <span class="hljs-comment">// 用于计算对象下标，sizemask=size-1</span><br>  uint64 sizemask;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DictEntry</span> </span>&#123;<br>  <span class="hljs-comment">// 只能是字符串类型</span><br>  Object key;<br>  <span class="hljs-comment">// 对象多态</span><br>  <span class="hljs-comment">// 另外，并没有使用字符串对象处理整数和普通对象，下面讲字符串对象时会涉及</span><br>  union &#123;<br>    <span class="hljs-comment">// value类行为对象</span><br>    Object v;<br>    <span class="hljs-comment">// value类型为无符号整数</span><br>    uint64 u64;<br>    <span class="hljs-comment">// value类型为有符号整数</span><br>    int64 s64;<br>  &#125; value;<br>  <span class="hljs-comment">// 拉链法解决hash冲突：key相同的下一个value对象</span><br>  DictEntry next;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然提到hash，那么着重解决一下几个问题：</p><ul><li>hash函数怎么选择？</li><li>hash冲突如何解决？</li><li>如何维护hash冲突的概率？</li></ul><h3 id="3-1-hash函数如何选择？"><a href="#3-1-hash函数如何选择？" class="headerlink" title="3.1.hash函数如何选择？"></a>3.1.hash函数如何选择？</h3><p>redis选用<a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C">murmurhash2</a>算法生成key对应的hash值，记做hash(key)，则最终插入下标index=hash(key) &amp; ht[x].sizemask。这里面信息量比较大，我们一一介绍：</p><ul><li>若N为2的n次幂，则 H%N = H&amp;(N-1)，这是快速计算方式，并且后续会看到redis保证桶大小为2的n次幂（java的HashMap也有类似设计），这里也解释了为什么会有一个sizemask字段</li><li>ht[x]的含义是，若当前字典不是rehash状态，则x=0，否则x=1</li></ul><h3 id="3-2-hash冲突如何解决？"><a href="#3-2-hash冲突如何解决？" class="headerlink" title="3.2.hash冲突如何解决？"></a>3.2.hash冲突如何解决？</h3><p>一般的hash冲突解决方法有两种：开放定址法和拉链法，redis和java.HashMap均采用拉链法，即将hash到相同桶下标的entry组织成一个链表（java的HashMap在链表长度大于8时，会将该链表转换为一棵红黑树，即平衡树，依次来提高检索效率）。</p><p>另外，此处的链表不是双向链表，所以采用头插法快速添加新节点（多嘴说一句，并发环境下，头插法可能产生循环链表问题，jdk8前后的解决方法并不相同，感兴趣的小伙伴可以搜一搜，但是单线程的redis并不存在这个问题）</p><h3 id="3-3-如何维护hash冲突的概率？"><a href="#3-3-如何维护hash冲突的概率？" class="headerlink" title="3.3.如何维护hash冲突的概率？"></a>3.3.如何维护hash冲突的概率？</h3><p>介绍一个概念：负载因子=桶已被使用的大小/桶总大小，可以看出，若负载因子过大，则产生hash冲突的可能性就更高，若负载因子过小，则空间利用率就变低。因此，根据负载因子大小，在合适的时机调整桶大小就变的尤为重要。</p><p>下面是redis执行的rehash的具体步骤：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/rehash.png"></p><ul><li>负载因子过大：<ul><li>服务器没有执行 <a href="https://www.runoob.com/redis/server-bgsave.html">BGSAVE</a> 或 <a href="https://www.runoob.com/redis/server-bgrewriteaof.html">BGREWRITEAOF</a> 命令时，&gt;=1，这是因为这些命令都会采取写时复制的手段来优化子进程的执行效率，那么就需要降低非必要的内存写入操作</li><li>服务器执行 BGSAVE 或 BGREWRITEAOF 命令时，&gt;=5</li></ul></li><li>负载因子过小：&lt;0.1</li></ul><p>最后，需要注意，rehash过程不是一次性完成的，而是延迟、渐进式的完成的，其过程是：</p><ol><li>rehash开始，将rehashidx置为0，代表rehash开始</li><li>其后每次对该字典有增删改查（包括rehash开始时的那一次）操作时，都会将ht[0]桶rehashidx位置上的数据重新写入到ht[1]桶内，删除ht[0]桶rehashidx位置上的所有数据，rehashidx++</li><li>当ht[0]桶上所有数据都迁移完成后，将rehashidx置为-1，代表rehash结束</li></ol><p>很明显，在rehash期间，插入操作会直接在ht[1]桶上完成（保证ht[0]只减不增，另外，先插入到ht[0]再rehash到ht[1]也太傻了），删除、更改、查询操作都会先检索ht[0]，数据不存在时再检索ht[1]得到最终结果</p><h2 id="4-跳表SkipList"><a href="#4-跳表SkipList" class="headerlink" title="4.跳表SkipList"></a>4.跳表SkipList</h2><p>鉴于大学的数据结构课本或者《算法导论》这样的书上都没有跳表的内容，所以我们得先介绍下跳表这种数据结构（这里奉上原始论文，感兴趣的同学可以看看<a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf%EF%BC%89%E3%80%82">https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf）。</a></p><p>这是一个链表：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist1.png"></p><p>我们给他加一点索引，用来加快检索速度：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist2.png"></p><p>当数据量特别大的时候，我们可能需要多层索引，获取更好的检索速度：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist3.png"></p><p>好了，我们可以做一个优化，即相同元素（初始元素及该元素代表的索引）只使用一个节点即可。</p><p>这就是跳表，我们来看下跳表如何检索一个元素（下述跳表中查找71）：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist4.png"></p><p>其时间复杂度 = 索引的高度 * 每层索引遍历元素的个数，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。那么跳表的总高度 h = log2n。并且，上层两个索引中间对应的下层索引个数最多为3，即时间复杂度=O(log2n)。</p><p>空间复杂度显然等于 n/2+n/4+…+n/h=O(n)。</p><p>那么，接下来的问题就变成了，随着元素的插入/删除，我们应该如何去维护跳表的索引，以使其保持优良的性能？</p><p>一种设计方案是，还是假设每两个结点会抽出一个结点作为上一级索引的结点，那么当本层元素大于3时，我们就要将其分裂为两部分，并且在上层添加这两部分的索引。删除同理。好了，说到这你应该意识到，这是B树的设计。</p><p>另一种方案，即跳表天才的设计，用概率来维护索引。即每个元素都有1/2的概率建立上层索引，当数据量足够大时，我们有理由相信这种概率建立起来的索引是离散的，即所有元素不会堆积在一起。</p><p>那么，我们来看一下跳表如何插入元素。假设在我们插入元素时，有一个函数randomLevel(x)，其返回值表示应该为这个元素新建几层索引。例如，randomLevel(x)=2，则新建1层索引。我们保证，randomLevel(x)函数有1/2的概率返回1，有1/4的概率返回2，以此类推。有的小伙伴会问，为什么不是randomLevel(x)=1新建一层索引呢？这是因为，只要randomLevel(x)&gt;1那么就会新建第一层的索引，那么randomLevel(x)=1的概率为1/2，就等同于第一层索引不被建立的概率等于1/2，那么，只要randomLevel(x)=2我们再开始建立索引就可以了。</p><p>我们举一个插入87的例子，randomLevel(87)=3，</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/skiplist5.png"></p><p>最后看一眼删除（删除87），我们只需要该元素整个删除即可（包括该元素代表的索引）：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png"></p><p>至此，我们可以介绍下redis的跳表了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br>  <span class="hljs-comment">// 指向跳表头节点</span><br>  <span class="hljs-comment">// 头节点不是实际的元素节点，即不计算在level、length内</span><br>  SkipListNode header;<br>  <span class="hljs-comment">// 指向跳表尾节点</span><br>  <span class="hljs-comment">// 尾节点是实际的元素节点</span><br>  SkipListNode tail;<br>  <span class="hljs-comment">// 层数最大的节点的层数</span><br>  <span class="hljs-keyword">int</span> level;<br>  <span class="hljs-comment">// 节点个数</span><br>  <span class="hljs-keyword">int</span> length;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListNode</span> </span>&#123;<br>  <span class="hljs-comment">// 分数，redis跳表通过分数作为元素插入位置的依据</span><br>  <span class="hljs-comment">// 分数按从小到大的顺序排列</span><br>  <span class="hljs-comment">// 不同元素分数可以相同，但是对象不能相同。相同分数的不同对象按照字典序排列。</span><br>  <span class="hljs-keyword">double</span> score;<br>  <span class="hljs-comment">// 对象指针</span><br>  Object obj;<br>  <span class="hljs-comment">// 后退指针，指向紧邻的前一个元素。注意，后退指针不参与跳表的索引结构，就像B+树的叶子结点链表一样，将所有的元素节点连接起来。方便检索范围内的所有数据。</span><br>  SkipListNode backward;<br>  <span class="hljs-comment">// 层（上述的各层索引）</span><br>  <span class="hljs-comment">// Level1-Level32，L1可以看做之前讲的基础数据，L2-L32可以看做索引</span><br>  SkipListLevel[] level;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipListLevel</span> </span>&#123;<br>  <span class="hljs-comment">// 前进指针，指向拥有同层索引的下一个节点</span><br>  SkipListNode forward;<br>  <span class="hljs-comment">// 跨度，注意，跨度并不参与实际的检索过程（有疑惑的抛开redis再看看前面的跳表介绍），只是用于计算同层两个节点间的元素个数</span><br>  uint32 span;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们看一下redis如何实现前述的randomLevel(x)函数的：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/randomLevel.png"></p><p>上述代码等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">func <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level+1</span><br>  <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123;<br>    level += <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，redis设置的SKIPLIST_P=0.25，即每4个元素生成一个上层索引</p><h2 id="5-整数集合IntSet"><a href="#5-整数集合IntSet" class="headerlink" title="5.整数集合IntSet"></a>5.整数集合IntSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSet</span> </span>&#123;<br>  <span class="hljs-comment">// 编码方式（注意与之后对象结构内的编码方式区分）</span><br>  <span class="hljs-comment">// 目前支持：int16、int32、int64</span><br>  uint32 encoding;<br>  <span class="hljs-comment">// 集合长度，即元素个数</span><br>  uint32 length;<br>  <span class="hljs-comment">// 具体数据，不会有重复值，按值大小从小往大排列</span><br>  <span class="hljs-comment">// 需要注意，具体数据类型与编码格式相关，并不是int8类型</span><br>  int8[] contents;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入元素的执行步骤：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/intsetAdd.png"></p><p>整数数组的特点是：</p><ul><li>灵活：支持不同类型的整数</li><li>节约内存：并没有一开始就申请int64占用的空间，而是在实际需要时逐步升级</li><li>一旦编码升级，就不会降级了</li></ul><h2 id="6-压缩列表ZipList（已经被快速链表代替）"><a href="#6-压缩列表ZipList（已经被快速链表代替）" class="headerlink" title="6.压缩列表ZipList（已经被快速链表代替）"></a><del>6.压缩列表ZipList（已经被快速链表代替）</del></h2><p>压缩列表是为节约内存而开发的，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。其编码格式为：</p><table><thead><tr><th align="left">记录整个压缩列表占用的内存字节数</th><th align="left">记录压缩列表尾节点距离起始位置的字节数</th><th align="left">记录节点个数</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">特殊值0xFF，标志压缩列表结尾</th></tr></thead><tbody><tr><td align="left">zlbytes</td><td align="left">zltail</td><td align="left">zllen</td><td align="left">entry1</td><td align="left">…</td><td align="left">entryn</td><td align="left">zlend</td></tr><tr><td align="left">4B</td><td align="left">4B</td><td align="left">2B</td><td align="left">不定</td><td align="left">不定</td><td align="left">不定</td><td align="left">1B</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>根据压缩列表地址p和zltail，我们可以计算出尾节点的起始位置p+zltail</li><li>若节点数&lt;65535，则zllen代表真实的节点数量，否则真实数量只能通过遍历压缩列表得到</li></ul><p>其中，entry的编码格式为：</p><table><thead><tr><th align="left">前一节点的长度（单位：B）</th><th align="left">记录了content的数据类型和长度</th><th align="left">具体值</th></tr></thead><tbody><tr><td align="left">previous_entry_length</td><td align="left">encoding</td><td align="left">content</td></tr><tr><td align="left">1B or 5B</td><td align="left">1B、2Bor5B</td><td align="left">不定</td></tr></tbody></table><p>特殊说明：</p><ul><li>previous_entry_length<ul><li>若前一节点长度小于254B，则其长度就保存在1B内</li><li>否则，previous_entry_length长度为5B，其第一字节被设置为固定值0xFE（254），后4字节保存前一节点的实际长度</li></ul></li><li>encoding<ul><li>字节数组编码<ul><li>1B，00开头，content长度由去除头两位的其余位表达</li><li>2B，01开头，content长度由去除头两位的其余位表达</li><li>5B，10开头，content长度由去除头两位的其余位表达</li></ul></li><li>整数编码<ul><li>1B，11开头，不同编码代表了不同的int类型</li><li>特殊的，1111开头，对应节点没有content字段，剩余四位表达具体数据</li></ul></li></ul></li></ul><p>压缩列表的遍历方式：</p><ol><li>根据压缩列表起始地址p和zltail，计算出尾节点的起始位置 pn=p+zltail</li><li>根据pn，获取到pn-1的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>根据pn-1，获取到pn-2的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>…</li><li>根据p1，获取到p0的起始地址、本节点数据的编码和长度，访问本节点数据</li><li>结束遍历</li></ol><p>最后，当我们插入或者删除数据时，有可能会导致原本用1B记录前一节点大小的previous_entry_length不够用了，从而引发一连串的节点更新，这种现象就叫做“连锁更新”。连锁更新时，最终压缩列表的大小需要依次计算得出，时间复杂度为O(n)，但是最终只需要一次内存分配。</p><p>总结下压缩列表的优缺点：</p><ul><li>优点<ul><li>节省空间</li></ul></li><li>缺点<ul><li>因为需要遍历访问，不适合保存过多元素</li><li>因为可能会引发连锁更新，所以不适合保存过大元素</li></ul></li></ul><h2 id="7-快速链表QuickList"><a href="#7-快速链表QuickList" class="headerlink" title="7.快速链表QuickList"></a>7.快速链表QuickList</h2><p>简单说，快速链表=双向链表+压缩列表，即双向链表的每个节点是一个压缩列表。这么做的目的是在获得压缩列表节约空间的好处同时，解决压缩列表无法存储过多元素的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quicklist</span> </span>&#123;<br>    <span class="hljs-comment">// quicklist 的链表头</span><br>    QuicklistNode head;<br>    <span class="hljs-comment">// quicklist 的链表尾</span><br>    QuicklistNode tail;<br>    <span class="hljs-comment">// 所有 ziplist 中的总元素个数</span><br>    <span class="hljs-keyword">long</span> count;<br>    <span class="hljs-comment">// quicklistNodes 的个数</span><br>    <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-comment">// 控制每个node中ziplist的元素个数</span><br>    <span class="hljs-comment">// 负数-n表示ziplist大小小于2^(n+1)KB</span><br>    <span class="hljs-comment">// 正数n表示ziplist元素个数小于n</span><br>    <span class="hljs-keyword">long</span> fill;<br>    <span class="hljs-comment">// 其他</span><br>    ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuicklistNode</span> </span>&#123;<br>    <span class="hljs-comment">// 前一个链表节点</span><br>    QuicklistNode prev;<br>    <span class="hljs-comment">// 后一个链表节点</span><br>    QuicklistNode next;<br>    <span class="hljs-comment">// 本节点是存储处元素的 ziplist</span><br>    <span class="hljs-comment">// 字节形式存储</span><br>    <span class="hljs-keyword">char</span> zl;<br>    <span class="hljs-comment">// ziplist 的字节大小</span><br>    <span class="hljs-keyword">int</span> sz;<br>    <span class="hljs-comment">// ziplist 的元素个数</span><br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-comment">// 原始字节=1</span><br>    <span class="hljs-comment">// 压缩存储=2</span><br>    <span class="hljs-keyword">int</span> encoding;<br>    <span class="hljs-comment">// 存储方式</span><br>    <span class="hljs-comment">// null=1</span><br>    <span class="hljs-comment">// ZIPLIST=2</span><br>    <span class="hljs-keyword">int</span> container;<br>    <span class="hljs-comment">// 数据是否被压缩</span><br>    <span class="hljs-keyword">int</span> recompress;<br>    <span class="hljs-comment">// 数据能否被压缩</span><br>    <span class="hljs-keyword">int</span> attempted_compress;<br>    <span class="hljs-comment">// 预留的 bit 位</span><br>    <span class="hljs-keyword">int</span> extra;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终结果如图所示：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/quicklist.png"></p><p>当往快速链表中插入数据时（以链表tail插入为例），若tail对应的ziplist已满，则需要创建新的node，当前节点的next指向新node，tail也指向新node，把元素插入到新node的ziplist中去。</p><h2 id="8-紧凑链表ListPack"><a href="#8-紧凑链表ListPack" class="headerlink" title="8.紧凑链表ListPack"></a>8.紧凑链表ListPack</h2><h3 id="8-1-编码格式"><a href="#8-1-编码格式" class="headerlink" title="8.1.编码格式"></a>8.1.编码格式</h3><p>本质上说，quickList并没有从根本上解决zipList连锁更新的问题，他只是将连锁更新的范围控制在一个节点内。并且，链表指针也会消耗内存空间，这不符合压缩列表的初衷。因此，根本解决方案就是紧凑列表ListPack。</p><p>压缩列表之所以会出现连锁更新的问题，本质上是因为单个元素大小的变动，会影响其相邻元素的previous_entry_length字段占用的空间大小，从而级联影响下去。那我们就需要在干掉这个previous_entry_length的情况下，依然支持对元素进行遍历。</p><p>我们看看ListPack的编码格式：</p><table><thead><tr><th align="left">记录整个紧凑列表占用的内存字节数</th><th align="left">记录紧凑列表的元素总数</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">具体节点</th><th align="left">特殊值0xFF，标志j紧凑列表结尾</th></tr></thead><tbody><tr><td align="left">totalBytes</td><td align="left">numElements</td><td align="left">element1</td><td align="left">…</td><td align="left">elementn</td><td align="left">listpackEndByte</td></tr><tr><td align="left">4B</td><td align="left">2B</td><td align="left">不定</td><td align="left">不定</td><td align="left">不定</td><td align="left">1B</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>若节点数&lt;65535，则numElements代表真实的节点数量，否则真实数量只能通过遍历紧凑列表得到</li></ul><p>其中，element的编码格式为：</p><table><thead><tr><th align="left">当前元素数据类型以及值长度</th><th align="left">具体值</th><th>当前元素总长度</th></tr></thead><tbody><tr><td align="left">encodingType</td><td align="left">data</td><td>tolLen</td></tr><tr><td align="left">不定</td><td align="left">不定</td><td>不定</td></tr></tbody></table><p>需要特殊说明的：</p><ul><li>encodingType和tolLen一定有值，但是data不一定，因为若data过小，会直接存储在encodingType内（下面会介绍）。</li><li>element只记录了当前元素的长度，所以不会引起压缩列表那样的连锁更新。</li></ul><p>编码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>|xxxxxxx// 表示<span class="hljs-number">7</span>位无符号整数，encodingType后<span class="hljs-number">7</span>位为data<br><span class="hljs-attribute">10</span>|xxxxxx// 表示短字符串，后<span class="hljs-number">6</span>位表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">110</span>|xxxxx// 表示<span class="hljs-number">13</span>位有符号整数，后<span class="hljs-number">5</span>位+下个字节存储具体数字<br><span class="hljs-attribute">1110</span>|xxxx// 表示<span class="hljs-number">12</span>位长度的字符串，后<span class="hljs-number">4</span>位+下个字节表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0000</span>// 表示长字符串，后<span class="hljs-number">4</span>字节表示字符串长度，后续data内存储具体字符串内容<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0001</span>// 表示<span class="hljs-number">16</span>位有符号整数，后<span class="hljs-number">2</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0010</span>// 表示<span class="hljs-number">24</span>位有符号整数，后<span class="hljs-number">3</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0011</span>// 表示<span class="hljs-number">32</span>位有符号整数，后<span class="hljs-number">4</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0100</span>// 表示<span class="hljs-number">64</span>位有符号整数，后<span class="hljs-number">8</span>字节存储具体数字<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">0101</span> - <span class="hljs-number">1111</span>|<span class="hljs-number">1110</span>// 未使用<br><span class="hljs-attribute">1111</span>|<span class="hljs-number">1111</span>// 结尾标志占用<br></code></pre></td></tr></table></figure><p>备注：</p><ul><li>处于复杂度和性能考虑，并未使用1111|0001 - 1111|1110这些编码去表达各种长度的有/无符号整数。</li></ul><p>最后是当前元素总长度的编码方式。由于encodingType及data的长度不固定，所以tolLen的长度也不是固定的。其编码方式是从当前的element的最右侧（结束位置）开始，一字节一字节的解析。其中，每一字节的最高位表示是否还需要更多的字节（0不需要，1需要），剩余7位就是长度的二进制表示部分。我们通过从右往左不断遍历每一字节，获取长度的所有二进制位，最终将他们拼接起来就是tolLen的值了。</p><p>例如，tolLen=500时，500的二进制表示为：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">111110100</span><br></code></pre></td></tr></table></figure><p>那么，我们就需要用两个字节来表示它：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>]<span class="hljs-number">0000011</span> [<span class="hljs-number">1</span>]<span class="hljs-number">1110100</span><br></code></pre></td></tr></table></figure><h3 id="8-2-正向查询元素"><a href="#8-2-正向查询元素" class="headerlink" title="8.2.正向查询元素"></a>8.2.正向查询元素</h3><p>正向遍历使用不到tolLen，我们只需要根据encodingType就可以确定data的起始位置和长度了，并据此计算出tolLen的长度，即整个元素的长度。这个过程是：</p><ol><li>指针跳转到头元素的起始位置</li><li>解析encodingType，获取data的起始位置和长度</li><li>解析data内容</li><li>计算encodingType+data的长度，即为len</li><li>根据len推导出tolLen的长度，即知道了元素的总长度</li><li>跳转指针到下一个元素的起始位置</li></ol><h3 id="8-3-逆向查询元素"><a href="#8-3-逆向查询元素" class="headerlink" title="8.3.逆向查询元素"></a>8.3.逆向查询元素</h3><ol><li>指针跳转到尾元素的结束位置</li><li>从右往左解析当前元素的tolLen</li><li>计算出当前元素的起始位置和前一个元素的结束位置</li><li>从当前元素的起始位置开始，解析encodingType，获取data的起始位置和长度</li><li>解析data内容</li><li>跳转指针到前一个元素的结束位置</li></ol><h1 id="二-拓展数据结构"><a href="#二-拓展数据结构" class="headerlink" title="二.拓展数据结构"></a>二.拓展数据结构</h1><h2 id="1-位图BitMap"><a href="#1-位图BitMap" class="headerlink" title="1.位图BitMap"></a>1.位图BitMap</h2><p>位图底层就是用字符串实现的，适合记录二值状态的数据。众所周知，字符串包含多个字符，一个字符包含多个字节，一个字节又由8个bit位组成，位图正是利用每个bit位存储二值数据。</p><h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2.HyperLogLog"></a>2.HyperLogLog</h2><p>首先需要清楚，HyperLogLog是用来解决基数统计相关问题的。</p><p>这里所谓基数，就是一个集合中不重复的元素个数。举个例子：有一个数字集合{2,1,3,1,2}，它没有顺序，数字也会重复，其基数就是{1,2,3}的长度，即3。</p><p>基数统计就是计算出这个集合的基数，即不重复的元素的个数。HyperLogLog算法就是用来解决基数统计问题的，关于该算法的详情可以看这篇文章<a href="/2023/06/23/%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95/" title="[基数统计算法]">[基数统计算法]</a>。</p><p>可以完成基数统计的方式如下：</p><table><thead><tr><th>数据结构</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HashTable</td><td>准确，没有误差</td><td>内存占用比最大</td></tr><tr><td>BitMap</td><td>准确，没有误差<br />内存占用比HashTable小</td><td>内存占用比HyperLogLog大</td></tr><tr><td>HyperLogLog</td><td>固定占用内存12KB，就可以支持2^64个元素的基数统计</td><td>基于概率的算法，存在误差</td></tr></tbody></table><h2 id="3-GEO"><a href="#3-GEO" class="headerlink" title="3.GEO"></a>3.GEO</h2><p>GEO经常用于LBS，即基于位置的服务，指的是使用地理数据信息向用户提供服务的软件应用，例如附近美食、打车等。众所周知，我们可以使用一组经纬度信息唯一表达地理位置信息。如北京的经纬度坐标是(39.9042, 116.4074)，含义是北京处于北纬39.9042度，东经116.4074度。</p><h3 id="3-1-GEOHash编码"><a href="#3-1-GEOHash编码" class="headerlink" title="3.1.GEOHash编码"></a>3.1.GEOHash编码</h3><p>在Redis中，正是将经纬度信息作为有序集合Sorted Set的score，将业务数据作为value进行存储。但是，数组并不能直接作为score存储，需要将其转换为浮点类型数字，这就是GEOHash编码了。</p><p>经纬度信息的范围都是[-180, 180]，我们可以通过二分查找的方式不断接近真实的经纬度，还是以北京(39.9042, 116.4074)为例：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash1.png"></p><p>如图所示，维度39.9042经过三次二分最终落在区间[0, 45)内，从根节点到叶子节点的路径编码是100，也就是说，我们通过编码100就知道北京的维度在区间[0, 45)内。可想而知，随着上述二叉树的高度不断增高，即叶子节点区间更加精细，我们通过编码得到的经纬度误差也就越低。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash2.png"></p><p>同理，北京的经度编码为110。</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/geohash3.jpg"></p><p>至此，我们实际上是将整个地球的表面切割为一个个小方块，编码位数越长，每个小方块越小，即小方块所代表的经纬度精度越高。</p><p>然后将经纬度的编码进行整合，经度编码全部放在偶数位，纬度编码全部放在奇数位，那北京的最终编码为：111000。如此一来，一般情况下，经纬度相邻的位置，其小方格也相邻，即地理位置也是相邻的。但是，对于一些临界值，经纬度相邻，小方格可能差的很远，所以我们一般通过查询给定小方格四周4到8个小方格来查找相邻地理位置。</p><h1 id="三-对象"><a href="#三-对象" class="headerlink" title="三.对象"></a>三.对象</h1><p>首先，redis数据库中的数据都是通过键值对（字典）的形式组织的。其中，键key永远是字符串对象。</p><p>其次，redis中只有字符串对象可以被嵌套使用，其余对象（list、set、zset、hash对象）都不可以互相嵌套使用。例如，[“a”, “b”]是允许的，但[{“k1”: “v1”}, {“k2”: “v2”}]是不允许的。</p><p>下面是redis对象的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisObject</span> </span>&#123;<br>  <span class="hljs-comment">// 类型</span><br>  uint4 type;<br>  <span class="hljs-comment">// 具体的数据结构</span><br>  uint4 encoding;<br>  <span class="hljs-comment">// 引用计数</span><br>  <span class="hljs-keyword">int</span> refcount;<br>  <span class="hljs-comment">// 对象最后一次被命令程序访问的时间点</span><br>  <span class="hljs-keyword">int</span> lru;<br>  <span class="hljs-comment">// 指针，指向具体对象</span><br>  Object ptr;<br>&#125;<br><br><span class="hljs-comment">// 查看key对应的value.type</span><br>TYPE &#123;key&#125;<br><span class="hljs-comment">// 查看key对应的value.encoding</span><br>OBJECT ENCODING &#123;key&#125;<br></code></pre></td></tr></table></figure><h2 id="1-string对象"><a href="#1-string对象" class="headerlink" title="1.string对象"></a>1.string对象</h2><p>string对象可以用来存储整数（12345）、浮点数（123.45）、字符串（“xqz”），其底层的实现方式是不同的，我们逐个探讨。</p><h3 id="1-1-整数"><a href="#1-1-整数" class="headerlink" title="1.1.整数"></a>1.1.整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = <span class="hljs-keyword">int</span><br>obj.ptr = 具体的整数<br></code></pre></td></tr></table></figure><h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2.字符串"></a>1.2.字符串</h3><p>当创建的字符串长度 &gt; 39B时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = raw<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>当创建的字符串长度 &lt;= 39B时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>可以看到，存储字符串时，底层数据结构都是sds，但是具体的编码方式不同：</p><table><thead><tr><th align="left">编码</th><th align="left">内存结构</th><th align="left">读写操作</th></tr></thead><tbody><tr><td align="left">raw</td><td align="left">obj和sds分开申请，两片独立的内存空间，使用ptr指针连接</td><td align="left">可读/可写</td></tr><tr><td align="left">embstr</td><td align="left">obj和sds同时申请，一片连续的内存空间，使用ptr指针连接</td><td align="left">只读</td></tr></tbody></table><h3 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3.浮点数"></a>1.3.浮点数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = string<br>obj.encoding = embstr<br>obj.ptr = sds对象<br></code></pre></td></tr></table></figure><p>浮点数实际是通过字符串来存储的，在浮点数计算时，redis从sds内取出字符串，转换成浮点数进行计算，并将计算结果再次转换成字符串进行存储。另外，过长的整型数也是通过这种方式存储的。</p><h3 id="1-4-编码转换"><a href="#1-4-编码转换" class="headerlink" title="1.4.编码转换"></a>1.4.编码转换</h3><p>当我们执行操作将整形数据变为字符串时，该对象的编码格式也变成了raw，如 1+”a”这种操作。</p><p>之前也提到，embstr是只读的，所以当我们修改embstr编码的字符串时，其底层编码也会变为raw。</p><h2 id="2-list对象"><a href="#2-list对象" class="headerlink" title="2.list对象"></a>2.list对象</h2><p>同时满足以下两个条件的list对象使用ziplist编码，即压缩列表数据结构，否则使用linkedlist编码，即双向链表数据结构。</p><ol><li>list中元素个数小于512（list-max-ziplist-entries可调）</li><li>list中所有字符串元素长度小于64字节（list-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到linkedlist，将保存在压缩列表的元素遍历取出，转成双向链表节点保存。</p><p>反之，若一开始是linkedlist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><p>另外，redis 3.2版本后引入quicklist数据结构，本文暂不介绍。</p><h3 id="2-1-ziplist编码"><a href="#2-1-ziplist编码" class="headerlink" title="2.1.ziplist编码"></a>2.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><h3 id="2-2-linkedlist编码"><a href="#2-2-linkedlist编码" class="headerlink" title="2.2.linkedlist编码"></a>2.2.linkedlist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = list<br>obj.encoding = linkedlist<br>obj.ptr = 双向链表对象<br></code></pre></td></tr></table></figure><h2 id="3-hash对象"><a href="#3-hash对象" class="headerlink" title="3.hash对象"></a>3.hash对象</h2><p>同时满足以下两个条件的hash对象使用ziplist编码，即压缩列表数据结构，否则使用ht编码，即字典数据结构。</p><ol><li>hash中元素个数小于512（hash-max-ziplist-entries可调）</li><li>hash中所有字符串元素（键或值）长度小于64字节（hash-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在压缩列表的元素遍历取出，转成字典节点保存。</p><p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="3-1-ziplist编码"><a href="#3-1-ziplist编码" class="headerlink" title="3.1.ziplist编码"></a>3.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><p>插入元素时，会先往压缩列表中添加键对象，再往压缩列表中添加值对象。</p><h3 id="3-2-ht编码"><a href="#3-2-ht编码" class="headerlink" title="3.2.ht编码"></a>3.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = hash<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure><h2 id="4-set对象"><a href="#4-set对象" class="headerlink" title="4.set对象"></a>4.set对象</h2><p>同时满足以下两个条件的set对象使用intset编码，即整数集合数据结构，否则使用ht编码，即字典数据结构。</p><ol><li>set中元素个数小于512（set-max-ziplist-entries可调）</li><li>set中所有元素均为整数</li></ol><p>若一开始是intset编码，当上述任一条件被破坏时，都会进行编码转换到ht，将保存在整数集合的元素遍历取出，转成字典节点保存。</p><p>反之，若一开始是ht编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="4-1-intset编码"><a href="#4-1-intset编码" class="headerlink" title="4.1.intset编码"></a>4.1.intset编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = intset<br>obj.ptr = 整数集合对象<br></code></pre></td></tr></table></figure><h3 id="4-2-ht编码"><a href="#4-2-ht编码" class="headerlink" title="4.2.ht编码"></a>4.2.ht编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = set<br>obj.encoding = ht<br>obj.ptr = 字典对象<br></code></pre></td></tr></table></figure><p>实现类似于java的HashSet，即字典键保存数据，字典值为NULL。</p><h3 id="4-3-聚合统计操作"><a href="#4-3-聚合统计操作" class="headerlink" title="4.3.聚合统计操作"></a>4.3.聚合统计操作</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 返回给定所有集合的并集</span><br><span class="hljs-function"><span class="hljs-title">SUNION</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回给定所有集合的并集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SUNIONSTORE</span></span> dest key1 key2 ...<br><br><span class="hljs-comment">// 返回给定所有集合的交集</span><br><span class="hljs-function"><span class="hljs-title">SINTER</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回给定所有集合的交集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SINTERSTORE</span></span> dest key1 key2 ...<br><br><span class="hljs-comment">// 返回key1集合与其他所有集合的差集</span><br><span class="hljs-function"><span class="hljs-title">SDIFF</span></span> key1 key2 ...<br><span class="hljs-comment">// 返回key1集合与其他所有集合的差集，并存储在dest集合中</span><br><span class="hljs-function"><span class="hljs-title">SDIFFSTORE</span></span> dest key1 key2 ...<br></code></pre></td></tr></table></figure><p>需要注意：</p><ul><li>由于这些统计计算比较耗时，执行上述命令可能会阻塞主线程。因此，对于SUNION、SINTER、SDIFF这类纯读命令，可以在从库上执行。</li><li>如果服务器处于集群模式，即数据分散在多个实例上，那么使用上述的统计命令时，可能由于多个key存在多个实例上，导致结果错误或直接报错。即上述命令不支持跨机器查询。</li></ul><p>所以，实际开发中，复杂的聚合统计操作不应该使用Redis完成。</p><h2 id="5-zset有序集合对象"><a href="#5-zset有序集合对象" class="headerlink" title="5.zset有序集合对象"></a>5.zset有序集合对象</h2><p>同时满足以下两个条件的zset对象使用ziplist编码，即压缩列表数据结构，否则使用skiplist编码，这里指跳表+字典数据结构。</p><ol><li>zset中元素个数小于128（zset-max-ziplist-entries可调）</li><li>zset中所有字符串元素长度小于64字节（zset-max-ziplist-value可调）</li></ol><p>若一开始是ziplist编码，当上述任一条件被破坏时，都会进行编码转换到skiplist，将保存在压缩列表的元素遍历取出，转成跳表+字典节点保存。</p><p>反之，若一开始是skiplist编码，之后又同时满足以上两个条件，是不会进行编码转换的。</p><h3 id="5-1-ziplist编码"><a href="#5-1-ziplist编码" class="headerlink" title="5.1.ziplist编码"></a>5.1.ziplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = ziplist<br>obj.ptr = 压缩列表对象<br></code></pre></td></tr></table></figure><p>插入元素时，会遍历压缩列表所有元素，根据score从小往大的顺序（即靠近表头位置的元素score小），先往压缩列表中添加数据对象，再往压缩列表中添加score对象。</p><h3 id="5-2-skiplist编码"><a href="#5-2-skiplist编码" class="headerlink" title="5.2.skiplist编码"></a>5.2.skiplist编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">obj.type = zset<br>obj.encoding = skiplist<br>obj.zsl = 跳表对象<br>obj.dict = 字典对象<br></code></pre></td></tr></table></figure><p>跳表中元素按score从小往大的顺序排列。</p><p>字典键等于数据元素（string类型），字典值等于score（double类型），即该字典的作用时从元素映射到对应score。</p><p>为什么需要跳表+字典两个数据结构？速度。如前所述，跳表可以提供优秀的范围查找能力，字典做不到。字典可以O(1) 地查看元素分值，跳表做不到（需要遍历找到节点）。</p><p>最后一点，跳表与字典对应的底层数据对象，是共用的，这是为了节约空间。</p><h1 id="四-自定义数据结构"><a href="#四-自定义数据结构" class="headerlink" title="四.自定义数据结构"></a>四.自定义数据结构</h1><h2 id="1-自定义新数据类型的底层结构"><a href="#1-自定义新数据类型的底层结构" class="headerlink" title="1.自定义新数据类型的底层结构"></a>1.自定义新数据类型的底层结构</h2><p>我们开发一个新数据类型：单链表。使用singlelist.h文件保存单链表的基本定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleList</span> </span>&#123;<br>    SingleListNode head;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleListNode</span> </span>&#123;<br>    String value;<br>    SingleListNode next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-增加新数据类型的全局定义"><a href="#2-增加新数据类型的全局定义" class="headerlink" title="2.增加新数据类型的全局定义"></a>2.增加新数据类型的全局定义</h2><p>在server.h文件中新增单链表的全局定义。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">...<br><span class="hljs-comment">// 数字7是根据现有枚举值追加的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_SINGLE_LIST 7</span><br></code></pre></td></tr></table></figure><h2 id="3-开发新数据类型的构造和析构函数"><a href="#3-开发新数据类型的构造和析构函数" class="headerlink" title="3.开发新数据类型的构造和析构函数"></a>3.开发新数据类型的构造和析构函数</h2><p>根据Redis规范，新建t_singlelist.c文件保存单链表的各种操作，如构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">SingleList <span class="hljs-title">newSingleList</span><span class="hljs-params">()</span> </span>&#123;<br>    SingleList list = zmalloc(sizeof());<br>    list.head = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>在object.c文件中增加新数据结构的全局创建函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">robj <span class="hljs-title">createSingleList</span><span class="hljs-params">()</span> </span>&#123;<br>    SingleList list = newSingleList();<br>    robj o = createObject(OBJ_SINGLE_LIST, list);<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>createObject函数是Redis提供的创建Redis对象的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">robj <span class="hljs-title">createObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, Object ptr)</span> </span>&#123;<br>    robj o = zmalloc(sizeof());<br>    o.type = type;<br>    o.ptr = ptr;<br>    ...<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数创建过程类似。</p><h2 id="4-开发新数据类型的命令操作"><a href="#4-开发新数据类型的命令操作" class="headerlink" title="4.开发新数据类型的命令操作"></a>4.开发新数据类型的命令操作</h2><p>我们新增一个往单链表末尾插入元素的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SLINSERT key value<br></code></pre></td></tr></table></figure><p>首先，在t_singlelist.c文件中实现该操作的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slinsertCommand</span><span class="hljs-params">(RedisClient c)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在server.h文件中声明这个函数，以便在server.c文件中可以引用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slinsertCommand</span><span class="hljs-params">(RedisClient c)</span></span><br></code></pre></td></tr></table></figure><p>最后，在server.c文件中将命令与实现函数关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">redisCommandTable[] = [<br>    ...<br>    &#123;<span class="hljs-string">&quot;SLINSERT&quot;</span>, slinsertCommand, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;m&quot;</span>, ....&#125;<br>]<br></code></pre></td></tr></table></figure><h1 id="五-对象其他细节"><a href="#五-对象其他细节" class="headerlink" title="五.对象其他细节"></a>五.对象其他细节</h1><h2 id="1-命令类型检查"><a href="#1-命令类型检查" class="headerlink" title="1.命令类型检查"></a>1.命令类型检查</h2><p>大体上可以将redis的操作键的命令分为两类</p><ol><li>可以对任意对象类型生效</li><li>只对命令绑定的对象类型生效</li></ol><p>对于第二种类型命令，redis会根据obj.type字段，在执行命令前主动检查：</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/checkobject.png"></p><h2 id="2-命令多态实现"><a href="#2-命令多态实现" class="headerlink" title="2.命令多态实现"></a>2.命令多态实现</h2><ul><li>基于类型的多态：可以对任意对象类型生效的命令，会根据value对象具体类型，做不同处理</li><li>基于编码的多态：作用到具体对象上的命令，会根据对象编码，调用对应数据结构API实现命令</li></ul><h2 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3.内存回收机制"></a>3.内存回收机制</h2><p>c语言不像java，java虚拟机会帮助程序员管理对象占用的内存，在对象不被使用时自动释放内存。redis使用引用计数算法实现了一套内存管理机制，现简单介绍。</p><p>首先了解下redis对象生命周期</p><p><img src="https://jon-xzzz-image-bed.oss-cn-beijing.aliyuncs.com/blog/jonxzzz/redis/objectlife.png"></p><p>与之对应的，之前说到的obj.refcount值是这样变化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建一个对象时，refcount初始化为1，因为不论有无key对象，服务器都需要持有这个对象</span><br>Object obj = <span class="hljs-keyword">new</span> StringObject();<br><br><span class="hljs-comment">// 对象被新程序使用时，调用incrRefCount(obj)函数，obj.refcount++</span><br><span class="hljs-comment">// 对象不再被新程序使用时，调用decrRefCount(obj)函数，obj.refcount--</span><br>...<br>  <br><span class="hljs-comment">// 最终，调用decrRefCount(obj)函数，将obj.refcount减为0，会导致该对象被redis服务器回收，内存被释放</span><br>decrRefCount(obj);<br></code></pre></td></tr></table></figure><p>涉及到函数列表：</p><table><thead><tr><th align="left">函数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">incrRefCount()</td><td align="left">refcount++</td></tr><tr><td align="left">decrRefCount()</td><td align="left">refcount–</td></tr><tr><td align="left">resetRefCount()</td><td align="left">refcount=0，但是不会释放对象</td></tr></tbody></table><h2 id="4-对象共享机制"><a href="#4-对象共享机制" class="headerlink" title="4.对象共享机制"></a>4.对象共享机制</h2><p>类似于java常量池机制，redis也会将常用字符串做为“常量”共享起来。在redis初始化服务器时，会创建0-9999共一万个整数字符串（通过redis.h/REDIS_SHARED_INTEGERS设置），后续共享使用。这些对象不仅是字符串对象可以共享，前述所有类型对象都可以使用。</p><p>但是，需要注意，redis只支持整数字符串的共享，这主要是因为要共享一个对象，当然需要判断两个引用对应的对象是否一致，整数对象可以在O(1)时间内验证，但当字符串复杂时，或其他结构的对象时（如list），这个验证过程会很消耗CPU并且不可控。</p><p>最后需要注意，当对象被共享时，其refcount++。</p><h2 id="5-对象空转时长"><a href="#5-对象空转时长" class="headerlink" title="5.对象空转时长"></a>5.对象空转时长</h2><p>前面提到的obj.lru记录了该对象最后一次被命令程序访问的时间点。</p><p>我们可以通过 OBJECT IDLETIME 命令查看值对象的 空转时长=当前时间-obj.lru。这个命令比较特殊，不会刷新obj.lru的值。</p><p>空转时长是当服务器内存不够时，用来判断该对象是否可以被回收时使用的，这个之后的专题会详细介绍。</p><p>至此，我们了解了redis所有的对象及其底层数据结构，希望对大家的工作学习有所帮助，谢谢～</p><p><strong>todo list:</strong></p><ul><li><input disabled="" type="checkbox"> 图完善</li><li><input disabled="" type="checkbox"> 源码解读</li><li><input disabled="" type="checkbox"> 指令及对应数据结构操作</li><li><input disabled="" type="checkbox"> 新版本数据结构</li><li><input disabled="" type="checkbox"> 布隆过滤器</li><li><input disabled="" type="checkbox"> Stream</li><li><input disabled="" type="checkbox"> bitcount 命令实现 SWAR算法</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD-003-单元测试</title>
    <link href="/2021/09/16/DDD-003-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/09/16/DDD-003-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>TODO:</p><h2 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h2><p>​    在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p><p>​    程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><p>为什么要写单元测试？</p><p>​    \1. 单元测试可以有效的提高代码的质量，降低线上问题出现的概率。我有若干次在上线前通过单元测试的回归发现现有的改动对之前逻辑产生了影响，出现了bug。</p><p>​    \2. 单元测试可以通过 CI/CD 流水线自动执行，非常方便，在提交到master分支触发单元测试是一个不错的选择。</p><p>​    \3. 如果需要对一块逻辑进行调整，全部成功的单元测试可以让你的安全感大大提升，不用提心吊胆，默默祈祷了。</p><p>​    4 单元测试全部通过，看到一排Tests passed非常有成就感，工作满意度提升。</p><p>​    \5. 单元测试是一个程序员能力的体现，一个优秀的程序员单元测试水平应该是很高的。</p><h2 id="怎样写单元测试？"><a href="#怎样写单元测试？" class="headerlink" title="怎样写单元测试？"></a>怎样写单元测试？</h2><ol><li><p>mockito+powermock+spring-boot-test是个人认为的最佳组合，其中spring-boot-test是为了自动依赖注入，mockito是为了mock对象，powermock可以处理静态方法。</p><p>\2. 针对service层写单元测试，不建议针对storage层写单元测试，个人认为storage层的业务逻辑通常会比较简单，集成测试通过即可。</p><p>\3. 各个单元测试之间是相互独立的。</p><p>\4. 每个单元测试粒度要尽可能小，尽可能做到”单元“。</p><p>\5. 每个单元测试执行时间要尽可能短，所以不建议加载整个spring context，而是按需加载。如果我要测试A类，那么只加载A类以及A类的依赖即可。</p><p>\6. 单元测试要做到和环境无关，因此针对一些数据库操作，rpc调用等都需要mock掉。</p><p>\7. 不要为了单测而单测，每个单元测试应该是有意义的，不要为了代码覆盖率写一些无意义的单元测试。</p><p>\8. 每个单元测试都有保证质量，要有期望值，比如输出多少，报什么错，执行次数等等。</p><p>\9. 单元测试的维护也是需要成本的，尽量通俗易懂，宁缺毋滥。</p><p>\10. 单元测试中的数据构造是一个比较繁琐的过程，可以将数据构造定义为factory，便于以后的复用。</p></li></ol><h2 id="demo示例"><a href="#demo示例" class="headerlink" title="demo示例"></a>demo示例</h2><p>测试的类为MatchBySkillScoreFilter，测试的方法为execute()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以需要测试的类作为启动器</span><br><span class="hljs-meta">@ContextConfiguration(classes = MatchBySkillScoreFilter.class)</span><br><span class="hljs-comment">// 测试运行于Spring测试环境</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatchBySkillScoreFilterTest</span> </span>&#123;<br><br>    <span class="hljs-comment">// 需要执行单元测试的类</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MatchBySkillScoreFilter matchBySkillScoreFilter;<br><br>    <span class="hljs-comment">// 使用@MockBean来mock代理类</span><br>    <span class="hljs-meta">@MockBean</span><br>    <span class="hljs-keyword">private</span> KidOtProxy kidOtProxy;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回优秀良好的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义stub</span><br>        Mockito.when(kidOtProxy.getTeacherTeachingScoreByOtIds(Matchers.any()))<br>                .thenReturn(TeacherRecommendFactory.buildTTeacherTeachingSKillScoreList());<br>        <span class="hljs-comment">// 定义测试输入内容</span><br>        TeacherRecommendContext teacherRecommendContext = TeacherRecommendFactory.buildTeacherRecommendContext();<br>        <span class="hljs-comment">// 执行service层逻辑</span><br>        List&lt;Long&gt; teacherIds = matchBySkillScoreFilter.execute(teacherRecommendContext, TeacherRecommendFactory.buildTeacherIdList()).getTeacherIdList();<br>        <span class="hljs-comment">// 验证输出结果与预期的是否一致</span><br>        Assert.assertEquals(<span class="hljs-number">2L</span>, (<span class="hljs-keyword">long</span>) teacherIds.get(<span class="hljs-number">0</span>));<br>        Assert.assertEquals(<span class="hljs-number">2</span>, teacherIds.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单元测试量化指标"><a href="#单元测试量化指标" class="headerlink" title="单元测试量化指标"></a>单元测试量化指标</h2><ol><li>覆盖率，即测试代码/全部代码，可以通过idea run with coverage查看，更专业的是使用jacoco，有两者的统计方式不完全相同，得出的覆盖率也有所差异。</li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li>直接使用mockito的@InjectMocks，@Mock和@Spy执行速度更快，为什么不使用？</li></ol><p>​     mockito原生的注解对依赖的支持不够友好，尤其是在依赖关系比较复杂的情况下。而spring作为依赖注入的专家，写起来还是很舒服的。</p><p>   \2. 为什么不使用@SpringBootTest(classes = MatchBySkillScoreFilter.class)而使用@ContextConfiguration?</p><p>​     “天下武功，唯快不破”，单元测试强调一个“快”字，@SpringBootTest注解功能强大，单元测试用不到，代价是在启动时加载内容会多一些，速度也会相应慢不少。</p><p>​     上面的例子，@SpringBootTest加载的bean有25个，applicationListeners为16个</p><p>​     <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_10-14-30.png?version=1&modificationDate=1621908871000&api=v2" alt="img"></p><p>​    <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_12-1-36.png?version=1&modificationDate=1621915297000&api=v2" alt="img"></p><p>​    @ContextConfiguration加载的bean只有20个,applicationListeners为0个</p><p>   <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_10-19-29.png?version=1&modificationDate=1621909170000&api=v2" alt="img"></p><p>  <img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-5-25_11-58-48.png?version=1&modificationDate=1621915129000&api=v2" alt="img"></p><p>​    \3. 还有哪些单元测试例子可以参考？</p><p>​     试听课重构项目conan-zis-trial-class中写了若干单元测试，项目的单测覆盖率超过30%，可以参考，如果有疑问欢迎一起学习讨论。</p><p><img src="https://confluence.zhenguanyu.com/download/attachments/163943076/image2021-8-3_14-5-1.png?version=1&modificationDate=1627970706000&api=v2" alt="img"></p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol><li><a href="https://blog.csdn.net/weixin_33682719/article/details/93835689">阿里巴巴编码规范-单元测试</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">维基百科-单元测试</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Domain Driven Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-003-REST</title>
    <link href="/2021/09/08/SAC-003-REST/"/>
    <url>/2021/09/08/SAC-003-REST/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>架构级别的所有设计决策都应该在所设计系统的功能、行为和社会需求的背景下做出，这是一个同样适用于软件架构和传统建筑架构领域的原则。“形式追随功能”的准则来自数百年失败的构建项目的经验，但经常被软件从业者忽视。</p><p>改变应用程序的交互方式对性能的影响比所使用的通信协议更大。</p><p>一般而言，基于网络的体系结构和软件体系结构之间的主要区别在于，如果可以在运行时基于组件的位置选择更有效的机制，则组件之间的通信仅限于消息传递或等效于消息传递。</p><p>分布式系统在用户看来就像一个普通的集中式系统，但运行在多个独立的 CPU 上。相比之下，基于网络的系统是那些能够跨网络运行的系统，但不一定以对用户透明的方式运行。在某些情况下，用户需要了解需要网络请求的操作与可在其本地系统上满足的操作之间的区别，特别是当网络使用意味着额外的交易成本时 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。</p><p>应用程序软件架构是整个系统的抽象级别，其中用户操作的目标可表示为功能架构属性。</p><p>这与网络抽象形成对比，网络抽象的目标是将位从一个位置移动到另一个位置，而不考虑为什么移动这些位。只有在应用程序级别，我们才能根据每个用户操作的交互次数、应用程序状态的位置、所有数据流的有效吞吐量（相对于单个数据流的潜在吞吐量）来评估设计权衡)、每个用户操作执行的通信范围等。</p><p>基于网络的应用程序的性能首先受应用程序需求的约束，然后是选择的交互方式，其次是实现的架构，最后是每个组件的实现。</p><p>关于基于网络的应用程序的一个有趣观察是，最好的应用程序性能是通过不使用网络来获得的。这实质上意味着基于网络的应用程序最有效的架构风格是那些在可能的情况下可以有效地最大限度地减少网络使用的风格，通过重用先前的交互（缓存），减少网络交互的频率与用户操作（复制数据和断开连接的操作）相关，或者通过将数据处理移动到更靠近数据源（移动代码）来消除某些交互的需要。</p><p>可修改性是指对应用程序架构进行更改的难易程度。可修改性可以进一步分解为可进化性、可扩展性、可定制性、可配置性和可重用性，如下所述。基于网络的系统的一个特别关注点是动态可修改性，其中对已部署的应用程序进行修改而无需停止和重新启动整个系统。</p><p>即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。由于参与基于网络的应用程序的组件可能分布在多个组织边界，因此系统必须为渐进的、碎片化的变化做好准备，在这种变化中，新旧实现并存，同时又不妨碍新实现利用其扩展功能。</p><p>构建软件的目的不是创建特定的交互拓扑或使用特定的组件类型——而是创建一个满足或超过应用程序需求的系统。为系统设计选择的架构风格必须符合这些需求，而不是相反。因此，为了提供有用的设计指导，架构风格的分类应该基于这些风格所引发的架构特性。</p><p>Berners-Lee [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_20">20</a> ] 写道，“Web 的主要目标是成为一个共享的信息空间，通过它人和机器可以进行通信。” 人们需要一种方法来存储和构建他们自己的信息，无论是永久的还是短暂的，以便他们自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护本地副本。</p><p>该系统的预期最终用户位于世界各地，通过互联网连接的各个大学和政府高能物理研究实验室。他们的机器是终端、工作站、服务器和超级计算机的异构集合，需要操作系统软件和文件格式的大杂烩。信息范围从个人研究笔记到组织电话列表。面临的挑战是构建一个系统，该系统将为这种结构化信息提供普遍一致的接口，可在尽可能多的平台上使用，并且随着新人员和组织加入项目而逐步部署。</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此体系结构需要最大限度地减少网络交互（数据传输协议内的往返）。</p><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p><p>假设 I：WWW 体系结构背后的设计原理可以用一种体系结构风格来描述，该体系结构风格由应用于 Web 体系结构中元素的一组约束组成。</p><p>假设二：可以在 WWW 架构风格中添加约束，以推导出一种新的混合风格，更好地反映现代 Web 架构所需的属性。</p><p>假设 III：可以将修改 Web 架构的建议与更新的 WWW 架构风格进行比较，并在部署之前分析冲突。</p><h1 id="XML-RPC"><a href="#XML-RPC" class="headerlink" title="XML-RPC"></a>XML-RPC</h1><p><strong>XML-RPC</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a>（Remote Procedure Call，RPC）的<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算</a><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2%E5%8D%94%E8%AD%B0">协议</a>，通过<a href="https://zh.wikipedia.org/wiki/XML">XML</a>将调用函数封装，并使用<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>协议作为发送机制。</p><p>XML-RPC 消息是一个 HTTP-POST 请求。请求的正文采用 XML 格式。一个过程在服务器上执行，它返回的值也采用 XML 格式。</p><p>过程参数可以是标量、数字、字符串、日期等；也可以是复杂的记录和列表结构。</p><p>下面是一个 XML-RPC 请求的例子：</p><p>必须指定用户代理和主机。</p><p>内容类型是 text/xml。</p><p>必须指定 Content-Length 并且必须正确。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">POST /RPC2 HTTP/1.0<br>User-Agent: Frontier/5.1.2 (WinNT)<br>Host: betty.userland.com<br>Content-Type: text/xml<br>Content-length: 181<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodCall</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">methodName</span>&gt;</span>examples.getStateName<span class="hljs-tag">&lt;/<span class="hljs-name">methodName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i4</span>&gt;</span>41<span class="hljs-tag">&lt;/<span class="hljs-name">i4</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodCall</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是对 XML-RPC 请求的响应示例：</p><p>除非出现低级错误，否则总是返回 200 OK。</p><p>内容类型是 text/xml。Content-Length 必须存在且正确。</p><p>响应的主体是单个 XML 结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 158<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:08 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">params</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>South Dakota<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">params</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>故障示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Connection: close<br>Content-Length: 426<br>Content-Type: text/xml<br>Date: Fri, 17 Jul 1998 19:55:02 GMT<br>Server: UserLand Frontier/5.1.2-WinNT<br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">methodResponse</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">fault</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">struct</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultCode<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">int</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">int</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>faultString<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Too many parameters.<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">struct</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">fault</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">methodResponse</span>&gt;</span><br></code></pre></td></tr></table></figure><p>XML-RPC发表于1998年，由<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>（<a href="https://zh.wikipedia.org/w/index.php?title=UserLand_Software&action=edit&redlink=1">UserLand Software</a>）的<a href="https://zh.wikipedia.org/w/index.php?title=Dave_Winer&action=edit&redlink=1">Dave Winer</a>及<a href="https://zh.wikipedia.org/wiki/Microsoft">Microsoft</a>共同发表[<a href="https://zh.wikipedia.org/wiki/XML-RPC#cite_note-2">2]</a>。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的<a href="https://zh.wikipedia.org/wiki/SOAP">SOAP</a>协议。</p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>SOAP 的最初意图相当温和：编写如何发送 <em>瞬态</em>XML 文档以触发远程主机上的操作或响应的方法。OAP 1.2 版提供了基于 XML 的信息的定义，该信息可用于在分散的分布式环境中的对等点之间交换结构化和类型化信息。</p><p><strong>SOAP</strong>（原为<strong>Simple Object Access Protocol</strong>的<a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E5%86%99">首字母缩写</a>，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，使用在计算机网络<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1">Web服务</a>（web service）中，交换带结构的信息。SOAP为了简化网页服务器（Web Server）从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>通信协议，遵从<a href="https://zh.wikipedia.org/wiki/XML">XML</a>格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><p>目前SOAP 1.1版是业界共同的标准，属于第二代的XML协议（第一代具主要代表性的技术为XML-RPC以及WDDX）</p><p>用一个简单的例子来说明SOAP使用过程，一个SOAP消息可以发送到一个具有Web Service功能的Web站点，例如，一个含有房价信息的数据库，消息的参数中标明这是一个查询消息，此站点将返回一个XML格式的信息，其中包含了查询结果（价格，位置，特点，或者其他信息）。由于数据是用一种标准化的可分析的结构来传递的，所以可以直接被第三方站点所利用。</p><ul><li>SOAP封装（envelope）：定义了一个框架，描述消息中的内容是什么、是谁发送的、谁应当接受并处理它以及如何处理它们；</li><li>SOAP编码规则（encoding rules）：定义了一种<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的机制，用于表示应用程序需要使用的数据类型的实例；</li><li>SOAP RPC表示（RPC representation）：定义了一个协定，用于表示远程过程调用和应答；</li><li>SOAP绑定（binding），它定义了SOAP使用哪种协议交换信息。使用<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>/<a href="https://zh.wikipedia.org/wiki/TCP">TCP</a>/<a href="https://zh.wikipedia.org/wiki/UDP">UDP</a>协议都可以。</li></ul><p>把SOAP绑定到HTTP的方式，同时利用了SOAP的样式和分散的灵活性特点以及HTTP的丰富特征库的优点。在HTTP上传送SOAP并不意味着SOAP会覆盖现有的HTTP语义，而是HTTP上的SOAP语义会自然地映射到HTTP语义。在使用HTTP作为协议绑定的场合中，RPC请求映射到HTTP请求上，而RPC应答映射到HTTP应答。然而，在RPC上使用SOAP并不仅限于HTTP协议绑定。</p><p>SOAP使用因特网应用层协议作为其传输协议。<a href="https://zh.wikipedia.org/wiki/SMTP">SMTP</a>以及<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>协议都可以用来传输SOAP消息，但是由于HTTP在如今的因特网结构中工作得很好，特别是在网络防火墙下仍然正常工作，所以被广泛采纳。SOAP亦可以在<a href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>上传输。</p><p>SOAP的消息格式采用<a href="https://zh.wikipedia.org/wiki/XML">XML</a>。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>定义了 SOAP 信封，它是一种结构，它定义了一个整体框架，用于表示 SOAP 消息的内容，确定谁应该处理全部或部分消息，以及处理这些部分是可选的还是强制性的。它还定义了一个协议绑定框架，它描述了如何编写将 SOAP 绑定到另一个底层协议的规范。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a>定义了<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP</a>的数据模型，一种特定的数据类型编码方案，可用于传送远程过程调用 (RPC)，以及[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1] 中</a>定义的底层协议绑定框架的一个具体实现。此绑定允许将 SOAP 消息作为 HTTP POST 请求和响应的有效负载进行交换，或者作为对 HTTP GET 的响应中的 SOAP 消息进行交换。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>描述了一个抽象特性，用于优化特定类型内容的 SOAP 消息的有线格式，以及它在 HTTP 绑定中实现的具体实现，同时仍将 SOAP 消息建模为单个 XML 信息集.</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP]</a>定义了一种更有效地序列化具有二进制内容的 XML 信息集的约定。 [<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L9527">MTOM]</a>利用 [ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L3777">XOP</a> ] 格式来优化 SOAP 消息的传输。</p><p>[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L4299">ResRep]</a>指定了一个 SOAP 头块，它携带 Web 资源的表示，这是处理 SOAP 消息所需要的，但接收者不愿意或不能通过取消引用消息中携带的资源的 URI 来获得。</p><p>SOAP 从根本上是一种无状态的单向消息交换范例，但应用程序可以通过将此类单向交换与底层协议提供的功能相结合来创建更复杂的交互模式（例如，请求/响应、请求/多响应等）和/或特定于应用程序的信息。SOAP 对它所传达的任何特定于应用程序的数据的语义保持沉默，因为它涉及诸如 SOAP 消息的路由、可靠的数据传输、防火墙穿越等问题。但是，SOAP 提供了一个框架，通过该框架，特定于应用程序的信息可以以可扩展的方式传达。此外，SOAP 提供了 SOAP 节点在接收 SOAP 消息时采取的所需操作的完整描述。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/primer-figure-1.png" alt="primer-figure-1"></p><p>SOAP标头元素是可选的，但它已被包括在示例来解释SOAP的某些特征。SOAP 标头是一种扩展机制，它提供了一种在 SOAP 消息中传递不是应用程序有效负载的信息的方法。这种“控制”信息包括例如与消息处理相关的传递指令或上下文信息。这允许以特定于应用程序的方式扩展 SOAP 消息。该元素的直接子元素<code>env:Header</code>称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#encapsulation"> 标头块</a>，代表数据的逻辑分组，如下所示，可以单独针对 SOAP 节点，这些节点在从发送方到最终接收方的消息路径中可能会遇到。SOAP 标头的设计考虑到 SOAP 的各种用途，其中许多将涉及其他 SOAP 处理节点（称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts"> SOAP 中介）</a>的参与，沿着从<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">初始 SOAP 发送方</a>到<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">最终 SOAP 接收</a><a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">方</a>的消息路径。这允许 SOAP 中介提供增值服务。标题，如后所示，可以被沿<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#senderreceiverconcepts">SOAP 消息路径</a>遇到的 SOAP 节点检查、插入、删除或转发. （不过，应该记住，SOAP 规范不处理头元素的内容，或者 SOAP 消息如何在节点之间路由，或者确定路由的方式等等。这些是整个应用程序的一部分，并且可能是其他规范的主题。）</p><p>SOAP Version 1.2 是一个简单的消息传递框架，用于在初始 SOAP 发送方和最终 SOAP 接收方之间传输以 XML 信息集形式指定的信息。更有趣的场景通常涉及这两个节点之间的多个消息交换。最简单的这种交换是请求-响应模式。[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R11">SOAP 1.1</a> ] 的一些早期使用强调使用这种模式作为传送远程过程调用 (RPC) 的手段，但重要的是要注意并非所有 SOAP 请求-响应交换都可以或需要建模为 RPC。当需要对某个程序行为建模时使用后者，交换的消息符合远程调用及其返回的预定义描述。比请求-响应模式所涵盖的更多的使用场景集可以简单地建模为在 SOAP 消息中交换的基于 XML 的内容以形成来回“对话”，其中语义处于发送和接收应用程序。</p><p>SOAP 1.2 版的设计目标之一是使用 XML 的可扩展性和灵活性封装远程过程调用功能。尽管用于 RPC 的 SOAP 的大多数示例都使用 HTTP 协议绑定，但它并不仅限于这种方式。要调用 SOAP RPC，需要以下信息：</p><ol><li>目标 SOAP 节点的地址。</li><li>过程或方法名称。</li><li>要传递给过程或方法的任何参数的标识和值以及任何输出参数和返回值。</li><li>用于识别作为 RPC 实际目标的 Web 资源的参数的明确分离，与传送用于处理目标资源调用的数据或控制信息的参数形成对比。</li><li>将用于传达 RPC 的消息交换模式，以及要使用的所谓“Web 方法”（稍后将详细介绍）的标识。</li><li>可选地，可以作为 SOAP 头块的一部分携带的数据。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:reference</span>&gt;</span>uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:20:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">m:reservation</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itinerary</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-14<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>late afternoon<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>&gt;</span>aisle<span class="hljs-tag">&lt;/<span class="hljs-name">p:seatPreference</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span>Los Angeles<span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span>New York<span class="hljs-tag">&lt;/<span class="hljs-name">p:arriving</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureDate</span>&gt;</span>2001-12-20<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureDate</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:departureTime</span>&gt;</span>mid-morning<span class="hljs-tag">&lt;/<span class="hljs-name">p:departureTime</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:seatPreference</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itinerary</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">q:lodging</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:q</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/hotels&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">q:preference</span>&gt;</span>none<span class="hljs-tag">&lt;/<span class="hljs-name">q:preference</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">q:lodging</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Header</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">m:reservation</span> <span class="hljs-attr">xmlns:m</span> =<span class="hljs-string">&quot;http://travelcompany.example.org/reservation&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   &lt; m:reference&gt;uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d<span class="hljs-tag">&lt;/<span class="hljs-name">m:reference</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">m:dateAndTime</span>&gt;</span>2001-11-29T13:35:00.000-05:00<span class="hljs-tag">&lt;/<span class="hljs-name">m:dateAndTime</span>&gt;</span> <br>  &lt;/m:reservation &gt; <br>  <span class="hljs-tag">&lt;<span class="hljs-name">n:passenger</span> <span class="hljs-attr">xmlns:n</span>=<span class="hljs-string">&quot;http://mycompany.example.com/employees&quot;</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">env:role</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope/role/next&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">env</span> <span class="hljs-attr">:mustUnderstand</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">n:name</span>&gt;</span>Åke Jógvan Øyvind<span class="hljs-tag">&lt;/<span class="hljs-name">n:name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">n:passenger</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Header</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">p:itineraryClarification</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/reservation/travel&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:departure</span> &gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:departing</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>          JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p:departing</span>&gt;</span> <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:departure</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">p:return</span>&gt;</span> <br>     <span class="hljs-tag">&lt;<span class="hljs-name">p:arriving</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>         JFK LGA EWR <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">p:airportChoices</span>&gt;</span> <br>     &lt;/p:arriving &gt; <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p:return</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p:itineraryClarification</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env:Envelope</span> <span class="hljs-attr">xmlns:env</span>=<span class="hljs-string">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">xmlns:rpc</span>=<span class="hljs-string">&#x27;http://www.w3.org/2003/05/soap-rpc&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">env:Body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">env:Fault</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Code</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>env:Sender<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">env:Subcode</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">env:Value</span>&gt;</span>rpc:BadArguments<span class="hljs-tag">&lt;/<span class="hljs-name">env:Value</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">env:Subcode</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Code</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Reason</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span>Processing error<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">env:Text</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;cs&quot;</span>&gt;</span>Chyba zpracování<span class="hljs-tag">&lt;/<span class="hljs-name">env:Text</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Reason</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">env:Detail</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">e:myFaultDetails</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:e</span>=<span class="hljs-string">&quot;http://travelcompany.example.org/faults&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:message</span>&gt;</span>Name does not match card number<span class="hljs-tag">&lt;/<span class="hljs-name">e:message</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">e:errorcode</span>&gt;</span>999<span class="hljs-tag">&lt;/<span class="hljs-name">e:errorcode</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">e:myFaultDetails</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">env:Detail</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">env:Fault</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">env:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">env:Envelope</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>头块和正文的进一步处理取决于SOAP 节点为处理给定消息所承担的<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts"> 角色</a>。SOAP 定义了（可选）<code>env:role</code>属性 - 在语法上， <code>xs:anyURI</code>- 可能出现在头块中，它标识该头块的预期目标所扮演的角色。如果 SOAP 节点承担由 URI 的值标识的角色，则它需要处理头块。</p><p>为了确保 SOAP 节点不会忽略对应用程序的总体目的很重要的头块，SOAP 头块还提供了附加的可选属性<code>env:mustUnderstand</code>，如果为“true”，则意味着目标 SOAP 节点<em>必须</em>根据该块的规范处理该块。</p><p>为了规避处理模型的默认规则，使用附加属性标记标题块<code>env:relay</code> 值为“true”时允许中介在它选择不处理它的情况下转发针对它自己的标头块。</p><p>SOAP 消息可以使用各种“底层”协议进行交换，包括其他应用层协议。SOAP 消息如何使用底层协议从一个 SOAP 节点传递到另一个节点的规范称为<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#concepts">SOAP 绑定</a>。[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1092">SOAP Part1]</a>以[ <a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#R12">XML Infoset</a> ]的形式定义了一个SOAP 消息，即，根据称为the <code>env:Envelope</code>（参见<a href="http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#soapenv">SOAP Part 1，第5 节</a>）的抽象“文档”的元素和属性信息项 。但是，SOAP 消息可能会在发送方和最终接收方之间经过几跳，其中每一跳可能是不同的协议绑定。换言之，在一个跳跃中由协议绑定支持的特征（例如，消息相关性、可靠性等）可能不被沿消息路径的另一个支持。SOAP 本身并没有提供任何机制来隐藏不同底层协议提供的特性差异。但是，特定应用程序需要的任何端到端或多跳特性，但在<em>预期</em>消息路径上的底层基础设施中可能不可用，可以通过作为 SOAP 的一部分携带来补偿消息信息集，即作为某个模块中指定的 SOAP 头块。应用程序设计者必须解决许多问题才能完成特定的应用程序语义，包括如何利用可用于所选环境的底层协议的本机特性</p><p>功能描述由 URI 标识，因此所有引用它的应用程序都确保具有相同的语义。特征由<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#bindprops">属性</a>限定，提供有助于实现该功能的附加信息。当 RPC 定义使得其方法描述的所有部分都可以描述为资源标识时，RPC 的整个目标可以由 URI 标识。如果应用程序需要使用只能在 SOAP 信息集中具有特定于绑定的表达式的功能，即使用 SOAP 标头块，则应用程序必须选择 HTTP POST 方法，并在请求正文中包含 SOAP 消息.如果 RPC 描述包含非资源识别的数据（参数），它还需要使用通过 HTTP POST 实现的<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>。即使在这种情况下，带有 SOAP 消息的 HTTP POST 也可以以 Web 友好的方式表示。与 GET 的使用一样，[<a href="https://www.w3.org/TR/2007/REC-soap12-part0-20070427/#L1098">SOAP Part2]</a> 建议在一般情况下，在 HTTP 请求 URI 中标识用于标识请求被 POST 到的资源的 SOAP 消息的任何部分。当然，相同的参数可以保留在 SOAP<code>env:Body</code>元素中。（在基于 SOAP 的 RPC 的情况下，参数必须保留在主体中，因为这些参数与接收应用程序期望的过程/方法描述相关。）</p><p>SOAP 规范中的建议是以 Web 架构兼容的方式使用 URI - 即作为资源标识符 - 无论使用的是 GET 还是 POST。</p><p>HTTP 具有众所周知的连接模型和消息交换模式。客户端通过 URI 识别服务器，使用底层 TCP/IP 网络连接到它，发出 HTTP 请求消息并通过相同的 TCP 连接接收 HTTP 响应消息。HTTP 隐式地将其请求消息与其响应消息相关联；因此，使用此绑定的应用程序可以选择推断 HTTP 请求消息正文中发送的 SOAP 消息与 HTTP 响应中返回的 SOAP 消息之间的相关性。类似地，HTTP 通过 URI 标识服务器端点，即<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2">Request-URI</a>，它也可以用作服务器上 SOAP 节点的标识。HTTP 允许在初始客户端和由 Request-URI 标识的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html#sec1.3">源服务器</a>之间存在多个中介 ，在这种情况下，请求/响应模型是一系列这样的对。但是请注意，HTTP 中介与 SOAP 中介不同。SOAP Part2中的 HTTP 绑定利用<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#WebMethodFeature">SOAP Web 方法特性</a>来允许应用程序选择所谓的 Web 方法——将其限制为 GET 或 POST 之一——以通过 HTTP 消息交换使用。此外，它还利用了两种消息交换模式，为应用程序提供了两种通过 HTTP 交换 SOAP 消息的方式：1) 使用 HTTP POST 方法在 HTTP 请求和响应消息的正文中传送 SOAP 消息，以及 2)在 HTTP 请求中使用 HTTP GET 方法在 HTTP 响应的正文中返回 SOAP 消息。第一种使用模式是称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep">SOAP 请求-响应消息交换模式</a>的绑定特性的 HTTP 特定实例，而第二种使用称为<a href="http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#soapresmep">SOAP 响应消息交换模式</a>。由于 HTTP SOAP GET 用法不允许请求中包含 SOAP 消息，因此在出站交互中需要功能的应用程序显然不能由 SOAP 信息集中的绑定特定表达式（即，作为 SOAP 标头块）支持利用这种消息交换模式。请注意，HTTP POST 绑定可用于所有情况。SOAP 使用 HTTP 传输，遵循 HTTP 状态代码的语义以在 HTTP 中传递状态信息。</p><p>万维网最核心的概念之一是作为资源标识符的 URI。使用 HTTP 绑定并希望与其他 Web 软件互操作的 SOAP 服务应该使用 URI 来寻址其服务中的所有重要资源。例如，万维网的一个非常重要（实际上占主导地位）的用途是纯信息检索，其中由 URI 标识的可用资源的表示是使用 HTTP GET 请求获取的，而不会以任何方式影响资源。（这在 HTTP 术语中称为<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1">安全且幂等的方法</a>。）关键点是资源的发布者提供其 URI，消费者可以“获取”该 URI。在许多情况下，SOAP 消息被设计用于纯粹用于信息检索的用途，例如请求某些资源（或对象，在编程术语中）的状态，而不是执行资源操作的用途。在这种情况下，使用 SOAP 主体来携带状态请求，主体的一个元素代表所讨论的对象，被视为与 Web 精神背道而驰，因为资源不是由请求标识的—— HTTP GET 的 URI。（在一些 SOAP/RPC 实现中，HTTP 请求 URI 通常不是资源本身的标识符，而是一些必须评估 SOAP 消息以识别资源的中间实体。）</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>为了方便后续讨论 REST 和 RESTful Api，我们先说 HTTP 协议的资源、请求方法与响应码的定义。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>HTTP 请求的目标称为<strong>资源</strong>。 每个资源都由统一资源标识符 URI 标识。人们很容易将 URI 视为远程文件系统路径名，并将该资源的表示视为此类文件的副本。但即使将 URI 映射机制绑定到文件系统，服务端也可能被配置为以请求作为输入执行文件，并将输出作为表示进行响应，而不是直接传输文件。无论如何，只有服务端需要知道它的每个 URI 如何对应于一个实现，以及每个实现如何管理、如何发送目标资源的当前表示以响应 GET 方法等工作。</p><p>HTTP 不限制资源的性质，资源可以是任何东西，例如一份文档，亦或是数据库中存储的数据，等等。HTTP 只是定义了一个与资源交互的统一接口。统一接口类似于一个窗口，只有通过向另一侧的某个独立参与者传递消息才能观察和处理资源。HTTP 没有定义资源是如何存储的，也没有定义这种存储如何响应资源状态变化，也没有定义服务端如何将资源转换为表示。</p><p>就 HTTP 而言，资源的表示（以下统称为<strong>表示</strong>）是旨在反映给定资源过去、当前或期望状态的信息（举例，若将订单视为一种资源，那么查询订单就是希望获取订单资源过去或者当前的信息，创建订单就是在传输订单的期望信息）。表示由元数据和数据流组成，可以轻松地通过 HTTP 进行传输。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>HTTP 的一个设计目标是将资源标识与请求方法分离，这是通过在请求方法和一些请求头字段中赋予语义来实现的：请求方法被设想为将语义应用于目标资源，这很类似于在已识别的对象上调用其定义好的方法，从而将方法语义应用到该对象上的方式。 如果请求方法语义与 URI 本身隐含的任何语义之间存在冲突，则请求方法语义优先。</p><p>与对象方法不同，HTTP 中的标准化请求方法不是特定于某类资源的。尽管每个资源自己确定这些语义是否被允许以及如何实现，但是应该确保标准化方法在应用于任何资源时具有相同的语义。统一的标准化方法在基于网络的系统中提供了更好的可见性和重用性。</p><p>下面根据请求方法的语义对方法进行分类：</p><ul><li><p>安全方法</p><p>如果请求方法所定义的语义本质上是只读的，则该请求方法被认为是安全的。客户端不会请求，也不期望将安全方法应用于目标资源，从而导致服务端上该资源的任何状态变更。同样，合理使用安全方法不会对服务端造成任何伤害、财产损失或异常负担。</p><p>安全方法的定义不会阻止服务端上的方法实现包含潜在有害的行为、并非完全只读的行为或调用时会导致副作用的行为。然而，重要的是客户端没有要求额外的行为，也不会为此负责。例如，大多数服务端在响应完成时会记录访问日志，无论使用何种方法，即使日志存储可能已满并导致服务端崩溃，该方法也被认为是安全的。同样，查看广告而发起的安全请求通常会产生向广告帐户收费的副作用，这也是安全的。</p><p>区分安全和不安全方法的目的是为了支持爬虫和缓存。此外，它允许用户代理在处理潜在不可信内容时对不安全方法应用适当的约束。</p></li><li><p>幂等方法</p><p>如果使用该请求方法的多个相同请求与使用单个此类请求对服务器的预期效果相同，则该请求方法被认为是幂等的。</p><p>与安全方法的定义一样，幂等性仅适用于客户端，服务端可以记录每次历史访问，或为每个幂等请求实现其他非幂等副作用。</p><p>客户端可以自动重复发送幂等请求。例如，如果客户端发送 PUT 请求，并且在收到任何响应之前网络底层连接已关闭，则客户端可以建立新连接并重试该幂等请求。</p></li><li><p>可缓存方法</p><p>请求方法若被定义为可缓存的，则表示允许中介存储对它们的响应以备将来重用。 通常，不依赖于当前或权威响应的安全方法被定义为可缓存的方法。</p><p>但即使规范定义为可缓存方法，但类似于 GET 方法，可以通过在请求头中设置 Cache-Control 字段，更改可缓存特性。</p></li></ul><table><thead><tr><th>方法名</th><th>介绍</th><th>是否安全</th><th>是否幂等</th><th>是否可缓存</th><th>是否有请求体</th></tr></thead><tbody><tr><td>GET</td><td>获取目标资源的当前选定表示</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>HEAD</td><td>与 GET 请求相同，但是只传输状态码和响应头</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>POST</td><td>请求目标资源根据资源自身的特定语义处理请求中包含的表示</td><td>否</td><td>否</td><td>否（规范上定义为可缓存，但大多数实现为不可缓存）</td><td>是</td></tr><tr><td>PUT</td><td>使用请求体中包含的表示替换目标资源当前所有表示，即请求目标资源的状态被<strong>创建</strong>或<strong>替换</strong>为由包含在请求消息有效负载中的表示所定义的状态</td><td>否</td><td>是</td><td>否</td><td>是</td></tr><tr><td>PATCH</td><td>请求创建新资源或对现有资源应用部分修改</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>DELETE</td><td>请求删除目标资源当前所有表示</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>CONNECT</td><td>建立到（被目标资源标识的）服务端的隧道</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>OPTIONS</td><td>请求有关可用于目标资源的通信选项，无论这些信息是存储在服务端还是中介</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>TRACE</td><td>沿着到目标资源的网络路径执行 HTTP 消息的环回测试</td><td>否</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><p>下面详细介绍各请求方法：</p><ul><li><p>GET</p><p>GET 方法是信息检索的主要机制，也是几乎所有性能优化的重点。客户端通过在请求头中设置 Range 字段，可以将 GET 方法的语义更改为“范围请求”，即请求仅传输所选表示的某些部分。注意，这不是类似于对订单信息的分页查询，而是请求对响应的部分获取。</p></li><li><p>HEAD</p><p>HEAD 方法可用于在不传输表示数据的情况下获取所选表示的元数据，通常用于测试超文本链接的有效性、可访问性和最近是否修改。HEAD方法的 响应可能对先前缓存的 GET 方法响应产生影响。</p></li><li><p>POST</p><p>POST 方法不可以被理解为仅代表<strong>创建</strong>。简单说，我们将请求分为读、写两类，那么自然 GET 方法代表读请求，POST 方法代表写请求。写请求自然包含很多语义，类似于创建、修改、删除、取消、预约等等。这是一开始 POST 方法的设计，也是过去（现在甚至还存在）很多系统对于 GET 和 POST 方法的使用方式。可以说，有了 GET 和 POST 方法就可以了。但是，为了更好的利用网络资源，对 HTTP 消息进行优化，比如缓存，以及规范客户端与服务端的交互，就逐渐需要更细化的方法定义，这也是 PUT、DELETE等方法的由来。</p></li><li><p>PUT</p><p>POST 和 PUT 方法之间的根本区别是： POST 方法旨在根据目标资源自己所定义的语义处理请求中的资源表示，而 PUT 方法被定义为替换目标资源的状态。</p><p>除了客户端请求的意图和服务端响应的语义可以表达的内容之外，HTTP 没有确切定义 PUT 方法如何影响服务端资源的状态。资源接口 URI 背后的所有实现细节都被服务端隐藏。</p><p>服务端应该保证 PUT 方法不会修改所定义的资源约束，并验证请求中的表示符合任何约束。当 PUT 方法请求中的表示与目标资源不一致时，服务端应该通过转换表示或更改资源配置来使它们一致，或者以包含足够信息的错误响应来解释表示为什么不合适。</p></li><li><p>PATCH</p><p>PATCH 方法将请求体中描述的一组更改应用于 URI 所标识的资源。更改的格式为补丁文档。如果 URI 未指向现有资源，则服务器可以创建新资源，具体取决于补丁文档类型是否可以在逻辑上修改空资源，以及权限等限制。</p><p>PUT 和 PATCH 方法之间的区别体现在服务端处理表示从而修改 URI 所标识的资源的方式上。PUT 方法请求所包含的表示被认为是存储在源服务器服务端上的资源的修改版本，客户端请求使用这个资源的修改版本替换现有的存储版本。但是 PATCH 方法请求所包含的表示是一组指令，它描述了当前服务端上的资源应如何修改以生成新版本。 服务端必须以原子方式应用整个更改指令，并且不会提供部分修改的表示。如果无法成功应用整个补丁文档，则服务端不得应用任何更改。原子性要求适用于所有直接受影响的文件和数据。如果补丁文档的大小大于 PUT 方法请求中的新资源的大小，那么更应该使用 PUT 方法。</p><p>POST 方法的使用方式多种多样，如果服务器愿意，可以将 POST 方法实现为类似 PUT 和 PATCH 的操作。如果操作没有以可预测的方式修改由 URI 标识的资源，则更应考虑 POST 方法。</p></li><li><p>DELETE</p><p>如果目标资源具有一个或多个表示，它们可能会或不会被服务端销毁，并且其存储可能会或不会被回收，这完全取决于资源的性质及其服务端的实现。</p></li><li><p>CONNECT</p><p>隧道通是通过一个或多个代理所创建的端到端的虚拟连接，可以使用 TLS 进行保护。除了成功响应之外的任何响应都表明隧道尚未连接成功，并且连接仍然由 HTTP 控制。如果隧道连接成功，则此后客户端与服务端的<strong>发送或者接受 TCP 消息流</strong>，直到隧道关闭。</p><p>建立通向任意服务端的隧道存在重大风险，特别是当目标服务端不是众所周知或保留的 TCP 端口时。</p></li><li><p>OPTIONS</p><p>客户端应该在向用户呈现通信选项时区分安全和不安全的方法。</p></li><li><p>TRACE</p></li></ul><h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><p>客户端必须理解任何状态代码类别（例如 3xx），并将无法识别的状态代码视为等同于该类别的 x00 状态码。</p><ul><li>1xx（信息）：请求已收到，继续处理。</li><li>2xx（成功）：请求被成功接收、理解和接受。</li><li>3xx（重定向）：需要采取进一步行动才能完成请求。</li><li>4xx（客户端错误）：请求包含错误的语法或无法完成。</li><li>5xx（服务器错误）：服务器未能满足有效的请求。</li></ul><h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><h2 id="World-Wide-Web-万维网特点及其需求"><a href="#World-Wide-Web-万维网特点及其需求" class="headerlink" title="World Wide Web 万维网特点及其需求"></a>World Wide Web 万维网特点及其需求</h2><p>在理解 REST 设计思想之前，我们需要先明确 Web 的特点，即 Web 系统架构的设计要求。</p><p>Web 的主要目标是成为一个人与机器互联互通的信息共享空间：人们需要一种方法来构建和存储他们自己的信息，无论这些信息是永久的还是短暂的，以便自己和他人都可以使用，并且能够引用和构建他人存储的信息，以便每个人都没有必要保留和维护信息的本地副本。Web 系统的最终预期是用户位于世界各地，并通过 Web 连接的。用户所使用的机器是终端、工作站、服务器和超级计算机的异构集合，有各式各样的操作系统软件和文件格式。信息范围从个人研究笔记到组织电话列表。Web 系统需要为这些异构信息提供普遍一致的接口，在尽可能多的平台上使用，并且随着新人员和组织加入而逐步部署整个 Web 系统。</p><p>尽管对它的成功感到欣喜若狂，但 Internet 开发人员社区开始担心 Web 使用的快速增长以及早期 HTTP 的一些不良网络特性会迅速超过 Internet 基础设施的容量并导致全面崩溃。Web 上应用程序交互性质的变化使情况变得更糟。最初的协议是为单个请求-响应对设计的，而新站点使用越来越多的内嵌图像作为网页内容的一部分，从而产生不同的浏览交互配置文件。部署的架构在支持可扩展性、共享缓存和中介方面存在重大限制，这使得针对日益增长的问题开发临时解决方案变得困难。同时，</p><p>Internet Engineering Taskforce 内的工作组成立以研究 Web 的三个主要标准：URI、HTTP 和 HTML。这些小组的章程是定义在早期 Web 架构中普遍和一致实现的现有架构通信的子集，识别该架构中的问题，然后指定一组标准来解决这些问题。这给我们带来了一个挑战：我们如何向已经广泛部署的架构引入一组新功能，以及我们如何确保它的引入不会对支持 Web 的架构属性产生不利影响甚至破坏成功？</p><p>Web 系统有以下特点：</p><ul><li><p>低门槛</p><p>由于参与信息的创建和构建是自愿的，因此需要低门槛才能充分采用。这适用于 Web 架构的所有用户：读者、作者和应用程序开发人员。</p><p>选择超媒体作为用户界面是因为它的简单性和通用性：无论信息来源如何，都可以使用相同的界面，超媒体关系（链接）的灵活性允许无限的结构化，链接的直接操作允许内部的复杂关系指导读者完成应用程序的信息。由于大型数据库中的信息通常更容易通过搜索界面而不是浏览来访问，因此 Web 还集成了通过向服务提供用户输入的数据并将结果呈现为超媒体来执行简单查询的能力。</p><p>对于作者而言，主要要求是整个系统的部分可用性不得妨碍内容的创作。超文本创作语言需要简单并且能够使用现有的编辑工具进行创建。作者希望以这种格式保存个人研究笔记等内容，无论是否直接连接到互联网，因此不能允许某些参考信息暂时或永久不可用的事实阻止阅读和创作可用的信息。出于类似的原因，必须能够在该引用的目标可用之前创建对信息的引用。由于鼓励作者合作开发信息源，参考文献需要易于交流，</p><p>简单性也是应用程序开发人员的目标。由于所有协议都定义为文本，因此可以使用现有网络工具查看和交互测试通信。尽管缺乏标准，这使得协议的早期采用得以实现。</p></li><li><p>可拓展性</p><p>虽然简单性使得部署分布式系统的初始实现成为可能，但可扩展性使我们能够避免永远陷入部署的限制。即使可以构建一个完全符合用户需求的软件系统，这些需求也会随着时间的推移而变化，就像社会随着时间的推移而变化一样。一个想要像 Web 一样长期存在的系统必须准备好接受变化。</p></li><li><p>分布式超媒体</p><p>超媒体的定义是将应用程序控制信息嵌入到信息呈现中，或者作为信息呈现的上层。分布式超媒体允许将演示和控制信息存储在远程位置。就其性质而言，分布式超媒体系统中的用户操作需要将大量数据从数据存储位置传输到使用位置。因此，必须为大粒度数据传输设计 Web 架构。</p><p>超媒体交互的可用性对用户感知的延迟高度敏感：选择链接和呈现可用结果之间的时间。由于 Web 的信息源分布在全球 Internet 上，因此架构需要最小化网络交互（数据传输协议内的往返）。</p></li><li><p>互联网规模</p><p>万维网旨在成为一个<em>互联网规模的</em>分布式超媒体系统，这意味着不仅仅是地理上的分散。互联网是关于跨越多个组织边界的互连信息网络。信息服务供应商必须能够应对无政府可扩展性和软件组件独立部署的需求。</p><h4 id="4-1-4-1-无政府可扩展性"><a href="#4-1-4-1-无政府可扩展性" class="headerlink" title="4.1.4.1 无政府可扩展性"></a>4.1.4.1 无政府可扩展性</h4><p>大多数软件系统都是在隐含假设下创建的，即整个系统都在一个实体的控制之下，或者至少系统内的所有实体都在朝着一个共同的目标而不是为了交叉目的而行动。当系统在 Internet 上公开运行时，不能安全地做出这样的假设。无政府可扩展性是指当架构元素受到意外负载时，或者在给定格式错误或恶意构造的数据时，需要继续运行架构元素，因为它们可能与组织控制之外的元素进行通信。架构必须服从于增强可见性和可扩展性的机制。</p><p>无政府可扩展性要求适用于所有架构元素。不能期望客户端保持对所有服务器的了解。不能期望服务器跨请求保留状态知识。超媒体数据元素不能保留“反向指针”，即引用它们的每个数据元素的标识符，因为对资源的引用次数与对该信息感兴趣的人数成正比。特别具有新闻价值的信息也可能导致“快速人群”：随着有关其可用性的消息在世界各地传播，访问尝试突然激增。</p><p>架构元素及其运行平台的安全性也成为一个重要的问题。多个组织边界意味着在任何通信中都可能存在多个信任边界。中间应用程序（例如防火墙）应该能够检查应用程序交互并防止组织安全策略之外的应用程序被执行。应用程序交互中的参与者应该假设收到的任何信息都是不可信的，或者在给予信任之前需要一些额外的身份验证。这要求架构能够传达身份验证数据和授权控制。但是，由于身份验证会降低可扩展性，因此架构的</p><h4 id="4-1-4-2-独立部署"><a href="#4-1-4-2-独立部署" class="headerlink" title="4.1.4.2 独立部署"></a>4.1.4.2 独立部署</h4><p>多个组织边界还意味着系统必须为渐进和碎片化的变化做好准备，在这种变化中，新旧实现共存，而不会阻止新实现利用其扩展功能。需要设计现有的架构元素，并期望在以后添加架构特性。同样，需要轻松识别较旧的实现，以便可以封装遗留行为，而不会对较新的架构元素产生不利影响。整个架构必须设计为以局部、迭代的方式简化架构元素的部署，因为不可能以有序的方式强制部署。</p></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>具象状态传输（REST）</strong>是一种软件架构风格，旨在指导万维网架构的设计和开发，特别是客户端-服务端应用程序。但更重要的是，REST 为互联网规模的分布式超媒体系统的架构定义了一组约束条件，因此客户端和服务端之间的耦合必须尽可能松散以促进大规模使用。这是通过定义<strong>资源</strong>作为抽象层，从而隐藏了底层实现细节。这种方法允许在跨组织（信任）边界的大规模分布式环境中的客户端和服务端之间实现最大的互操作性。</p><p>REST 的目标是提高性能、可扩展性、简单性、可修改性、可见性、可移植性和可靠性。这是通过遵循 REST 原则来实现的，例如客户端 - 服务器架构、无状态、可缓存性、分层系统的使用、按需代码支持以及使用统一接口。要对系统进行分类，必须遵循这些原则。REST架构风格强调组件间交互的可扩展性、统一接口、组件独立部署、分层架构、方便缓存组件、减少用户感知延迟、加强安全性和封装遗留系统。</p><p>就其本质而言，架构风格独立于任何特定的实现，虽然 REST 是作为 Web 标准开发的一部分创建的，但 Web 的实现并不遵守 REST 架构风格中的每一个约束。不匹配可能由于无知或疏忽而发生，但 REST 架构风格的存在意味着它们可以在标准化之前被识别出来。例如，Fielding 将会话信息嵌入 URI 确定为违反 REST 的约束，这会对共享缓存和服务器可扩展性产生负面影响。<a href="https://en.wikipedia.org/wiki/HTTP_cookies">HTTP cookie</a>也违反了 REST 约束，因为它们可能与浏览器的应用程序状态不同步，从而使它们不可靠；它们还包含可能涉及隐私和安全的不透明数据。</p><p>REST 已被整个软件行业采用，并且是一套被广泛接受的用于创建无状态、可靠的<a href="https://en.wikipedia.org/wiki/Web_API">Web API 的指南</a>。遵守<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints">REST 约束的</a>Web API被非正式地描述为<strong>RESTful</strong>。RESTful Web API 通常松散地基于<a href="https://en.wikipedia.org/wiki/HTTP_method">HTTP 方法</a>，通过<a href="https://en.wikipedia.org/wiki/URL-encoding">URL 编码的</a>参数访问<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_concepts">资源</a>，并使用<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或<a href="https://en.wikipedia.org/wiki/XML">XML</a>传输数据。</p><p>为了创建 REST 架构风格，Fielding 确定了在创建基于全球网络的应用程序时适用的要求，例如需要低进入壁垒以实现全球采用。他还调查了基于网络的应用程序的许多现有架构风格，确定了哪些功能与其他风格共享，例如缓存和客户端-服务器功能，以及 REST 独有的功能，例如资源概念。Fielding 试图对当前实现的现有架构进行分类，并确定哪些方面应该被视为 Web 的行为和性能要求的核心。</p><p>其核心原则是定义可以用少量方法控制的命名资源。这些资源和方法被称为 API 的“名词”和“动词”。使用 HTTP 协议时，资源名称自然映射到网址，方法自然映射到 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>。这使得要学习的内容减少了很多，因为开发人员可以专注于资源及其关系，并假定它们拥有的标准方法同样很少。</p><p>一个万维网应该如何工作的模型。</p><p>REST 最初被称为“HTTP 对象模型”，但该名称通常会导致将其误解为 HTTP 服务器的实现模型。“具象状态转移”这个名称旨在唤起一个精心设计的 Web 应用程序行为的图像：网页网络（虚拟状态机），用户通过选择链接（状态转换）在应用程序中前进。REST 提供了一组架构约束，当作为一个整体应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署和中间组件，以减少交互延迟、加强安全性和封装遗留系统。</p><p>Representational State Transfer (REST) 风格是分布式超媒体系统中架构元素的抽象。REST 忽略了组件实现和协议语法的细节，以便专注于组件的角色、它们与其他组件交互的约束以及它们对重要数据元素的解释。它包含对组件、连接器和数据的基本约束，这些约束定义了 Web 体系结构的基础，从而定义了其作为基于网络的应用程序的行为的本质。</p><p>REST 定义了一个预期应用程序行为模型，该模型支持简单而健壮的应用程序，这些应用程序在很大程度上不受困扰大多数基于网络的应用程序的部分故障条件的影响。</p><p>通过将延迟减少作为架构目标，REST 可以根据用户感知的性能区分媒体类型（表示的数据格式）。</p><p>REST 是一组协调的架构约束，它试图最大限度地减少延迟和网络通信，同时最大限度地提高组件实现的独立性和可扩展性。这是通过对连接器语义施加约束来实现的，而其他样式则专注于组件语义。REST 实现了交互的缓存和重用、组件的动态可替代性以及中介对动作的处理，从而满足了互联网规模的分布式超媒体系统的需求。</p><p>REST 仅详细阐述了被认为对互联网规模的分布式超媒体交互必不可少的架构部分。对于基于网络的应用程序，系统性能取决于网络通信。对于分布式超媒体系统，组件交互由大粒度数据传输而不是计算密集型任务组成。REST 风格是为响应这些需求而开发的。它对资源和表示的通用连接器接口的关注启用了组件的中间处理、缓存和可替换性，这反过来又允许基于 Web 的应用程序从 1994 年的 100,000 个请求/天扩展到 1999 年的 600,000,000 个请求/天。</p><p>REST 或 REpresentational State Transfer 是一种架构风格，用于在网络上的计算机系统之间提供标准，使系统更容易相互通信。符合 REST 的系统，通常称为 RESTful 系统，其特点是它们是无状态的，并且将客户端和服务器的关注点分开。</p><p>2000 年，Roy Fielding 提出了表征状态转移 (REST) 作为设计 Web 服务的架构方法。REST 是一种基于超媒体构建分布式系统的架构风格。REST 独立于任何底层协议，不一定与 HTTP 绑定。但是，最常见的 REST API 实现使用 HTTP 作为应用程序协议。REST 相对于 HTTP 的主要优势在于它使用开放标准，并且不会将 API 或客户端应用程序的实现绑定到任何特定实现。</p><ul><li>REST API 是围绕<em>资源</em>设计的，<em>资源</em>是客户端可以访问的任何类型的对象、数据或服务。</li><li>资源有一个<em>identifier</em>，它是唯一标识该资源的 URI。</li><li>客户端通过交换资源<em>表示</em>与服务交互。</li><li>REST API 使用统一的接口，这有助于将客户端和服务实现解耦。对于基于 HTTP 构建的 REST API，统一接口包括使用标准 HTTP 动词对资源执行操作。最常见的操作是 GET、POST、PUT、PATCH 和 DELETE。</li><li>REST API 使用无状态请求模型。HTTP 请求应该是独立的并且可以以任何顺序发生，因此在请求之间保持瞬态信息是不可行的。唯一存储信息的地方是资源本身，每个请求都应该是一个原子操作。此约束使 Web 服务具有高度可扩展性，因为无需在客户端和特定服务器之间保留任何关联。任何服务器都可以处理来自任何客户端的任何请求。也就是说，其他因素可能会限制可扩展性。</li><li>REST API 由表示中包含的超媒体链接驱动。</li></ul><h2 id="架构约束"><a href="#架构约束" class="headerlink" title="架构约束"></a>架构约束</h2><p>六个指导性约束定义了一个 RESTful 系统。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-SOA_with_REST-6">6] </a>[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Richardson_2007-8">8]</a>这些约束限制了服务器处理和响应客户端请求的方式，因此，通过在这些约束内运行，系统可以获得理想的<a href="https://en.wikipedia.org/wiki/Non-functional_requirement">非功能特性</a>，例如性能、可伸缩性、简单性、可修改性、可见性、便携性和可靠性。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a>如果系统违反了任何必需的约束，则不能将其视为 RESTful。</p><p>正式的 REST 约束如下：</p><h3 id="客户端-服务端架构"><a href="#客户端-服务端架构" class="headerlink" title="客户端-服务端架构"></a>客户端-服务端架构</h3><p>关注点分离是客户端-服务器约束背后的原则。通过将用户界面问题与数据存储问题分开，我们提高了用户界面跨多个平台的可移植性，并通过简化服务器组件提高了可扩展性。然而，也许对 Web 最重要的是分离允许组件独立发展，从而支持多个组织域的 Internet 规模需求。</p><p>在 REST 架构风格中，客户端的实现和服务器的实现可以独立完成，彼此互不了解。只要每一方都知道要向另一方发送什么格式的消息，它们就可以保持模块化和分离。将用户界面问题与数据存储问题分开，我们提高了跨平台界面的灵活性，并通过简化服务器组件来提高可扩展性。此外，分离允许每个组件独立发展的能力。通过使用 REST 接口，不同的客户端访问相同的 REST 端点，执行相同的操作，并接收相同的响应。</p><p>一个或多个客户端必须能够同时监视和操作同一资源。</p><p>大多数现代 Web 应用程序都公开了客户端可用于与应用程序交互的 API。一个设计良好的 Web API 应该旨在支持：</p><ul><li><strong>平台独立性</strong>。无论 API 在内部如何实现，任何客户端都应该能够调用 API。这需要使用标准协议，并具有一种机制，使客户端和 Web 服务可以就要交换的数据格式达成一致。</li><li><strong>服务进化</strong>。Web API 应该能够独立于客户端应用程序发展和添加功能。随着 API 的发展，现有的客户端应用程序应该无需修改即可继续运行。所有功能都应该是可发现的，以便客户端应用程序可以充分使用它。</li></ul><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>在计算中，无状态协议是一种<a href="https://en.wikipedia.org/wiki/Communications_protocol">通信协议</a>，其中接收方（通常是服务器）不保留会话信息。客户端将相关会话数据发送到接收器，这样传输的每个信息包都可以被孤立地理解，而无需会话中先前数据包的上下文信息。无状态协议的这一特性使它们成为高容量应用程序的理想选择，通过消除由保留会话信息引起的服务器负载来提高性能。</p><p>我们接下来为客户端-服务器交互添加一个约束：通信本质上必须是无状态的，如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_3">第 3.4.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_3">图 5-3</a>）的客户端-无状态-服务器 (CSS) 风格，这样从客户端到服务器必须包含理解请求所需的所有信息，并且不能利用服务器上存储的任何上下文。因此，会话状态完全保留在客户端上。这种约束导致了可见性、可靠性和可伸缩性的特性。可见性得到改善，因为监控系统不必查看单个请求数据之外的内容来确定请求的全部性质。可靠性得到提高，因为它简化了从部分故障中恢复的任务 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_133">133</a> ]。可扩展性得到改进，因为不必在请求之间存储状态允许服务器组件快速释放资源，并进一步简化实现，因为服务器不必管理跨请求的资源使用。与大多数架构选择一样，无状态约束反映了设计权衡。缺点是它可能会通过增加一系列请求中发送的重复数据（每次交互开销）来降低网络性能，因为这些数据不能在共享上下文中留在服务器上。此外，将应用程序状态置于客户端会减少服务器对一致应用程序行为的控制，因为应用程序变得依赖于跨多个客户端版本的正确语义实现。</p><p>遵循 REST 范式的系统是无状态的，这意味着服务器不需要知道客户端处于什么状态，反之亦然。这样，服务器和客户端都可以理解收到的任何消息，即使没有看到以前的消息。这种无状态约束是通过使用<em>资源</em>而不是<em>命令</em>来强制执行的。资源是 Web 的名词——它们描述您可能需要存储或发送到其他服务的任何对象、文档或 <em>事物</em>。由于 REST 系统通过对资源的标准操作进行交互，因此它们不依赖于接口的实现。这些约束帮助 RESTful 应用程序实现可靠性、快速性能和可扩展性，作为可以管理、更新和重用的组件，即使在系统运行期间也不影响整个系统。</p><p>系统状态应该始终是可发现和可测试的。即使操作跟踪资源不再处于活动状态，客户端也应该能够确定系统状态。查询长时间运行的操作状态的行为本身应该利用网络的原则。即具有统一接口语义的明确定义的资源。客户端可以对某些资源发出 GET 请求以确定长时间运行的操作的状态</p><p>长期运行的操作应该适用于希望“即发即忘”的客户以及希望积极监控结果并采取行动的客户。</p><p>取消并不明确意味着回滚。在每个 API 定义的情况下，它可能意味着回滚、补偿、完成或部分完成等。在取消操作之后，客户不应该负责将服务返回到允许继续服务的一致状态。</p><h3 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h3><p>在万维网上，客户端和中介可以缓存响应。响应必须隐式或显式地将自己定义为可缓存或不可缓存，以防止客户端提供陈旧或不适当的数据以响应进一步的请求。管理良好的缓存部分或完全消除了一些客户端-服务器交互，进一步提高了可扩展性和性能。</p><p>为了提高网络效率，我们添加缓存约束，形成<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_4">3.4.4节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_4">图5-4</a>）的client-cache-stateless-server样式。缓存约束要求对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权为以后的等效请求重用该响应数据。添加缓存约束的优势在于它们有可能通过减少一系列交互的平均延迟来部分或完全消除某些交互，从而提高效率、可扩展性和用户感知性能。然而，权衡是，如果缓存中的陈旧数据与将请求直接发送到服务器时获得的数据显着不同，则缓存会降低可靠性。</p><h3 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h3><p>统一接口约束是任何 RESTful 系统设计的基础。它简化和解耦了架构，使每个部分都可以独立演进。这个统一接口的四个约束是：</p><ul><li>请求中的资源标识 - 单个资源在请求中标识，例如在 RESTful Web 服务中使用URI。资源本身在概念上与返回给客户端的表示分开。例如，服务器可以以HTML、XML或JSON格式从其数据库发送数据——这些都不是服务器的内部表示。</li><li>通过表示进行资源操作 - 当客户端持有资源的表示（包括附加的任何<a href="https://en.wikipedia.org/wiki/Metadata">元数据）时</a>，它有足够的信息来修改或删除资源的状态。</li><li>自描述消息 - 每条消息都包含足够的信息来描述如何处理消息。例如，要调用的解析器可以由<a href="https://en.wikipedia.org/wiki/Media_type">媒体类型</a>指定。[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch5-1">1]</a></li><li>超媒体作为应用状态（发动机<a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>） -已经进入一个初始的URI REST应用类似于人类的Web用户访问该<a href="https://en.wikipedia.org/wiki/Home_page">主页</a>网站-REST客户端的话应该能够动态地使用服务器提供的链接发现它需要的所有可用资源。随着访问的进行，服务器以包含指向当前可用的其他资源的<a href="https://en.wikipedia.org/wiki/Hyperlink">超链接的</a>文本进行响应。客户端无需使用有关应用程序结构或动态的信息进行硬编码。</li></ul><p>将 REST 架构风格与其他基于网络的风格区分开来的核心特征是它强调组件之间的统一接口（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_6">图 5-6</a>）。通过将通用性的软件工程原理应用于组件接口，简化了整个系统架构并提高了交互的可见性。实现与它们提供的服务分离，这鼓励了独立的可进化性。然而，代价是统一的接口会降低效率，因为信息是以标准化的形式传输的，而不是特定于应用程序需求的形式。REST 接口被设计为高效的大粒度超媒体数据传输，针对 Web 的常见情况进行优化，但导致接口对于其他形式的架构交互不是最佳的。为了获得统一的接口，需要多个架构约束来指导组件的行为。REST 由四个接口约束定义：资源识别、通过表征操纵资源、自我描述信息、超媒体作为应用程序状态的引擎。</p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>客户端通常无法判断它是直接连接到终端服务器还是沿途的中介。如果在客户端和服务器之间放置代理或负载均衡器，则不会影响它们的通信，也不需要更新客户端或服务器代码。中间服务器可以通过启用负载平衡和提供共享缓存来提高系统可扩展性。此外，安全性可以添加为 Web 服务之上的一个层，将业务逻辑与安全逻辑分开。将安全添加为一个单独的层会强制执行安全策略。最后，中间服务器可以调用多个其他服务器来生成对客户端的响应。</p><p>为了进一步改善 Internet 规模需求的行为，我们添加了分层系统约束（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_7">图 5-7</a>）。如<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_2">第 3.4.2 节</a>所述，分层系统风格允许架构通过约束组件行为而由分层层组成，使得每个组件不能“看到”超出与其交互的直接层。通过将系统的知识限制在单个层，我们对整个系统的复杂性进行了限制，并促进了基板的独立性。层可用于封装遗留服务并保护来自遗留客户端的新服务，通过将不常用的功能移动到共享中介来简化组件。中介还可用于通过跨多个网络和处理器实现服务负载平衡来提高系统可扩展性。分层系统的主要缺点是它们增加了数据处理的开销和延迟，降低了用户感知的性能 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_32">32</a> ]。对于支持缓存约束的基于网络的系统，这可以被中介共享缓存的好处所抵消。在组织域的边界放置共享缓存可以带来显着的性能优势 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_136">136</a> ]。这些层还允许对跨越组织边界的数据实施安全策略，这是防火墙的要求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_79">79</a> ]。分层系统和统一接口约束的组合产生类似于统一管道和过滤器风格（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_2_2">第 3.2.2 节</a>）的架构特性。尽管 REST 交互是双向的，但超媒体交互的大粒度数据流都可以像数据流网络一样进行处理，过滤器组件有选择地应用于数据流，以便在内容通过时对其进行转换 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_26">26</a> ]。在 REST 中，中介组件可以主动转换消息的内容，因为消息是自描述的，并且它们的语义对中介是可见的。</p><h3 id="按需代码（可选）"><a href="#按需代码（可选）" class="headerlink" title="按需代码（可选）"></a>按需代码（可选）</h3><p>服务器可以通过传输可执行代码来临时扩展或自定义客户端的功能：例如，已编译的组件（如Java 小程序）或客户端脚本（如JavaScript）。</p><p>我们为 REST 设置的最后一项约束来自<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_5_3">第 3.5.3 节</a>（<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#fig_5_8">图 5-8</a>）的按需代码风格。REST 允许通过下载和执行小程序或脚本形式的代码来扩展客户端功能。这通过减少需要预先实现的功能数量来简化客户端。允许在部署后下载功能提高了系统可扩展性。但是，它也会降低可见性，因此它只是 REST 中的一个可选约束。可选约束的概念似乎是矛盾的。但是，它在包含多个组织边界的系统的架构设计中确实有其用途。这意味着体系结构只有在已知可选约束对整个系统的某些领域有效时才能获得它们的好处（并遭受缺点）。可选约束允许我们设计一个架构，在一般情况下支持所需的行为，但要理解它可能在某些上下文中被禁用。</p><h2 id="架构元素"><a href="#架构元素" class="headerlink" title="架构元素"></a>架构元素</h2><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p><img src="/images/SAC/REST/data_element.png"></p><p>数据元素的性质和状态是 REST 架构的一个重要方面。</p><p>许多分布式处理范式将处理逻辑（例如代码、存储过程、搜索表达式等，MapReduce 即是此思想的代表）移动到数据端，而不是将数据移动到处理组件中，这些分布式对象的所有数据都封装在处理组件中并由处理组件隐藏。在 REST 架构中，用户选择链接后，数据需要从其存储位置移动到用户的位置。有如下三种基本的数据移动方式：</p><ol><li><strong>在数据所在的位置渲染数据并将固定格式的渲染结果发送给接收者。</strong>传统的客户端 - 服务器风格，允许所有关于数据真实性质的信息隐藏在发送者中，防止对数据结构做出假设并使客户端实现更容易。但是，它也严重限制了接收方的功能，并将大部分处理负载置于发送方，从而导致可扩展性问题。    </li><li><strong>用渲染引擎封装数据并发送给接收者。</strong>移动对象样式 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_50">50</a>]，提供信息隐藏，同时通过其独特的渲染引擎对数据进行专门处理，但将接收方的功能限制在该引擎中的预期范围内，并可能大大增加传输的数据量。</li><li><strong>将原始数据连同描述数据类型的元数据一起发送给接收者，以便接收者可以选择自己的渲染引擎。</strong>允许发送方在最小化传输的字节数的同时保持简单和可扩展，但失去了信息隐藏的优势，并且要求发送方和接收方都理解相同的数据类型。</li></ol><p>REST 通过关注对数据类型与元数据的共同理解，提供了所有三个选项的混合，但限制了向标准化接口显示的内容的范围。REST 组件通过以与一组不断发展的标准数据类型之一匹配的格式传输资源的表示来进行通信，根据接收者的能力或愿望以及资源的性质动态选择。无论表示形式与原始源的格式相同，还是源自源，都隐藏在界面后面。通过发送由封装渲染引擎的标准数据格式中的指令组成的表示，可以近似移动对象样式的好处。因此，REST 获得了客户端-服务器风格的关注点分离，而没有服务器可扩展性问题，允许通过通用接口隐藏信息以实现服务的封装和演变，并通过可下载的功能引擎提供多样化的功能集。</p><p>REST 中信息的关键抽象是<em>资源</em>。任何可以命名的信息都可以是资源：文档或图像、时间服务（例如“洛杉矶今天的天气”）、其他资源的集合、非虚拟对象（例如人）等. 换句话说，任何可能成为作者超文本引用目标的概念都必须符合资源的定义。资源是到一组实体的概念映射，而不是在任何特定时间点对应于映射的实体。更准确地说，资源<em>R</em>是随时间变化的隶属函数<em>M</em> R <em>(t)<em>，它在时间</em>t</em>映射到一组等效的实体或值。集合中的值可以是<em>资源表示</em>和/或<em>资源标识符</em>。资源可以映射到空集，这允许在该概念的任何实现存在之前对其进行引用——这个概念对于 Web 之前的大多数超文本系统来说是陌生的 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_61">61]</a>]。某些资源在某种意义上是静态的，即在它们创建后的任何时间进行检查时，它们始终对应于相同的值集。其他人的价值随着时间的推移有很大程度的变化。资源唯一需要静态的是映射的语义，因为语义是区分一种资源与另一种资源的原因。资源的这种抽象定义启用了 Web 架构的关键特性。首先，它通过包含许多信息源而没有人为地按类型或实现来区分它们来提供通用性。其次，它允许对表示的引用进行后期绑定，从而能够根据请求的特征进行内容协商。最后，它允许作者引用该概念而不是该概念的某些单一表示，从而无需在表示更改时更改所有现有链接（假设作者使用了正确的标识符）。REST 使用资源标识符来标识组件之间交互中涉及的特定资源。REST 连接器提供了一个通用接口，用于访问和操作资源的值集，而不管成员函数是如何定义的或处理请求的软件类型如何。分配资源标识符的命名机构，使引用资源成为可能，负责随着时间的推移维护映射的语义有效性（即，确保成员函数不会改变）。</p><p>REST 组件通过使用表示来捕获该资源的当前或预期状态并在组件之间传输该表示来对资源执行操作。表示是一个字节序列，加上描述这些字节的表示元数据。表示的其他常用但不太精确的名称包括：文档、文件和 HTTP 消息实体、实例或变体。表示包括数据、描述数据的元数据，有时还包括描述元数据的元数据（通常用于验证消息完整性）。元数据采用名称-值对的形式，其中名称对应于定义值结构和语义的标准。响应消息可能包括表示元数据和资源元数据：关于资源的信息，不是特定于所提供的表示。控制数据定义了组件之间消息的目的，例如请求的操作或响应的含义。它还用于参数化请求并覆盖某些连接元素的默认行为。例如，缓存行为可以通过包含在请求或响应消息中的控制数据进行修改。根据消息控制数据，给定的表示可以指示所请求资源的当前状态、所请求资源的期望状态或某些其他资源的值，例如客户端查询表单中输入数据的表示，或响应的某些错误条件的表示。例如，资源的远程创作要求创作者向服务器发送一个表示，从而为该资源建立一个值，该值可以由以后的请求检索。如果给定时间资源的值集由多个表示组成，则可以使用内容协商来选择最佳表示以包含在给定消息中。</p><p>但定义比这更普遍：任何可以命名的信息都可以是资源：图像、数据库查询、时间服务（例如“伦敦今天的天气”），甚至是其他资源的集合</p><p>面向资源的 API 通常被构建为资源层次结构，其中每个节点是一个“简单资源”或“集合资源”。为方便起见，它们通常被分别称为资源和集合。</p><ul><li>一个集合包含<strong>相同类型</strong>的资源列表。 例如，一个用户拥有一组联系人。</li><li>资源具有一些状态和零个或多个子资源。 每个子资源可以是一个简单资源或一个集合资源。</li></ul><p>例如，Gmail API 有一组用户，每个用户都有一组消息、一组线程、一组标签、一个个人资料资源和若干设置资源。</p><p>虽然存储系统和 REST API 之间存在一些概念上的对应，但具有面向资源 API 的服务不一定是数据库，并且在解释资源和方法方面具有极大的灵活性。例如，创建日历事件（资源）可以为参与者创建附加事件、向参与者发送电子邮件邀请、预约会议室以及更新视频会议时间安排。</p><p>虽然完整的资源名称类似于普通网址，但两者并不相同。单个资源可以由不同的 API 版本、API 协议或 API 网络端点公开。完整资源名称未指明此类信息，因此在实际使用中必须将其映射到特定的 API 版本和 API 协议。</p><p>“Web 资源”首先在万维网上定义为由其URL标识的文档或文件。今天，该定义更加通用和抽象，包括可以在 Web 上以任何方式识别、命名、寻址、处理或执行的所有事物、实体或操作。在 RESTful Web 服务中，对资源的<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>发出的请求会引发响应，其<a href="https://en.wikipedia.org/wiki/Payload_(computing)">有效负载</a>格式为<a href="https://en.wikipedia.org/wiki/HTML">HTML</a>、<a href="https://en.wikipedia.org/wiki/XML">XML</a>、<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>或某种其他格式。例如，响应可以确认资源状态已更改。响应还可以包含<a href="https://en.wikipedia.org/wiki/Hypertext">超文本</a>相关资源的链接。这些请求和响应最常见的协议是 HTTP。它提供操作（<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP 方法</a>），例如 GET、POST、PUT 和 DELETE。通过使用无状态协议和标准操作，RESTful 系统旨在通过重用可以管理和更新的组件来实现快速性能、可靠性和增长能力，即使在系统运行时也不影响整个系统。</p><p>客户端只能使用<strong>URI</strong>访问资源。换句话说，客户端使用 URI 请求资源，服务器使用资源的<strong>表示</strong>进行响应。资源的表示是 REST 中的另一个重要概念。为了确保响应可以被尽可能多的客户端<strong>应用程序</strong>解释，资源的表示以超文本格式发送。因此，通过在客户端和服务器之间的<strong>消息中</strong>传输的超文本表示来操纵资源。客户端和服务器的强解耦以及使用统一寻址协议的基于文本的信息传输为满足 Web 的要求提供了基础：健壮性（无政府可扩展性）、组件的独立部署、大粒度数据传输和内容读者、内容作者和开发人员的低准入门槛。</p><p>REST 架构风格的约束影响以下架构属性：</p><ul><li>组件交互中的性能，这可能是用户感知性能和网络效率的主导因素；[<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-Fielding-Ch2-7">7]</a></li><li><a href="https://en.wikipedia.org/wiki/Scalability">可扩展性</a>允许支持大量组件和组件之间的交互；</li><li>统一界面的简单性；</li><li>组件的可修改性以满足不断变化的需求（即使在应用程序运行时）；</li><li>服务代理组件之间通信的可见性；</li><li>通过随数据移动程序代码来实现组件的可移植性；</li><li>在组件、连接器或数据中存在故障时，系统级抗故障的可靠性。</li></ul><p>REST 用于定义 URI 标准的术语资源 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_21">21</a>]，以及通过其表示来操作资源的通用接口的整体语义。早期的 Web 架构将 URI 定义为文档标识符。作者被指示根据文档在网络上的位置来定义标识符。然后可以使用 Web 协议来检索该文档。然而，由于多种原因，这个定义被证明是不令人满意的。首先，它表明作者正在识别传输的内容，这意味着只要内容发生变化，标识符就应该改变。其次，存在许多对应于服务而不是文档的地址——作者可能打算将读者引导至该服务，而不是先前访问该服务的任何特定结果。最后，在某些时间段存在与文档不对应的地址，REST 中资源的定义基于一个简单的前提：标识符应尽可能不经常更改。因为 Web 使用嵌入式标识符而不是链接服务器，作者需要一个与他们想要的超媒体引用语义密切匹配的标识符，允许引用保持静态，即使访问该引用的结果可能会随着时间的推移而改变。REST 通过将资源定义为作者想要识别的语义，而不是在创建引用时对应于这些语义的值来实现这一点。然后由作者确保为引用选择的标识符确实标识了预期的语义。</p><p>定义资源以便 URI 标识概念而不是文档给我们留下了另一个问题：用户如何访问、操作或传输概念，以便在选择超文本链接时他们可以获得有用的东西？REST 通过将被操作的事物定义为已识别资源的表示而不是资源本身来回答这个问题。源服务器维护从资源标识符到对应于每个资源的一组表示的映射。因此，通过资源标识符定义的通用接口传输表示来操纵资源。REST 对资源的定义源自 Web 的核心需求：跨多个信任域独立创作互连的超文本。强制接口定义与接口要求相匹配会导致协议看起来模糊，但这只是因为被操作的接口只是一个接口而不是一个实现。协议特定于应用程序操作的意图，但接口背后的机制必须决定该意图如何影响资源映射到表示的底层实现。信息隐藏是推动 REST 统一接口的关键软件工程原则之一。由于客户端仅限于对表示的操作而不是直接访问资源的实现，因此可以以命名机构所需的任何形式构造实现，而不会影响可能使用其表示的客户端。此外，如果在访问资源时存在多个资源表示，则可以使用内容选择算法来动态选择最适合该客户端能力的表示。当然，缺点是资源的远程创作不像文件的远程创作那么简单。</p><p>通过 Web 的统一接口进行远程创作的挑战是由于客户端可以检索的表示与服务器上可能用于存储、生成或检索该表示的内容的机制之间的分离。单个服务器可以将其命名空间的某些部分映射到文件系统，文件系统又映射到可以映射到磁盘位置的 inode 的等价物，但是这些底层机制提供了一种将资源与一组表示相关联的方法，而不是而不是识别资源本身。许多不同的资源可以映射到相同的表示，而其他资源可能根本没有映射。资源不是存储对象。资源不是服务器用来处理存储对象的机制。资源是一个概念映射——服务器接收标识符（标识映射）并将其应用于其当前的映射实现（通常是特定于集合的深度树遍历和/或哈希表的组合）以查找当前负责的处理程序实现和处理程序实现然后根据请求内容选择适当的操作+响应。所有这些特定于实现的问题都隐藏在 Web 界面后面；只能通过 Web 界面访问的客户端无法假定它们的性质。</p><p>如上所述，一个资源可以有许多标识符。换句话说，当用于访问服务器时，可能存在两个或多个具有等效语义的不同 URI。也可能有两个 URI 导致在访问服务器时使用相同的机制，但这些 URI 标识两个不同的资源，因为它们的含义不同。语义是分配资源标识符和用表示填充这些资源的行为的副产品。服务器或客户端软件在任何时候都不需要知道或理解 URI 的含义——它们只是作为一个渠道，资源的创建者（人类命名机构）通过它可以将表示与由 URI 标识的语义相关联。 URI。换句话说，服务器上没有资源；只是通过资源定义的抽象接口提供答案的机制。这可能看起来很奇怪，但这就是使 Web 能够跨许多不同实现工作的本质。</p><p>尽管 URI 设计符合 REST 的标识符架构概念，但仅靠语法不足以强制命名机构根据资源模型定义自己的 URI。一种滥用形式是在超媒体响应表示引用的所有 URI 中包含标识当前用户的信息。当软件试图将 Web 视为分布式文件系统时，会发生与 REST 资源接口的另一个冲突。由于文件系统公开其信息的实现，因此存在将这些信息“镜像”到多个站点的工具，作为负载平衡和重新分配更接近用户的内容的一种手段。但是，它们之所以能够这样做，只是因为文件具有一组固定的语义（命名的字节序列），可以轻松复制。相比之下，尝试将 Web 服务器的内容镜像为文件将失败，因为资源接口并不总是与文件系统的语义匹配，并且因为数据和元数据都包含在表示的语义中并且对表示的语义很重要. 可以在远程站点复制 Web 服务器内容，但只能通过复制整个服务器机制和配置，或选择性地仅复制那些具有已知静态表示的资源。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>![image-20210913181829225](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913181829225.png)</p><p>REST 使用各种连接器类型（在<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#tab_5_2">表 5-2</a>中进行了总结）来封装访问资源和传输资源表示的活动。连接器为组件通信提供了一个抽象接口，通过提供清晰的关注点分离和隐藏资源和通信机制的底层实现来增强简单性。接口的通用性还实现了可替换性：如果用户只能通过抽象接口访问系统，则可以在不影响用户的情况下替换实现。由于连接器管理组件的网络通信，因此可以在多个交互之间共享信息，以提高效率和响应能力。所有 REST 交互都是无状态的。也就是说，每个请求都包含连接器理解请求所需的所有信息，独立于可能在它之前的任何请求。这种限制实现了四个功能：1）它消除了连接器在请求之间保留应用程序状态的任何需要，从而减少了物理资源的消耗并提高了可扩展性；2）它允许并行处理交互，而不需要处理机制理解交互语义；3）它允许中介孤立地查看和理解请求，这在服务动态重新排列时可能是必要的；并且，4) 它强制所有可能影响缓存响应可重用性的信息出现在每个请求中。主要的连接器类型是客户端和服务器。第三种连接器类型，缓存连接器，可以位于客户端或服务器连接器的接口上，以便保存对当前交互的可缓存响应，以便它们可以重用于以后请求的交互。REST 试图在缓存行为的透明性需求与高效使用网络的需求之间取得平衡，而不是假设始终需要绝对透明性。缓存能够确定响应的可缓存性，因为接口是通用的而不是特定于每个资源的。默认情况下，对检索请求的响应是可缓存的，而对其他请求的响应是不可缓存的。如果某种形式的用户身份验证是请求的一部分，或者如果响应指示不应共享它，则该响应只能由非共享缓存进行缓存。组件可以通过包含将交互标记为可缓存、不可缓存或仅在有限时间内可缓存的控制数据来覆盖这些默认值。解析器将部分或完整的资源标识符转换为建立组件间连接所需的网络地址信息。连接器类型的最后一种形式是隧道，它只是跨连接边界中继通信，例如防火墙或较低级别的网络网关。它被建模为 REST 的一部分而不是作为网络基础设施的一部分抽象出来的唯一原因是某些 REST 组件可能会从活动组件行为动态切换到隧道行为。主要示例是 HTTP 代理，它响应 CONNECT 方法请求 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_71">71</a> ]切换到隧道，从而允许其客户端使用不允许代理的不同协议（例如 TLS）直接与远程服务器通信。当两端终止通信时，隧道消失。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>![image-20210913182732672](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913182732672.png)</p><p>用户代理使用客户端连接器发起请求并成为响应的最终接收者。最常见的示例是 Web 浏览器，它提供对信息服务的访问并根据应用程序需要呈现服务响应。源服务器使用服务器连接器来管理所请求资源的命名空间。它是其资源表示的最终来源，并且必须是旨在修改其资源值的任何请求的最终接收者。每个源服务器为其服务提供一个通用接口作为资源层次结构。资源实现细节隐藏在接口后面。中间组件既充当客户端又充当服务器，以便在可能的翻译、请求和响应的情况下进行转发。</p><p>![image-20210913183608285](/Users/xiaoqizong/Library/Application Support/typora-user-images/image-20210913183608285.png)</p><p>REST 的客户端-服务器关注点分离简化了组件实现，降低了连接器语义的复杂性，提高了性能调优的有效性，并增加了纯服务器组件的可扩展性。分层系统约束允许在通信中的各个点引入中介——代理、网关和防火墙——而不改变组件之间的接口，从而允许它们通过大规模共享缓存来协助通信转换或提高性能。REST 通过将消息约束为自描述性来实现中间处理：请求之间的交互是无状态的，标准方法和媒体类型用于指示语义和交换信息，响应明确指示可缓存性。由于组件是动态连接的，它们的排列和功能对于特定的应用程序操作具有类似于管道和过滤器样式的特性。尽管 REST 组件通过双向流进行通信，但每个方向的处理都是独立的，因此容易受到流转换器（过滤器）的影响。通用连接器接口允许基于每个请求或响应的属性将组件放置在流上。服务可以使用复杂的中介层次结构和多个分布式源服务器来实现。REST 的无状态特性允许每个交互独立于其他交互，无需了解整体组件拓扑，这是 Internet 规模架构不可能完成的任务，并允许组件充当目的地或中介，动态确定通过每个请求的目标。连接器只需要在其通信范围内知道彼此的存在，尽管出于性能原因，它们可能会缓存其他组件的存在和功能。</p><p>客户端连接器检查资源标识符，以便为每个请求选择适当的通信机制。例如，当标识符指示它是本地资源时，客户端可以被配置为连接到特定代理组件，可能充当注释过滤器的代理组件。同样，客户端可以配置为拒绝对某些标识符子集的请求。REST 不限制特定协议的通信，但它确实限制了组件之间的接口，因此限制了组件之间可能以其他方式进行的交互和实现假设的范围。</p><p>REST 组件交互以分层的客户端-服务器风格构建，但通用资源接口的附加约束为中介提供了可替代性和检查的机会。请求和响应具有远程调用风格的外观，但 REST 消息针对的是概念资源而不是实现标识符。已经进行了多次尝试将 Web 体系结构建模为分布式文件系统（例如 WebNFS）的形式或分布式对象系统 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_83">83</a> ]。然而，他们将各种 Web 资源类型或实现策略排除为“不有趣”，而实际上它们的存在使这些模型的假设无效。REST 运行良好，因为它不会将资源的实现限制为某些预定义的模型，允许每个应用程序选择最符合其自身需求的实现，并能够在不影响用户的情况下替换实现。向消费组件发送资源表示的交互方法与基于事件的集成 (EBI) 风格有一些相似之处。主要区别在于 EBI 样式是基于推送的。包含状态的组件（相当于 REST 中的源服务器）在状态更改时发出事件，无论是否有任何组件实际上对此类事件感兴趣或侦听此类事件。在 REST 风格中，消费组件通常会提取表示。尽管将其视为希望监控单个资源的单个客户端时效率较低，但 Web 的规模使得不受监管的推送模型不可行。</p><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><ul><li><p>围绕资源组织 API 设计</p><p>关注 Web API 公开的业务实体。如果可能，资源 URI 应基于名词（资源）而不是动词（对资源的操作）。资源不必基于单个物理数据项。避免创建简单地反映数据库内部结构的 API。REST 的目的是对实体以及应用程序可以对这些实体执行的操作进行建模。客户端不应暴露于内部实现。实体通常被组合成集合（订单、客户）。集合是与集合中的项目不同的资源，应该有自己的 URI。如有必要，在数据库和 Web API 之间引入一个映射层。这样，客户端应用程序就与底层数据库方案的更改隔离开来。</p><p>在 URI 中采用一致的命名约定。一般来说，对引用集合的 URI 使用复数名词会有所帮助。将集合和项目的 URI 组织成层次结构是一种很好的做法。这种方法有助于保持 Web API 的直观性。</p><p>还要考虑不同类型资源之间的关系以及如何公开这些关联。更好的解决方案是在 HTTP 响应消息的正文中提供指向相关资源的可导航链接。在更复杂的系统中，提供 URI 使客户端能够浏览多个级别的关系可能很诱人，例如<code>/customers/1/orders/99/products</code>. 但是，如果资源之间的关系在未来发生变化，这种复杂程度可能难以维护并且不灵活。相反，尽量保持 URI 相对简单。一旦应用程序拥有对资源的引用，就应该可以使用此引用来查找与该资源相关的项目。可以将前面的查询替换为 URI<code>/customers/1/orders</code>来查找客户 1 的所有订单，然后<code>/orders/99/products</code>查找该订单中的产品。</p><p>另一个因素是所有 Web 请求都会对 Web 服务器施加负载。请求越多，负载越大。因此，尽量避免暴露大量小资源的“健谈”Web API。此类 API 可能需要客户端应用程序发送多个请求以查找其所需的所有数据。相反，您可能希望对数据进行非规范化并将相关信息组合到可以通过单个请求检索的更大资源中。但是，您需要平衡这种方法与获取客户端不需要的数据的开销。检索大对象会增加请求的延迟并产生额外的带宽成本。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-string">orders</span> // <span class="hljs-string">Good</span><br><br><span class="hljs-string">https</span>://<span class="hljs-string">adventure-works</span>.<span class="hljs-string">com</span>/<span class="hljs-built_in">create-order</span> // <span class="hljs-string">Avoid</span><br></code></pre></td></tr></table></figure></li><li><p>根据 HTTP 方法定义 API 操作</p><p>HTTP 协议定义了许多为请求分配语义的方法。大多数 RESTful Web API 使用的常见 HTTP 方法是：</p><ul><li><strong>GET</strong>在指定的 URI 处检索资源的表示。响应消息的正文包含所请求资源的详细信息。</li><li><strong>POST</strong>在指定的 URI 处创建一个新资源。请求消息的正文提供了新资源的详细信息。请注意，POST 还可用于触发实际上不创建资源的操作。</li><li><strong>PUT</strong>创建或替换指定 URI 处的资源。请求消息的正文指定要创建或更新的资源。</li><li><strong>PATCH</strong>执行资源的部分更新。请求正文指定要应用于资源的一组更改。</li><li><strong>DELETE</strong>删除指定 URI 处的资源。</li></ul><p>特定请求的效果应取决于资源是集合还是单个项目。</p><ul><li>POST 请求创建一个资源。服务器为新资源分配一个 URI，并将该 URI 返回给客户端。POST 请求还可用于将数据提交到现有资源进行处理，而无需创建任何新资源。</li><li>PUT 请求创建资源<em>或</em>更新现有资源。客户端指定资源的 URI。请求正文包含资源的完整表示。如果具有此 URI 的资源已存在，则会替换它。否则，如果服务器创建一个新资源。服务器可能支持更新，但不支持通过 PUT 创建。是否支持通过 PUT 创建取决于客户端是否可以在资源存在之前有意义地为其分配 URI。如果没有，则使用 POST 创建资源并使用 PUT 或 PATCH 进行更新。</li><li>PATCH 请求对现有资源执行<em>部分更新</em>。客户端指定资源的 URI。请求正文指定要应用于资源的一组<em>更改</em>。这比使用 PUT 更有效，因为客户端只发送更改，而不是资源的整个表示。从技术上讲，如果服务器支持，PATCH 还可以创建新资源（通过指定对“空”资源的一组更新）。</li></ul><p>PUT 请求必须是幂等的。如果客户端多次提交相同的 PUT 请求，结果应该始终相同（相同的资源将被修改为相同的值）。POST 和 PATCH 请求不保证是幂等的。</p></li><li><p>符合 HTTP 语义</p><p>JSON 合并补丁稍微简单一些。补丁文档与原始 JSON 资源具有相同的结构，但仅包含应更改或添加的字段子集。此外，可以通过<code>null</code>在补丁文档中指定字段值来删除字段。（这意味着如果原始资源可以具有显式空值，则合并补丁不适合。）JSON 合并补丁的媒体类型是<code>application/merge-patch+json</code>.如果原始资源可以包含显式空值，则不适合合并补丁，因为<code>null</code>补丁文档中的特殊含义。此外，补丁文档没有指定服务器应用更新的顺序。这可能重要也可能无关紧要，具体取决于数据和域。<a href="https://tools.ietf.org/html/rfc6902">RFC 6902 中</a>定义的 JSON 补丁更加灵活。它将更改指定为要应用的操作序列。操作包括添加、删除、替换、复制和测试（以验证值）。JSON 补丁的媒体类型是<code>application/json-patch+json</code>.</p><p>如果在向客户端发送响应之前等待完成，可能会导致无法接受的延迟。如果是这样，请考虑使操作异步。返回 HTTP 状态代码 202（已接受）以指示请求已被接受进行处理但尚未完成。您应该公开一个返回异步请求状态的端点，以便客户端可以通过轮询状态端点来监视状态。在 202 响应的 Location 标头中包含状态端点的 URI。如果客户端向此端点发送 GET 请求，则响应应包含请求的当前状态。或者，它还可以包括预计完成时间或取消操作的链接。</p></li><li><p>使用 HATEOAS 启用导航到相关资源</p><p>REST 背后的主要动机之一是应该可以在不需要 URI 方案的先验知识的情况下导航整个资源集。每个 HTTP GET 请求都应返回通过响应中包含的超链接查找与所请求对象直接相关的资源所必需的信息，并且还应提供描述对这些资源中的每一个可用的操作的信息。这一原则被称为 HATEOAS，或作为应用程序状态引擎的超文本。该系统实际上是一个有限状态机，对每个请求的响应都包含从一种状态转移到另一种状态所需的信息；不需要其他信息。</p><p>返回的链接集可能会更改，具体取决于资源的状态。这就是超文本作为“应用程序状态引擎”的含义。</p></li></ul><p>REST 要求客户端向服务器发出请求，以便检索或修改服务器上的数据。一个请求通常包括：</p><ul><li>一个 HTTP 动词，它定义了要执行的操作类型</li><li>一个<em>标头</em>，它允许客户端传递有关请求的信息</li><li>资源的路径</li><li>包含数据的可选消息正文</li></ul><p>我们在请求中使用了 4 个基本的 HTTP 动词来与 REST 系统中的资源进行交互：</p><ul><li>GET — 检索特定资源（通过 id）或资源集合</li><li>POST — 创建一个新资源</li><li>PUT — 更新特定资源（通过 id）</li><li>DELETE — 通过 id 删除特定资源</li></ul><p>请求必须包含指向应该对其执行操作的资源的路径。在 RESTful API 中，应该设计路径以帮助客户端了解正在发生的事情。路径的第一部分应该是资源的复数形式。<code>fashionboutique.com/customers/223/orders/12</code>即使您以前从未见过这条特定路径，like 路径也很清楚它指向的内容，因为它是分层的和描述性的。我们可以看到，我们正在<code>id</code>为<code>id</code>223的客户访问12的订单。路径应包含定位资源所需的特定程度所需的信息。在引用资源列表或集合时，并不总是需要添加<code>id</code>. 例如，对<code>fashionboutique.com/customers</code>路径的 POST 请求不需要额外的标识符，因为服务器将为<code>id</code>新对象生成一个。如果我们尝试访问单个资源，则需要<code>id</code>在路径后附加。例如： <code>GET fashionboutique.com/customers/:id</code>— 检索<code>customers</code>资源中<code>id</code>指定的项目。 <code>DELETE fashionboutique.com/customers/:id</code>— 删除<code>customers</code>资源中<code>id</code>指定的项目。</p><p>人类应该能够轻松阅读和构建 URL。这有助于发现并简化在没有良好支持的客户端库的平台上的采用。除了友好的 URL 之外，可以移动或重命名的资源应该公开一个包含唯一稳定标识符的 URL。可能需要与服务交互以从资源的友好名称中获取稳定的 URL，例如某些服务使用的“/my”快捷方式。稳定标识符不需要是 GUID。操作必须尽可能使用正确的 HTTP 方法，并且必须遵守操作幂等性。HTTP 方法通常称为 HTTP 动词。</p><p>随着数据的增长，集合也在增长。规划分页对于所有服务都很重要。因此，当有多个页面可用时，序列化有效负载必须包含下一个页面的不透明 URL。集合查询的结果可以根据属性值进行排序。该属性由*$orderBy<em>查询参数的值确定。如果服务不支持按</em>$orderBy*表达式中命名的属性进行排序，则服务必须以响应不支持的请求部分中定义的错误消息进行响应。</p><p>如果调用者请求在功能允许列表中发现不受支持的功能，服务必须提供错误响应。错误响应必须是来自 4xx 系列的 HTTP 状态代码，指示无法满足请求。</p><p>由于 REST 专门针对分布式信息系统，因此它将应用程序视为信息和控制替代方案的内聚结构，用户可以通过它来执行所需的任务。小粒度或中粒度消息用于控制语义，但大部分应用程序工作是通过包含完整资源表示的大粒度消息完成的。请求语义的最常见形式是检索资源的表示（例如，HTTP 中的“GET”方法），通常可以将其缓存以供以后重用。REST 将所有控制状态集中到响应交互而接收到的表示中。目标是通过消除服务器在当前请求之外保持对客户端状态的感知的任何需要来提高服务器可伸缩性。An application’s state is therefore defined by its pending requests, the topology of connected components (some of which may be filtering buffered data), the active requests on those connectors, the data flow of representations in response to those requests, and the processing of those representations as they are received by the user agent.只要没有未完成的请求，应用程序就会达到稳定状态；即，它没有未决请求，并且对其当前请求集的所有响应都已完全接收或接收到可以将它们视为表示数据流的程度。对于浏览器应用程序，此状态对应于“网页”，包括主要表示和辅助表示，例如内嵌图像、嵌入的小程序和样式表。应用稳态的重要性体现在它们对用户感知性能和网络请求流量突发性的影响中。浏览器应用程序的用户感知性能取决于稳态之间的延迟：在一个网页上选择超媒体链接和为下一个网页呈现可用信息之间的时间段。因此，浏览器性能的优化集中在减少这种通信延迟上。由于基于 REST 的架构主要通过资源表示的传输进行通信，因此延迟可能会受到通信协议设计和表示数据格式设计的影响。在接收到响应数据时增量呈现响应数据的能力取决于媒体类型的设计和每个表示中的布局信息（内嵌对象的视觉尺寸）的可用性。</p><p>一个有趣的观察是最有效的网络请求是不使用网络的请求。换句话说，重用缓存响应的能力可显着提高应用程序性能。尽管由于查找开销，使用缓存会为每个单独的请求增加一些延迟，但即使是一小部分请求导致可用缓存命中，平均请求延迟也会显着降低。应用程序的下一个控制状态驻留在第一个请求资源的表示中，因此获得第一个表示是一个优先事项。因此，REST 交互通过“先响应后思考”的协议得到改进。换句话说，一个需要每个用户操作多次交互的协议，以便在发送内容响应之前执行诸如协商功能功能之类的事情，将比 （一种协议，它首先发送最有可能是最佳的，然后在第一个响应不令人满意时为客户端提供一个可供选择的列表。） 感知速度更慢。应用程序状态由用户代理控制和存储，并且可以由来自多个服务器的表示组成。除了将服务器从存储状态的可扩展性问题中解放出来之外，这还允许用户直接操作状态（例如，Web 浏览器的历史记录），预测该状态的变化（例如，链接映射和表示的预取），并跳转从一个应用程序到另一个应用程序（例如，书签和 URI 条目对话框）。因此，模型应用程序是一个引擎，通过检查和选择当前表示集合中的替代状态转换，从一个状态移动到下一个状态。毫不奇怪，这与超媒体浏览器的用户界面完全匹配。但是，该样式并不假定所有应用程序都是浏览器。事实上，应用程序的详细信息通过通用连接器接口对服务器隐藏，因此用户代理同样可以是为索引服务执行信息检索的自动化机器人，寻找符合特定标准的数据的个人代理，或维护Spider 忙于在信息中查找损坏的引用或修改的内容 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_39">39</a> ]。</p><p>REST 确定的 HTTP 中的关键问题领域包括规划新协议版本的部署、将消息解析与 HTTP 语义和底层传输层 (TCP) 分开、区分权威和非权威响应、细粒度控制缓存，以及无法自我描述的协议的各个方面。REST 还被用于对基于 HTTP 的 Web 应用程序的性能进行建模，并预测诸如持久连接和内容协商等扩展的影响。最后，REST 已被用于将标准化 HTTP 扩展的范围限制在适合架构模型的范围内，而不是允许滥用 HTTP 的应用程序同样影响标准。</p><p>REST 的主要目标之一是支持在已经部署的架构中逐步和分散部署变更。通过引入版本控制要求和规则来扩展协议的每个语法元素，对 HTTP 进行了修改以支持该目标。HTTP 请求语义由请求方法名称表示。只要可以在客户端、服务器和它们之间的任何中介之间共享一组标准化的语义，就允许方法扩展。不幸的是，早期的 HTTP 扩展，特别是 HEAD 方法，使得 HTTP 响应消息的解析依赖于了解请求方法的语义。这导致了部署矛盾：如果接收方需要知道方法的语义才能被中介安全转发，那么在部署新方法之前必须更新所有中介。通过将解析和转发 HTTP 消息的规则与与新 HTTP 协议元素关联的语义分离，此部署问题已得到解决。例如，HEAD 是唯一一种方法，Content-Length 头字段除了表示消息体长度之外，还有其他意义，并且没有新的方法可以改变消息长度的计算。GET 和 HEAD 也是条件请求头字段具有缓存刷新语义的唯一方法，而对于所有其他方法，它们具有前提条件的含义。同样，HTTP 需要一个通用规则来解释新的响应状态代码，以便可以部署新的响应而不会显着损害旧客户端。因此，我们扩展了规则，即每个状态代码都属于由其三位十进制数的第一位表示的类别：100-199 表示消息包含临时信息响应，200-299 表示请求成功，300 -399 表示请求需要重定向到另一个资源， 400-499 表示客户端犯了一个不应重复的错误， 500-599 表示服务器遇到了错误，但客户端可能会得到更好的稍后（或通过其他服务器）响应。如果接收者不理解给定消息中状态代码的特定语义，那么他们必须像对待它的类中的 x00 代码一样对待它。</p><p>REST 将组件之间的消息限制为自描述的，以支持交互的中间处理。由于 REST 试图在对高效、低延迟行为的需求与对语义透明缓存行为的需求之间取得平衡，因此 HTTP 允许应用程序确定缓存要求而不是将其硬编码到协议本身中是至关重要的。协议要做的最重要的事情是完整准确地描述正在传输的数据，这样任何应用程序都不会被愚弄，认为它只有一件事，而实际上它有其他东西。HTTP/1.1 通过添加 Cache-Control、Age、Etag 和 Vary 标头字段来实现这一点。</p><p>所有资源都将请求（由方法、标识符、请求头字段，有时是表示）映射到响应（由状态代码、响应头字段，有时是表示）。</p><p>HTTP 不支持回写缓存。HTTP 缓存不能假设通过它写入的内容与从对该资源的后续请求中可检索的内容相同，因此它无法缓存 PUT 请求正文并将其重用于以后的 GET 响应。这条规则有两个原因：1) 元数据可能在幕后生成，2) 无法从 PUT 请求中确定对以后 GET 请求的访问控制。但是，由于使用 Web 的写入操作极为罕见，因此缺少回写缓存不会对性能产生重大影响。</p><p>Cookie 还违反了 REST，因为它们允许在没有充分识别其语义的情况下传递数据，从而成为安全和隐私方面的问题。cookie 与 Referer [sic] 标头字段的组合可以在用户在站点之间浏览时对其进行跟踪。因此，Web 上基于 cookie 的应用程序永远不会可靠。应该通过匿名身份验证和真正的客户端状态来完成相同的功能。使用上下文设置 URI 而不是 cookie 的明智使用可以更有效地实现涉及偏好的状态机制，其中明智意味着每个状态一个 URI，而不是由于嵌入了用户 ID 的无限数量的 URI。理想的 ReSTful 服务允许客户端（可能不在浏览器中）<em>在一个请求中</em>执行任何需要的任务；因为执行此操作所需的完整状态由客户端保存，而不是由服务器保存。由于客户端完全控制状态，它可以自己创建状态（如果这是合法的），并且只与 API 对话以“完成”。需要 cookie 会使这变得困难。对于浏览器以外的客户端，与查询参数、普通请求头或请求正文相比，管理 cookie 是一个相当大的不便。另一方面，在浏览器中，使用 cookie 可以让很多事情变得更简单。</p><h1 id="Web成熟度模型"><a href="#Web成熟度模型" class="headerlink" title="Web成熟度模型"></a>Web成熟度模型</h1><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img54.png" alt="img54"></p><p>万维网的技术形成了网络服务的技术栈。当人们设计 Web 服务时，他们倾向于从堆栈底部选择一些技术。您可以通过查看他们是选择零、一项、两项还是三项技术来粗略地判断他们。当我说您从堆栈中选择时，我并不是说您会找到根本不使用 HTTP 或没有 URI 的 Web 服务。我的意思是有一类 Web 服务并没有真正获得 URI 或没有真正获得 HTTP。该模型之所以有用，是因为这三种技术是 RESTful 约束的真实实现。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/overview.png" alt="overview"></p><p>我要强调的是，RMM 虽然是思考 REST 元素的好方法，但并不是 REST 本身级别的定义。Roy Fielding 已经明确表示，<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">级别 3 RMM 是 REST 的先决条件</a>。 RMM 的有用之处在于它提供了一个很好的逐步方式来理解rest背后的基本思想。因此，我认为它是帮助我们了解概念的工具，而不是应该在某种评估机制中使用的东西。我认为我们还没有足够的例子来真正确定 restful 方法是集成系统的正确方法，我确实认为这是一种非常有吸引力的方法，并且在大多数情况下我会推荐这种方法。</p><p>该模型的吸引力在于它与常见设计技术的关系。</p><ul><li>级别 1 通过使用分而治之，将大型服务端点分解为多个资源来解决处理复杂性的问题。</li><li>级别 2 引入了一组标准的动词，以便我们以相同的方式处理类似的情况，消除不必要的变化。</li><li>级别 3 引入了可发现性，提供了一种使协议更具自文档性的方法。</li></ul><hr><ul><li><p>0级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img55.png" alt="img55"></p><p>如果您查看 XML-RPC 服务或典型的 SOAP 服务（例如 Google 现已弃用的搜索服务），您会看到一些看起来很像 C 库的东西。有很多函数，有时用句点命名。所有这些功能都可以通过向一个 URI 发送 POST 请求来访问。这些网站很烦人，因为它们实际上并不在网络上。有一个小的基于网络的窥视孔进入其他宇宙，你只能通过窥视孔传递消息来与另一个宇宙交流。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level0.png" alt="level0"></p><p>该模型的出发点是使用 HTTP 作为远程交互的传输系统，但不使用任何网络机制。本质上，您在这里所做的是使用 HTTP 作为您自己的远程交互机制的隧道机制，通常基于<a href="http://www.eaipatterns.com/EncapsulatedSynchronousIntegration.html">Remote Procedure Invocation</a>。</p><p>它只是来回传递普通的旧 XML (POX)。如果您使用 SOAP 或 XML-RPC，它的机制基本相同，唯一的区别是您将 XML 消息包装在某种信封中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>The server then will return a document giving me this information<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">doctor</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;mjones&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /appointmentService HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">reason</span>&gt;</span>Slot not available<span class="hljs-tag">&lt;/<span class="hljs-name">reason</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequestFailure</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>1级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img56.png" alt="img56"></p><p>为每个单独的事物提供了一个 URI。如果我们以一级思维回到 XML-RPC 示例，我们可以说它有什么问题。只有一种资源，这个黑匣子。我们看到了解决方案：将复杂性从黑匣子中取出并制造更多资源。将 Web 服务拆分为其分子组件，并为每个分子提供自己的 URI。</p><p>Web 的强大之处在于它为您提供了将任务的固有复杂性拆分为小块的工具。URI 允许您为系统中的每个对象命名。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level1.png" alt="level1"></p><p>在 RMM 中实现 Glory of Rest 的第一步是引入资源。因此，现在我们不再向单个服务端点发出所有请求，而是开始与单个资源进行对话。</p><p>回复携带相同的基本信息，但现在每个时隙都是可以单独寻址的资源。</p><p>使用特定资源预订约会意味着发布到特定时段。</p><p>对于像我这样的对象人来说，这就像特定对象的概念。我们不是在以太中调用某个函数并传递参数，而是在一个特定对象上调用一个方法，为其他信息提供参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>POST /doctors/mjones HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotRequest</span> <span class="hljs-attr">date</span> = <span class="hljs-string">&quot;2010-01-04&quot;</span>/&gt;</span><br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img58.png" alt="img58"></p><p>在 HTTP 层面，Web 的主要进步在于，虽然它可以处理任何类型的操作，但它将读取操作、想要获取数据的操作分开，并对其进行特殊处理。</p><p>在 80 年代和 90 年代，“get”与 FTP、Gopher、WAIS、Archie 和 Comp-U-Store 的含义截然不同。取消引用 FTP URI 是一个巨大的音乐数字。当所有这些协议都转移到 Web 上，并且所有这些信息都获得了 URI 时，突然间“get”对所有这些协议都意味着同样的事情。URI 的意思是“那个”，HTTP 方法的意思是“给我”。这里是堆栈的 URI 部分与 HTTP 部分相遇的地方。RFC 2616 赋予 GET 特定含义。GET 请求必须是安全的和幂等的，等等。GET 的确切含义并不重要。重要的是 GET 对其含义有限制，当存在限制时，您可以围绕它们进行优化：条件 GET、部分 GET、可靠性、可缓存性等等。这就是统一接口的价值。一级服务不遵守这些限制。</p><p>您发出的每个 XML-RPC 请求都使用 POST。HTTP 标准对 POST 没有任何限制。您可能正在获取数据，您可能正在修改数据，但无法知道。HTTP POST 的意思是“随便！” 您无法对安全或幂等请求应用优化，因为无法知道哪些请求满足这些要求。</p><p>我们使用的 Web 仅使用 GET 和 POST，因为它们是 HTML 4 支持的唯一方法。但大多数 RESTful 更进一步，将 PUT 和 DELETE 从 POST 中分离出来。我想你可能对这场争论很熟悉。关于这些方法的价值存在争论，但这是关于成熟启发式的第二级争论，而不是关于谁更纯粹或更实用的争论。这些方法或任何方法的论据是，如果我们将它们从 POST 中分离出来，它们开始意味着除了“随便！”之外的其他内容。我们可以围绕它们进行优化。</p><p>缺点是，当您添加 HTTP 方法时，您会限制可以理解您的服务语义的客户端的范围</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level2.png" alt="level2"></p><p>我在 0 级和 1 级的所有交互中都使用了 HTTP POST 动词，但有些人使用 GET 代替或另外使用。在这些级别上并没有太大区别，它们都被用作隧道机制，允许您通过 HTTP 隧道进行交互。级别 2 远离此，使用 HTTP 动词尽可能接近它们在 HTTP 本身中的使用方式。</p><p>在第 2 级，对这样的请求使用 GET 是至关重要的。 HTTP 将 GET 定义为安全操作，即它不会对任何事物的状态进行任何重大更改。这使我们能够以任何顺序安全地多次调用 GET，并且每次都获得相同的结果。这样做的一个重要结果是，它允许请求路由中的任何参与者使用缓存，这是使 Web 表现良好的关键因素。HTTP 包括各种支持缓存的措施，可供通信中的所有参与者使用。通过遵循 HTTP 规则，我们能够利用该功能.</p><p>即使我使用与级别 1 相同的帖子，远程服务的响应方式也存在另一个显着差异。如果一切顺利，该服务将回复 201 的响应代码，以表明世界上有新资源。201 响应包含一个带有 URI 的位置属性，客户端可以使用该 URI 获取该资源在未来的当前状态。此处的响应还包括该资源的表示，以立即为客户端节省额外的调用。</p><p>此响应的重要部分是使用 HTTP 响应代码来指示出现问题。在这种情况下，409 似乎是一个不错的选择，表明其他人已经以不兼容的方式更新了资源。与使用 200 的返回码但包括错误响应不同，在级别 2 中，我们明确地使用了某种类似这样的错误响应。由协议设计者决定使用什么代码，但如果出现错误，应该有一个非 2xx 响应。级别 2 介绍使用 HTTP 动词和 HTTP 响应代码。</p><p>这里有一种矛盾。REST 倡导者谈论使用所有 HTTP 动词。他们还通过说 REST 试图从网络的实际成功中学习来证明他们的方法是合理的。但是万维网在实践中并没有太多地使用 PUT 或 DELETE。网络实践所支持的关键元素是安全（例如 GET）和非安全操作之间的强分离，以及使用状态代码来帮助传达您遇到的错误类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br><br># 响应<br># 失败<br>HTTP/1.1 409 Conflict<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>3级</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/img66.png" alt="img66"></p><p>如果您嵌入实际的 URI，您的客户可以更容易地从一种资源移动到另一种资源。撇开那些不仅可以使用它们的 URI 很烦人的事实，这种设计在客户端和这个特定的 Web 服务之间创建了耦合。您必须编写无法重用的自定义客户端代码。客户端行为由 Web 服务当前提供的文档编程，而不是由过去决定的内容编程。资源之间的连接是一种数据形式，它们应该与其余数据一起在文档中进行描述。让您的客户专注于查看该文档并决定下一步做什么。不是内化关于您将数据放在网络上的位置的特定规则。</p><p><img src="/Users/xiaoqizong/Documents/%E5%9B%BE%E7%89%87/level3.png" alt="level3"></p><p>每个时间片都有一个链接元素，其中包含一个 URI 来告诉我们如何预约。超媒体控制的重点在于它们告诉我们下一步可以做什么，以及我们需要操纵的资源的 URI 来完成它。我们不必知道在哪里发布我们的预约请求，响应中的超媒体控件告诉我们如何去做。</p><p>超媒体控制的一个明显好处是它允许服务器在不破坏客户端的情况下更改其 URI 方案。只要客户端查找“addTest”链接 URI，服务器团队就可以处理除初始入口点之外的所有 URI。</p><p>另一个好处是它可以帮助客户端开发人员探索协议。这些链接为客户开发人员提供了下一步可能的提示。它没有提供所有信息：“self”和“cancel”控件都指向同一个 URI——它们需要确定一个是 GET，另一个是 DELETE。但至少它为他们提供了一个起点，让他们了解更多信息并在协议文档中寻找类似的 URI。</p><p>同样，它允许服务器团队通过在响应中放置新链接来宣传新功能。如果客户端开发人员密切关注未知链接，这些链接可能会触发进一步探索。</p><p>关于如何表示超媒体控件没有绝对的标准。遵循 ATOM ( <a href="https://tools.ietf.org/html/rfc4287">RFC 4287</a> )指出，众所周知<a href="http://www.iana.org/assignments/link-relations.html">的链接关系</a>的定义是<a href="http://www.iana.org/assignments/link-relations.html">链接关系注册表</a>。这些仅限于 ATOM 所做的事情，它通常被视为 3 级的领导者。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 请求<br># 获取指定医生所有可用时间片<br>GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1<br>Host: royalhope.nhs.uk<br>But the response has a new element<br><br># 响应<br># 指定医生所有可用时间片<br>HTTP/1.1 200 OK<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">openSlotList</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;5678&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1600&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1650&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/slot/book&quot;</span> <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/5678&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">openSlotList</span>&gt;</span><br><br># 请求<br># 预约指定医生时间片<br>POST /slots/1234 HTTP/1.1<br>[various other headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointmentRequest</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointmentRequest</span>&gt;</span><br><br># 响应<br># 成功<br>HTTP/1.1 201 Created<br>Location: http://royalhope.nhs.uk/slots/1234/appointment<br>[various headers]<br><br><span class="hljs-tag">&lt;<span class="hljs-name">appointment</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;1234&quot;</span> <span class="hljs-attr">doctor</span> = <span class="hljs-string">&quot;mjones&quot;</span> <span class="hljs-attr">start</span> = <span class="hljs-string">&quot;1400&quot;</span> <span class="hljs-attr">end</span> = <span class="hljs-string">&quot;1450&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">patient</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;jsmith&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/addTest&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment/tests&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;self&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/slots/1234/appointment&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/changeTime&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/doctors/mjones/slots?date=20100104&amp;status=open&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/appointment/updateContactInfo&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/patients/jsmith/contactInfo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;/linkrels/help&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">uri</span> = <span class="hljs-string">&quot;/help/appointment&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appointment</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Thomas Fielding.Architectural Styles and the Design of Network-based Software Architectures.2000</a></p><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Wiki:Representational state transfer</a></p><p><a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html">Leonard Richardson.Justice Will Take Us Millions Of Intricate Moves.2008</a></p><p><a href="https://martinfowler.com/articles/richardsonMaturityModel.html#level0">Martin Fowler.Richardson Maturity Model.2010</a></p><p><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md">Microsoft REST API Guidelines</a></p><p><a href="https://cloud.google.com/apis/design">Google Cloud API 设计指南</a></p><p><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">Ed Price - MSFT.RESTful web API design.2018</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC7231</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc5789">RFC5789</a></p><p><a href="https://zh.wikipedia.org/wiki/XML-RPC">Wiki:XML-RPC</a></p><p><a href="http://xmlrpc.com/">XML-RPC Home</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">Wiki:SOAP</a></p><p><a href="https://web.archive.org/web/20080915090248/http://webservices.xml.com/pub/a/ws/2001/04/04/soap.html">A Brief History of SOAP</a></p><p><a href="https://www.w3.org/TR/soap/">W3C:SOAP</a></p>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-002-MVC</title>
    <link href="/2021/08/26/SAC-002-MVC/"/>
    <url>/2021/08/26/SAC-002-MVC/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本科在校期间（不确定现在是否也是这样，更不确定是否所有学校都是如此），虽然学生通过操作系统、计算机网络等等科目接触到了许许多多的软件架构，例如期末考试一定会去背的7层 OSI 网络协议，结果老师一开始就告诉你事实协议是4层的 TCP/IP 协议，最后学的是5层协议。这巨大的分层架构摆在眼前，仍然会有很多学生被“架构”二字劝退。</p><p>之所以以 MVC 架构开头，是因为当时出去面试，很多面试官都会问一句：“什么是 MVC？”（怀念面试还没有那么内卷的时代）。大多数人是怎么回答的呢？或者说，甚至连面试官都是怎么看待 MVC 架构的呢？下面是摘抄自<a href="https://www.ruanyifeng.com/blog/2007/11/mvc.html">阮一峰</a>老师微博的内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。<br><br><span class="hljs-bullet">*</span> 最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。<br><br><span class="hljs-bullet">*</span> 中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。<br></code></pre></td></tr></table></figure><p>这是正确的吗？下面是维基百科关于 MVC 架构的介绍：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。<br><br><span class="hljs-bullet">*</span> 模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。“Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比如：观察者模式）<br><br><span class="hljs-bullet">*</span> 视图（View）能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。<br><br><span class="hljs-bullet">*</span> 控制器（Controller）起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。<br></code></pre></td></tr></table></figure><p>好像看起来这两个定义不是那么相同。那么，我想问的是，为什么会有这些差异？究竟什么是业务？维基百科所提到的刷新机制是什么？凡此种种，让我尝试给出 MVC 的严谨定义，再着眼于繁杂的工程领域实现。</p><h2 id="1979-THING-MODEL-VIEW-EDITOR"><a href="#1979-THING-MODEL-VIEW-EDITOR" class="headerlink" title="1979 THING-MODEL-VIEW-EDITOR"></a>1979 THING-MODEL-VIEW-EDITOR</h2><p>我们从 wiki 公认的最早提出 MVC 概念的文章《THING-MODEL-VIEW-EDITOR》，以及同一时期的书籍《Smalltalk-80: The Interactive Programming Environment》出发。</p><p>在 Smalltalk-80 系统早期版本的用户界面往往由四种元素组成：文本、文本列表（菜单）、按钮和图形（位图或像素图）。这些元素具有三种基本的用户交互方式：浏览、查看和编辑。故由 Smalltalk-80 系统提出的 MVC ，其核心目标就是定义可共享的用户界面组件。换句话说，MVC 架构就是一种系统模块化，它具有模块化的好处：将功能模块相互隔离，使其应用程序设计人员更容易了解和修改每个特定模块，而无需了解其他模块的一切。</p><p>MVC 将系统分解为三部分：</p><ul><li><p>model</p><p>model 是对现实世界中的事物以数据形式在计算机系统中的抽象表示，包括数据集合以及处理这些数据所需的方法，不包含信息在屏幕上显示的信息。model 是系统中实际完成工作的那些组件（<a href="#model_work">什么工作？</a>）。model 提供一种机制，使 view/controller 可以注册其中，当此 model 的状态发生变化时，可以根据注册信息广播消息（观察者模式）。</p></li><li><p>view</p><p>view 是 model 的视觉展示，它突出 model 的某些属性并抑制其他属性。view 通过请求从 model 中获取展示所需的数据，或者更新 model 中的数据。所有这些请求都包含在 model 所表示的抽象含义中，因此 view 必须知道它所代表的 model 的属性语义（这里虽然表明 model 具有业务含义，但一是 MVC 并没有将业务与技术区分开，二是 MVC 并没有从业务上做过模块划分，它只按照技术领域去做模块划分）。 </p></li><li><p>editor/controller</p><p>controller 是用户和系统之间的链接。它为用户提供<strong>输入入口</strong>，包含其关联 model 和 view 与输入设备（键盘、鼠标、时间等）之间的接口，controller 的工作就是处理 model 的控制或操作（编辑）功能。<strong>注意，controller 不是 view 的补充，view 永远不知道用户输入，例如鼠标操作</strong>。可以通过 controller 将消息发送到 view，用来再现用户命令序列。 controller 还处理与其他 controller 的调度交互。</p><p>editor 是一种特殊的 controller，它允许用户修改视图显示的信息。</p></li></ul><p>view 与 controller 一一对应，每个 controller 只对应一个 model，但一个 model 可能与许多 view/controller 对应。view 和 controller 需要明确地了解它们对应的 model，但 model 不应该知道他们的 view 和 controller。其实从技术的角度讲，model、view、controller 在划分清晰的前提下，是具有可插拔特性的。但是，这里之所以要强调 model 与 view/controller 之间的这种对应关系，是因为 model 承载着业务上的逻辑。</p><p><img src="/images/SAC/MVC/mvc_flow_chart1.png"></p><p>MVC 有以下几种交互场景：</p><ul><li><p>显示数据：view 直接向 model 查询最新数据，经过过滤后以适当的形式向用户展示。</p></li><li><p>用户输入：用户采取一些输入动作，通过 controller 通知 model 执行相应的操作，这有可能会改变 model 的状态。当 model 状态改变时，会向在该 model 中注册的 view/controller 广播它已经改变状态的通知。 然后，收到通知的 view 可以查询 model 有关其新状态的数据，并向用户显示。 </p></li></ul><p>这产生了几个重要问题：</p><ul><li><p>消息广播</p><p>一个 model 绑定了多组 view/controller，但是每次用户的输入动作，都只可能通过一个 controller 传递到 model，所以，当 model 的状态改变时，所涉及的所有 view/controller 都需要感知到这些变化，以及时应对。</p></li><li><p>读写分离</p><p>很显然，MVC 天生就带着读写分离的味道。参考 CQRS，view 直接访问 model 获取最新数据，以用来显示，并且，view 是永远不关心用户具体输入行为的。controller 负责用户输入行为，即增加、删除、修改等操作，在某些场景下，用户的输入在到达了 controller 后，不需要更新 model，就会直接返回给 view 用于展示。</p></li></ul><p>可以看出，MVC 是一种解决用户控制复杂大型数据集问题的通用方案，让用户可以从多个角度控制他们的数据。MVC 有利于数据封装和代码复用。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>随着软件不断发展，UI设计、交互方式、网络协议的不断创新，web 的普及等等事件的发生，传统的 MVC 架构已经不能很好的支持应用的发展，故出现了各种 MVC 变种。</p><p><img src="/images/SAC/MVC/mvc1.png"></p><p><img src="/images/SAC/MVC/mvc2.png"></p><p><img src="/images/SAC/MVC/mvc_flow_chart2.png"></p><p>每个版本的 MVC 结构，虽稍有不同，但都遵循其核心思想–分治。</p><p>从数据访问模式的角度，MVC 进行了读写分离。其中 view 负责数据展示。controller 通过连接 view 与 model 处理用户请求。view 从 model 初获取最新数据（无论是否经过 controller）。</p><p>从功能职责的角度，MVC 明确了数据访问与处理的一般流程，从数据存储、数据处理、请求处理、数据展示这一链路出发，将系统划分为 model、view、controller 三块。这不仅简化了项目结构，使得后续开发类似项目（如 CRUD 类型的管理平台）有迹可循，而且明确了团队分工，降低企业成本，增加沟通效率。</p><p>我们再一次对 MVC 进行定义：</p><ul><li><p><strong>model–领域逻辑</strong></p><p>与之前基本一致，model 是利用面向对象方法，将现实世界问题域中的对象抽象为应用程序对象。在这些抽象对象中封装了业务属性和业务逻辑（需要注意的是，这里并不是说一定要用充血模型甚至胀血模型，因为可以将数据和方法封装在不同的对象中）。<a name="model_work">model 管理与数据相关的所有任务：数据验证、控制会话状态、控制数据源结构（数据库）。</a>  model 拥有与不同数据源交互的方法。</p><p>与之对应的，负责应用程序逻辑的开发人员定义为开发角色，他们负责数据查询、验证、处理等。</p></li><li><p><strong>view–展示逻辑</strong></p><p>与之前基本一致，view 是 model 的外在表现。view 控制数据的显示方式。具体地说，view 负责用户图形界面管理，包括所有表单、按钮、图形元素和所有其他 HTML 元素。通过将应用程序的设计与应用程序的实现相分离，当设计人员决定通过更改表格来更改应用程序界面时，将大大降低出错的风险。 同时，开发人员的工作也大大减少，因为他不再需要查看 HTML 代码元素、设计元素和图形元素。一个 model 可以对应一个或者多个 view。</p><p><strong>与之前不同的是，部分系统的实现中，view 还负责与用户的交互方式。</strong>在这些系统中，view 具有与外界交互的功能，管理着应用系统与外界的接口。一方面，view 为外界提供输入功能，并触发业务逻辑运行（这里若是换一种理解方式，仅仅将 view 视为用户行为事件的触发器或低级事件，在做出简单处理后向 controller 发送高级事件；而 controller 则提供了处理该高级事件的接口，并作出响应，这样就没有了所带来的职责混淆的问题，但无论如何，对于 view 和 controller 职责的定义在此没有发生变化）；另一方面，view 又将业务逻辑运行的结果以某种形式显示给外界。</p><p>与之对应的，负责应用程序外观和展示的开发人员定义为设计角色，他们负责显示从开发角色处获取的数据。</p></li><li><p><strong>controller–应用程序逻辑</strong></p><p>与之前基本一致，controller 管理 view 和 model 之间的关系。controller 负责响应用户请求，与 model 交互并决定应该由哪个 view 显示结果，即将 view 传递的事件转换为对 model 的操作。controller 还负责为用户提供输入入口。</p><p><strong>与之前不同的是，部分系统的实现中，controller 使用 view 传输进来的外部信息，对 model 进行更新；同时，model 的更新与修改也将通过 controller 来通知 view，从而保持 view 与 model 的一致。</strong></p><p>与之对应的，负责前两个角色的工作粘合起来的开发人员定义为集成角色。</p></li></ul><p>有几个重要问题探讨一下。</p><ul><li><p>为什么有些系统的 view 模块，即负责数据展示，又负责提供用户输入入口？按照一开始的设计，这本应该由 view 和 controller 分别负责。</p><p>以 java web 项目为例，无论是前后端分离的项目，还是由 jsp 这类框架动态生成的 html 页面的项目，用户在这种 B/S 架构（留坑）下，读写操作所交互的对象都是浏览器页面。用户没有与后端系统直接交互的手段，用户的所有操作都需要经由浏览器页面，向后端系统发送 http 请求，再由后端系统返回给浏览器的 http 响应，向用户展示最新数据。这样一来，view 和 controller 的职责范围，就有了微妙变化：</p><ul><li>view 不仅负责之前所讲的数据展示，还负责向用户提供输入接口。</li><li>controller 依然提供输入接口，但这是与 view 提供的相关机制结合起来一起向用户提供服务的。此时的 controller 的职责更准确的定义应该是“协调 view 与 model 的工作”，controller 更多负责 http 请求、数据转换、路径映射等工作。其实这与初始版本中的 controller 定义并不冲突，甚至一开始就有 model 中的数据更新之后通知 controller，再由 controller 告知 view 的途径。但是，区别就在于，现在只剩下了 controller 与 model 的交流，而没有了 view 与 model 的交流。</li></ul><p>上述观点都是基于 B/S 架构的，推广一下，部分 C/S 依然适用这样的交互方式。但这并不代表所有系统的交互方式都是如此，极端点的例子，很多数据分析平台，写数据的路径与读数据的路径完全分离，要是结合到 MVC 上，这完全就是 view 与 controller 的职责所在，当然了，每个系统所要解决的问题都不一样，落到实现细节上，并不能刻板的去和理论知识对照（这里要挖坑，需要找时间研究总结下典型场景和相应的交互方式）。</p></li><li><p>为什么 model 的更新消息不像之前一样，直接传递给 view，而是要经过 controller？</p><p>如前所述，有些系统中 view 缺乏与 model 直接交流的路径，所以必须要经过 controller。但是，这并不代表无法实现，还以之前的 java web 项目为例，可以将 web socket 技术看作 model 进行消息通知的手段（当然，model 通知 controller 可以由其他方式实现），那么就可以结合观察者之类的设计模式，达到数据更新时主动告知 view 的目的。</p></li><li><p>读写分离机制还存在吗？</p><p><em><strong>为方便理解，下述将使用具体的技术语言 html、spring mvc controller 以用于区别 view、controller</strong></em></p><p>若是像  java web 这样的系统，即使在不使用类似 web socket 单独开辟出 view 与 model 交流通道的前提下，依然可以对 spring mvc controller 的类型进行分类，即专门负责读请求的 spring mvc controller 与专门负责写请求的 spring mvc controller，这样一来，本质上可以认为，负责读请求的 html/spring mvc controller 是 MVC 中的 view + controller，因为他们是负责数据展示的，此时的 spring mvc controller 实现只是一种技术手段，而 controller 也只是协助 view，向其提供数据；负责写请求的 html/spring mvc controller 是 MVC 中的 controller，因为他们是向用户暴露输入接口的。</p><p>若是抛开这样的具体系统不谈，更加不影响我们去理解读、写两类请求拥有自己的访问模式了。</p></li><li><p>为什么没有了消息广播机制？</p><p>不是所有业务都需要这样的消息通知机制去实时的同步数据，而且考虑到实现这种机制所带来的成本增加，放弃也就不难理解了。</p></li></ul><p>总结一下，MVC 结构具有设计清晰、易于扩展、模块分离的特点，适用于多用户、可扩展、可维护、高交互性的系统，因此在构建 Web 应用中具有显著的优势。MVC 结构很好地表达了用户与系统的交互模式，以及整个系统的程序架构模式。MVC 结构可以很方便的用多个 view 来显示数据，从而可以使系统能方便的支持其它新的客户端类型。对于开发人员来讲，由于 MVC 分离了系统中的数据控制和数据表现 ,从而可以分清开发者的责任，后台开发人员可以专注业务的处理，前台开发人员专注于用户交互界面的设计，从而加快产品开发及推向市场的速度。</p><p><strong>我认为，消息广播机制并不影响 MVC 核心思想–分治在具体系统上的应用，故对这种机制可做取舍。但是，读写分离是 view 与 controller 天生定义所带来的职责区别，所以，若是没有了读写分离，那就不应该是传统 MVC 架构，而应该是拓展 MVC 架构。</strong></p><p><strong>MVC 的核心是通过“分治”的思想划分出职责明确的各个模块，并确定数据在模块间的通信、同步过程。</strong></p><h2 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h2><p>本节我们讨论 MVCS 架构，网上关于此架构的讨论较少。MVCS 中的 S 指的是 service 层。我们先不关注到底是 MVC 中分离出了 Service 还是 MVP 中分离出了 Service，从而形成了 MVCS 的架构（虽然看名字是 MVC 细分演化出来的 S），我们先来探讨下 service 的职责，以及细分出 service 的原因。</p><p>我们模拟一个“茶柜”展示的业务，所要做的事就是在 html 页面上展示一个茶产品的列表。自然，“茶”就是我们抽象出来的业务对象，数据库也有一张 tea table。</p><p>下面是以 spring mvc 为框架的 java web 常见的项目结构。简单介绍一下：</p><ul><li><p>controller</p><p>这部分是 spring mvc 框架中 controller 的实现，下图是 spring mvc 框架的 http 请求处理流程图（读者可以简要感受其原理，深入探讨需学习 servlet + spring mvc 相关知识，本文不过多涉及）。</p><p><img src="/images/SAC/MVC/spring_mvc1.png"></p><p><img src="/images/SAC/MVC/spring_mvc2.jpeg"></p><p>spring mvc 流程简单说就是当 http 请求到达时，由 dispatcherServlet 根据 url、请求类型等条件选择由哪个 handler （例如 TeaController）处理请求，handler中调用实际的业务处理方（即本例中的 service）。业务处理方处理完成后，返回结果，由 handler 将结果封装为 modelAndView 对象，交由 viewResolver 处理，生出渲染对象返回给前端 web 浏览器显示。</p><p>可以看出，整个 spring mvc 框架的职责对应 MVC 架构中的 controler 模块，负责协调 view 与 model 之间的关系，进行调度。</p></li><li><p>service + storage</p><p>service 与 storage 其实是职责细分的结果。</p><ul><li><p>service 负责定义业务领域上的数据行为。</p></li><li><p>storage 负责数据存储访问。数据存储并不特定于具体的数据库，诸如 MySQL、Redis、HDFS，甚至是本地文件系统、第三方应用都可以。ORM 框架只是我们在编写服务端访问数据库代码的语法糖，即 ORM 框架不是数据存储模块本身，而是实现数据存储的工具之一。我们的“数据”仍然存储在各类数据库中，storage 负责服务端与数据库端的交互。</p></li></ul><p>一方面，在细分了 service 与 storage 后，entity 与 PO（persistant object）的关系是清晰的，即 entity 负责数据的业务逻辑抽象，PO 表示数据的逻辑格式。在没有细分 service 与 storage 的 MVC 架构中，可以区分 entity 与 PO 并给予他们上述职责，但更多的可能是将entity 与 PO 混为一谈，即一个类负责了这两块职责，使得业务代码与数据库细节耦合在一起。但是无论怎么说，这些实现都依然属于 model 模块的定义，即负责数据与数据行为。</p><p>另一方面，贫血模型将数据与数据行为分开，充血模型将数据与部分数据行为放在一起。总言之，无论是使用贫血模型还是充血模型的 entity，整个 service + storage + entity + PO 依然属于 model 模块的职责范围。</p><p>总结，service + entity 的组合定义了业务领域的数据与数据行为，storage + PO 定义了底层存储（当然不是指硬盘这样的底层）层面的数据格式和访问方式。数据与访问数据都是 model 模块的一部分。需要注意的是，按照这样的职责划分，service/entity 不应该依赖于 storage/PO，storage/PO 应该依赖于 service/entity。即 service/entity 是业务领域的概念，并不关心底层实现细节。</p></li><li><p>html + css + js</p><p>这部分负责控制数据的显示方式，以及与用户的交互方式。故对应 MVC 中的 view 模块与 conrtoller 模块的部分职责。与之前所讲并无区别。</p><p>目前流行的前后端分离框架中，使用较多的 vue、react 等语言，自有其官方推荐的文件组织结构，与此处所举例并无本质区别。在讲到 MVVM 架构之前，对这部分我们不做过多延展。但是，需要注意的是，正如之前所讲，可以看到，controller 模块的职责是协调 view 与 model 之间的关系，其实现是涉及到 B/S 架构中前后端两部分的，并不独立存在。</p><p>像 jsp 这样的动态网页开发技术，其本质是使用 java 语言封装了 html 页面的生成过程。换言之，jsp 的作用就是生成 html 页面，但真正负责数据显示的仍然是 html + css + js 这些技术，故 jsp 应该视为 MVC 架构中的 controller 模块。</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> controller<br>---- TeaController<br>---- QueryTeaController<br><span class="hljs-bullet">-</span> service<br>---- TeaService<br>---- impl<br>-------- TeaServiceImpl<br><span class="hljs-bullet">-</span> storage<br>---- TeaStorage<br>-------- TeaStorageImpl<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> html<br>---- teaList.html<br><span class="hljs-bullet">-</span> css<br>---- teaList.css<br><span class="hljs-bullet">-</span> js<br>---- teaList.js<br></code></pre></td></tr></table></figure><p>经过探讨，笔者认为 MVCS 架构的核心是<strong>将数据的业务表达与存储表达区分开</strong>。即业务表达负责定义并实现业务领域上的数据与数据行为，向上提供接口。存储表达负责管理数据存储，与业务脱钩。</p><p>在基于这个定义的基础上，可以反思很多。例如，很多项目将部分业务逻辑实现在了 sql 语句上，这是错误的。正确做法是，首先思考 service 是否要提供该数据行为，在 service 需要提供的基础上，何种数据访问方式（可能是写 sql）能实现这一行为。</p><h2 id="1996-MVP"><a href="#1996-MVP" class="headerlink" title="1996 MVP"></a>1996 MVP</h2><p>TODO:</p><p><em>确保任何操作演示文稿的代码只操作演示文稿，将所有域和数据源逻辑推送到程序的明确分开的区域。</em></p><p>这种模式是一种分层形式，我们将表示代码和域代码保存在单独的层中，域代码不知道表示代码。</p><p>表示代码将操纵富客户端应用程序中的 GUI 小部件和结构、Web 应用程序中的 HTTP 标头和 HTML，或命令行应用程序中的命令行参数和打印语句。然后我们将应用程序划分为两个逻辑模块，所有表示代码在一个模块中，其余的在另一个模块中。</p><p>进一步分层通常用于将数据源代码与域（业务逻辑）分开，并使用<a href="https://www.martinfowler.com/eaaCatalog/serviceLayer.html">服务层</a>将域分开。出于分离表示的目的， 我们可以忽略这些进一步的层，将所有这些都称为“领域层”。请记住，域层的进一步分层是可能的。</p><p>除了分隔之外，还有一个严格的可见性规则。演示文稿能够调用域，但反之则不行。这可以作为构建的一部分使用依赖项检查工具进行检查。这里的重点是域应该完全不知道可以使用哪些演示文稿。这既有助于将关注点分开，也支持使用具有相同域代码的多个演示文稿。</p><p>尽管域无法调用演示文稿，但如果发生任何更改，域通常需要通知演示文稿。<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201633612">Observer</a>是解决这个问题的常用方法。域触发一个事件，通过演示观察到该事件，然后演示根据需要从域中重新读取数据。</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://folk.universitetetioslo.no/trygver/2007/MVC_Originals.pdf">Trygve Reenskaug.THING-MODEL-VIEW-EDITOR, 1979.</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.388.2266&rep=rep1&type=pdf">Adele Goldberg.Smalltalk-80: The Interactive Programming Environment, 1984.</a></p><p><a href="https://pdf.sciencedirectassets.com/278653/1-s2.0-S1877705814X00020/1-s2.0-S187770581400352X/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEH4aCXVzLWVhc3QtMSJGMEQCIHc8mQO8Xz3tRDpHYqSrP/Ry9jGIQ34lFez/rSuVfoseAiBlCNu+KUYZoXw0S1GL3pSQnxV02UzwETl0RXq/0nv1ASqDBAi2//////////8BEAQaDDA1OTAwMzU0Njg2NSIMDxrH7laEvfWEj51EKtcD1pVPGdkhPhPfFhxJxrIUDkQCkABfA1k97pShjs5vjQ1Mxzxjc+ikAAgzcw+17pF1HkVVrQcqWR7+Rl8WL0HDuLp8NfyQUmpxyD2gZsa8KkU/QovaQUGuMRAJCWlODemCspy7CHyhJXSxsbfRqO1Gnk6VklR1DwEP1lEOn3Oq1CRhI+PlJj2T/efZCJO+SwADMhtU9REQ5z8len68ckwKwdVSaMSVnH8cJ1lwpH5o8UKTZB9h9a7YZyZaxI24vrrCQQ1fhcjz58sx5Z8KDRIOYyLRoqlqk+vRx7H+cnndWI3vN63iK1qFrTXnFzJlvJF0TKULP63iFPZ6bgu3IXyzPqzZ83q646Xxw3IJMKEjgX8oFbqVu7w5THXnbtjxlVjxmyNWuAO/+9YUAgLOlNzP84+b1ZWUmj3d06cb2gUUEKnIF5kLpt/8zeFk+aYRZJgZzy4MYlHynbdMa4u9n93ETAi+jaxXvBzRMss1Z46t4tiSCQGx59rP6reT54SMaCkEiUdfqETLhq52abZ66GKwpoR5ci9aaW57wGRNq/NhTRl2J3xCprbQ8BOjMi9qbZVFpfZwMfXdwmf4WCnZP5OEQB3TCt13VkyL6gG6QoCnqVWRy1t3l9x5MLLVsYkGOqYBj36DquA2msyX9hmkNp9YdnEGxl9C3yVVNU+8qbgjxDBaQsPrG/0fiMupNzlNUvXFjcsuvFHyokR96xItOweKYbGOcc14H+KVp9U1wvkr9dAQ5IeNMgLosyS9JfQVy3VdWRF9G1AdWGtonkumFnrDhPnnGlhlrQcnIUXTZNUyXRTsdlG9zLdMGaRtDGqhOk1CYYeW1E1F4OF+TYLtvV5EpmAI7ZsUwA==&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210830T061856Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWWRCNY73/20210830/us-east-1/s3/aws4_request&X-Amz-Signature=a14fbae4f5014af539585b0a560486fb97c5630a5ab72987b254ab5fb18ac730&hash=5902936a72d87db3275f4fe2aaa2a34bfa8a5f0a15cb91f81f8b039318205651&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S187770581400352X&tid=spdf-9afc5b5d-6a90-40cc-a1e0-743a3a825bb8&sid=9315aae8544ba24f036a61d42bd1116b0a42gxrqa&type=client">Dragos-Paul Pop.Designing an MVC Model for Rapid Web Application Development, 2013.</a></p><p><a href="https://stefanoborini.com/book-modelviewcontroller/">Stefano Borini.Understanding Model-View-Controller.2019</a></p>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAC-001-概述</title>
    <link href="/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/08/26/SAC-001-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>暂时不知道说啥，但是要感谢 hgraca 的博客专栏<a href="https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/">《The Software Architecture Chronicles》</a>给予我灵感。</p><p>暂定目标是：前期总结自己经历学习的架构知识，对一些模棱两可的概念深挖到底，尽力丰富自己的见识，并沉淀下来一些属于自己的感悟。</p><p>TODO:</p><p>A software architecture is an abstraction of the run-time elements of a software system during some phase of its operation.A system may be composed of many levels of abstraction and many phases of operation, each with its own software architecture.</p><p><strong>软件体系结构</strong>是一个软件系统的运行时间的元素在其操作期间的某些阶段的抽象。一个系统可能由许多抽象层次和许多操作阶段组成，每个阶段都有自己的软件架构。</p><p>软件架构的核心是抽象原则：通过封装隐藏系统的一些细节，以便更好地识别和维持其属性 。一个复杂的系统将包含许多抽象层次，每个层次都有自己的架构。架构代表该级别系统行为的抽象，因此架构元素由它们提供给该级别其他元素的抽象接口来描述 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_9">9</a>]。在每个元素中可以找到另一个体系结构，定义子元素系统，这些子元素实现由父元素的抽象接口表示的行为。架构的这种递归一直延续到最基本的系统元素：那些不能分解为较不抽象的元素的元素。</p><p>除了架构的层次，一个软件系统通常会有多个操作阶段，如启动、初始化、正常处理、重新初始化和关闭。系统架构的整体描述不仅必须能够描述系统架构在每个阶段的操作行为，还必须能够描述阶段之间转换的架构。</p><p>我们将软件架构的视图与源代码的视图分开，以便专注于独立于给定组件实现的软件运行时特性。因此，架构设计和源代码结构设计虽然密切相关，但却是独立的设计活动。</p><p>A software architecture is defined by a configuration of architectural elements–components, connectors, and data–constrained in their relationships in order to achieve a desired set of architectural properties.</p><p>软件架构是由架构元素（组件、连接器和数据）的配置定义的，这些元素在它们的关系中受到约束，以实现一组所需的架构属性。架构元素包括处理、数据和连接元素。形式是由元素的属性和元素之间的关系——即对元素的约束来定义的。通过捕捉选择建筑风格、选择元素和形式的动机，基本原理为建筑提供了潜在的基础。</p><p>我对软件架构的定义是 Perry 和 Wolf [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_105">105</a> ] 模型中定义的详细版本，除了我排除了基本原理。尽管基本原理是软件架构研究和架构描述的一个重要方面，但将其包含在软件架构的定义中将意味着设计文档是运行时系统的一部分。基本原理的存在与否可以影响架构的演变，但是，一旦构成，架构就独立于其存在的原因。反射系统 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_80">80</a>] 可以使用过去表现的特征来改变未来的行为，但这样做是用另一个较低级别的架构替换一个较低级别的架构，而不是在这些架构中包含基本原理。因此，我们对软件架构的定义包括架构属性，而不是基本原理。基本原理解释了这些属性，缺乏基本原理可能会导致架构随着时间的推移逐渐衰败或退化，但基本原理本身并不是架构的一部分。</p><p>The architecture of a software system defines that system in terms of components and of interactions among those components.</p><p>软件系统的体系结构根据组件和这些组件之间的交互来定义该系统。除了指定系统的结构和拓扑外，体系结构还显示了系统需求和所构建系统的元素之间的预期对应关系。这种模型无法充分描述基于网络的软件架构，因为系统内数据元素的性质、位置和移动通常是系统行为的最重要决定因素</p><p>A component is an abstract unit of software instructions and internal state that provides a transformation of data via its interface.</p><p>组件是软件指令和内部状态的抽象单元，通过其接口提供数据转换。每个组件的行为都是架构的一部分，只要该行为可以从另一个组件的角度观察或辨别 。换句话说，一个组件是由它的接口和它提供给其他组件的服务定义的，而不是由它在接口后面的实现来定义的</p><p>A connector is an abstract mechanism that mediates communication, coordination, or cooperation among components.</p><p>连接器是一种抽象机制，用于调解组件之间的通信、协调或合作。连接器通过将数据元素从一个接口传输到另一个接口而不更改数据来实现组件之间的通信。相比之下，组件可能（但并非总是）从外部角度转换数据。</p><p>A datum is an element of information that is transferred from a component, or received by a component, via a connector.</p><p>数据是通过连接器从组件传输或由组件接收的信息元素。示例包括字节序列、消息、编组参数和序列化对象，但不包括永久驻留或隐藏在组件中的信息。组件还可以生成数据，例如时钟或传感器的软件封装。</p><p>A configuration is the structure of architectural relationships among components, connectors, and data during a period of system run-time.</p><p>配置是系统运行期间组件、连接器和数据之间架构关系的结构。组件，它是计算的位置。连接器，定义组件之间的交互。配置，它们是交互组件和连接器的集合。</p><p>An architectural style is a coordinated set of architectural constraints that restricts the roles/features of architectural elements and the allowed relationships among those elements within any architecture that conforms to that style.</p><p>架构风格是一组协调的架构约束，它限制架构元素的角色/特征以及在符合该风格的任何架构中这些元素之间允许的关系。由于架构体现了功能性和非功能性属性，因此很难直接比较不同类型系统的架构，甚至是不同环境中设置的相同类型系统的架构。样式是一种对架构进行分类并定义其共同特征的机制 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_38">38</a> ]。每种风格都为组件的交互提供了一个抽象，通过忽略架构其余部分的附带细节来捕捉交互模式的本质 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_117">117</a> ]。架构风格封装了有关架构元素的重要决策，并强调了对元素及其关系的重要约束。此定义允许仅关注架构的连接器或组件接口的特定方面的样式。</p><p>具体来说，架构风格决定了可在该风格实例中使用的组件和连接器的词汇，以及关于如何组合它们的一组约束 [ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_53">53</a> ]。这种对架构风格的限制性观点是他们对软件架构定义的直接结果——将架构视为一种正式的描述，而不是一个正在运行的系统，这导致了仅基于方框图和线图的共享模式的抽象。</p><p>由于将一组命名的约束称为样式可以更容易地传达常见约束的特征，因此我们使用架构样式作为一种抽象方法，而不是作为个性化设计的指标。</p><p>事实上，亚历山大的模式概念并不以建筑元素的重复排列为中心，而是以发生在空间内的事件的重复模式——人类活动和情感——为中心，并理解事件模式不能与它发生的空间[ <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/references.htm#ref_3">3</a> ]。</p><p><em>作为世界中的一个元素，每一种模式都是特定语境、在该语境中反复出现的特定力量系统以及允许这些力量自行解决的特定空间配置之间的关系。</em></p><p><em>作为语言的一种元素，模式是一种指令，它展示了如何一遍又一遍地使用这种空间配置来解决给定的力系统，无论上下文是否相关。</em></p><p><em>简而言之，模式同时也是一个发生在世界上的事情，以及告诉我们如何创建该事物以及何时必须创建它的规则。它既是一个过程，也是一件事；既是对活着的事物的描述，也是对产生该事物的过程的描述。</em></p><style>    .cd-timeline.svelte-1t2uafz .svelte-1t2uafz,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::after,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::before{-webkit-box-sizing:border-box;box-sizing:border-box}.cd-timeline.svelte-1t2uafz{font-size:1.6rem;font-family:"Droid Serif", serif;color:#7f8c97;background-color:#e9f0f5}.cd-timeline.svelte-1t2uafz a{color:#acb7c0;text-decoration:none}.cd-timeline.svelte-1t2uafz img{max-width:100%}.cd-timeline.svelte-1t2uafz h1,h2{font-family:"Open Sans", sans-serif;font-weight:bold}.cd-timeline.svelte-1t2uafz{overflow:hidden;margin:2em auto}.cd-timeline__container.svelte-1t2uafz{position:relative;width:90%;max-width:1170px;margin:0 auto;padding:2em 0}.cd-timeline__container.svelte-1t2uafz::before{content:'';position:absolute;top:0;left:18px;height:100%;width:4px;background:#d7e4ed}@media only screen and (min-width: 1170px){.cd-timeline.svelte-1t2uafz{margin-top:3em;margin-bottom:3em}.cd-timeline__container.svelte-1t2uafz::before{left:50%;margin-left:-2px}}.cd-timeline__block.svelte-1t2uafz{position:relative;margin:2em 0}.cd-timeline__block.svelte-1t2uafz:after{content:"";display:table;clear:both}.cd-timeline__block.svelte-1t2uafz:first-child{margin-top:0}.cd-timeline__block.svelte-1t2uafz:last-child{margin-bottom:0}@media only screen and (min-width: 1170px){.cd-timeline__block.svelte-1t2uafz{margin:4em 0}}.cd-timeline__img.svelte-1t2uafz{position:absolute;top:0;left:0;width:40px;height:40px;border-radius:50%;-webkit-box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05);box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05)}.cd-timeline__img.svelte-1t2uafz{background:#75ce66}@media only screen and (min-width: 1170px){.cd-timeline__img.svelte-1t2uafz{width:60px;height:60px;left:50%;margin-left:-30px;-webkit-transform:translateZ(0);transform:translateZ(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}.cd-timeline__content.svelte-1t2uafz{position:relative;margin-left:60px;background:white;border-radius:0.25em;padding:1em;-webkit-box-shadow:0 3px 0 #d7e4ed;box-shadow:0 3px 0 #d7e4ed}.cd-timeline__content.svelte-1t2uafz:after{content:"";display:table;clear:both}.cd-timeline__content.svelte-1t2uafz::before{content:'';position:absolute;top:16px;right:100%;height:0;width:0;border:7px solid transparent;border-right:7px solid white}.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{color:#303e49}.cd-timeline__content.svelte-1t2uafz p,.cd-timeline__date.svelte-1t2uafz{font-size:1.3rem}.cd-timeline__content.svelte-1t2uafz p{margin:1em 0;line-height:1.6}.cd-timeline__date.svelte-1t2uafz{display:inline-block}.cd-timeline__date.svelte-1t2uafz{float:left;padding:.8em 0;opacity:.7}@media only screen and (min-width: 768px){.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{font-size:2rem}.cd-timeline__content.svelte-1t2uafz p{font-size:1.6rem}.cd-timeline__date.svelte-1t2uafz{font-size:1.4rem}}@media only screen and (min-width: 1170px){.cd-timeline__content.svelte-1t2uafz{margin-left:0;padding:1.6em;width:45%;-webkit-transform:translateZ(0);transform:translateZ(0)}.cd-timeline__content.svelte-1t2uafz::before{top:24px;left:100%;border-color:transparent;border-left-color:white}.cd-timeline__date.svelte-1t2uafz{position:absolute;width:100%;left:122%;top:6px;font-size:1.6rem}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz{float:right}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz::before{top:24px;left:auto;right:100%;border-color:transparent;border-right-color:white}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__date.svelte-1t2uafz{left:auto;right:122%;text-align:right}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}    </style><section class="cd-timeline js-cd-timeline svelte-1t2uafz">    <div class="cd-timeline__container svelte-1t2uafz">            </div></section>]]></content>
    
    
    <categories>
      
      <category>The Software Architecture Chronicles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD-001-对一个未完成项目的总结</title>
    <link href="/2021/08/19/DDD-001-%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/19/DDD-001-%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容为ZXJY公司内部系统架构、代码、文章、讨论的归纳总结，以及本人对各问题的思考。因保密相关，涉及到敏感内容，会以网络普遍讨论的模型为例。</p><h2 id="ZXJY公司系统架构所面临的问题"><a href="#ZXJY公司系统架构所面临的问题" class="headerlink" title="ZXJY公司系统架构所面临的问题"></a>ZXJY公司系统架构所面临的问题</h2><p><strong>核心问题：微服务数量过多。</strong></p><p>ZXJY从2015年开始全面使用微服务架构后，服务的数量就开始飞涨。某些研发组甚至发展到了，一个业务功能一个微服务的程度（往往是按照数据库表来划分的，这里要埋一个坑，即微服务如何划分的实践问题）。在一开始感受到微服务带来的分工和模块化的优点之后，团队很快就碰到如何管理数量庞大的微服务的棘手问题–<strong>系统复杂程度指数级上升</strong>。</p><ul><li><p>理解困难。</p><ul><li>新人对业务逻辑与代码逻辑的映射、系统架构、代码细节、技术实现理解困难。</li></ul></li><li><p>开发困难。</p><ul><li>难以判断新功能放在哪个微服务更合适（或者说都可以）。</li><li>抽象泄漏。微服务作为SOA的一种类型，其初衷就是希望能够通过对外部提供一个合理抽象的接口，从而屏蔽内部的实现。只要接口定义不变，内部可以独立迭代，从而实现开发流程的扩展性。然而我们很难保证服务拆分和接口设计是合理的，尤其在业务快速迭代的过程中，整个系统的各种基础假设都会被持续迭代。然而一旦某个逻辑被暴露为微服务接口，其抽象就泄露到了整个系统，后续要修改或者下线这个接口的成本是极高的。这就导致了后续即使业务逻辑发生变化，我们也只能捏着鼻子在沿着错误的抽象来修修补补。</li></ul></li><li><p>部署困难。</p><ul><li>一个功能的上线可能涉及到多个微服务，那么怎么打包、上线顺序等等都是问题，当团队开发节奏加快后，频繁的部署使研发、运维人员苦不堪言，很多简单的修改都需要同时更新多个微服务，不但使得工作量大大增加，也使得部署的依赖更加复杂。</li><li>DevOps、敏捷等技术的运用遭受挑战。</li></ul></li><li><p>测试困难。</p><ul><li>本地代码调试困难。</li><li>Bug溯源、定位、追踪复杂。</li></ul></li><li><p>维护困难。</p><ul><li>网络波动对服务性能影响巨大。</li><li>对基础设施迭代不友好。数量庞大的微服务大大拖慢了基础设施迭代和推广的速度，又进一步使得微服务无法得到有效支撑。一个惨痛的现实就是，每次有紧急的基础设施升级，都必须手动升级数量庞大的微服务，带来了巨大的人力浪费。</li></ul></li></ul><h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h2><p>在讨论解决方案之前，应先定义清楚衡量系统架构的指标都有哪些（此处不由得联想到《演进式架构》，或者更广义的说，在讨论任何科学问题时，先行定义清楚问题域边界是至关重要的）。</p><p>在介绍最终衡量指标前，先对陶文的博客<a href="https://github.com/taowen/modularization-examples">《代码防腐》</a>做简要陈述。代码腐败也叫软件熵，是指软件性能随着时间而逐渐恶化或反应性的递减，导致软件出错、不稳定。这并不是一个物理现象，因为软件实际上并不会衰变，而是缺乏敏捷反应、未能随环境变化而修改。显然，正如《没有银弹》一文所说，由于<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">软件本质性</a>所引发出的 complexity、invisibility、conformity、changeability，再加上许多人为因素：软件开发者本人所处时空限制、能力限制导致其并不能做出现在看来“完美”的设计；商业软件本身需要去衡量各种成本，包括资金、人力、时间等等；缺乏完善的测试等。以上因素，导致开发者不得不在本就困难的问题基础上，缺乏思考、设计的情况下赶工开发，致使问题影响范围扩大，又由于没有严格的测试拦截，导致问题得不到有效的反映和遏制，再加之缺乏复盘性的总结学习，导致问题越来越难以解决，即腐败的味道愈加浓重。</p><p>什么样的系统是我们所希望的，我们又要如何去发现代码腐败。</p><p>首先陶文指出了系统应该具备的三点特性，现做出总结。</p><ul><li><p>Autonomy 独立性。</p><p>开发团队担心出现这样的症状：</p><ul><li>沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。</li><li>需求下线困难：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。</li></ul><p>独立性的愿景就是尽量减轻上述的症状，让拆分出来的代码更独立。用以下指标衡量系统的独立性：</p><ul><li>会议时间。</li><li>接口改动次数 / 接口实现改动次数 比率：我们期望大部分时候就可以只改接口实现，而不改接口本身。</li></ul></li><li><p>Consistency 一致性。</p><p>一致性是对可复用 git 仓库的要求，是为了防御常见的设计错误。用以下指标衡量系统的一致性：</p><ul><li>必要参数总量 / 参数总量 比率：把可复用 git 仓库对外提供的函数的参数分为两类，必要参数和非必要参数。非必要参数是指只有 10% 的调用方传递了的参数。</li><li>咨询量：可复用的 git 仓库，应该努力降低使用者的成本。 使用者的最大成本来自于沟通问询。如果文档不清楚，接入方式是手工的，必然会体现在咨询量上。</li><li>接入次数：使用次数只有1次或者2次，就不应该被抽取成可复用的 git 仓库。至少要被使用3次。</li><li>接入率：如果要抽出可复用的代码，出发点应该是一致性，是在团队关键成员达成了一致之后的有意识行为。</li><li>阻断率：阻断率指所有可接入的地方，有多少处上了强制检查，确保了违规行为会被阻断。</li></ul></li><li><p>Feedback 反馈性。</p><p>业务逻辑无论如何做拆分，最终仍然是要集成到一起跑起来的。 无论是编辑时拆分成文件、文件夹、git 仓库，还是运行时拆分成进程，拆分无可避免地引入了“降低反馈速度”的副作用。 一旦产生了分工，就会有你不了解的部分。这也是分工的本意所在，控制知识边界，让普通人也可以参与劳动。 但是软件是要整体集成到一起才能发挥其全部价值。这种“整体”与“部分”的矛盾，造成了反馈性问题。</p><p>开发团队担心出现这样的症状：</p><ul><li>故障定位慢。</li><li>获得真实反馈慢：代码写完了要等审核发版，错过了这个版本又要等一个月公司才会发下个版本。</li><li>本地测试难：稍微有点价值的测试都不是本地可以用 JUnit 写出来的。</li><li>与用户脱轨。</li></ul><p>反馈性的愿景是尽量减少获得反馈的摩檫力。业务逻辑拆分为什么会影响到反馈性呢？这仍然是要归结为人的沟通效率问题（《人月神话》）。能用标准化的方式解决的，就可以减少沟通。能尽量减少信息传递次数的，就可以有效减少传递过程中的信息衰减。用以下指标衡量系统的反馈性：</p><ul><li>工单流转时长。</li><li>故障定位时长。</li><li>代码集成时长。</li></ul></li></ul><p>其次陶文给出了应对代码腐败的策略。</p><ul><li><p>信息隐藏：封装、抽象、依赖倒置。</p><p>在依赖倒置的前提下，需要显式地提炼出最小化接口， 从而让更多的需求改动封闭在更上层的依赖关系里，更多去改实现代码，而不是改接口代码。</p><p>还有一个问题是，如何做到独立性？这里不能依赖人力的 code review，而应该依赖代码结构，限制改动范围。如此一来，模块的 git 仓库是不会造成全局影响。我们就可以放心的把新人分配去写一个独立的模块，而不用担心其设计选择造成大面积的代码腐化。code review 仅需要集中关照主板。并且评价“高内聚低耦合”的标准也可以用主板的代码改动行数进行量化（在完成需求的前提下，主板的代码改动行数越少越好）。</p></li><li><p>分层</p></li><li><p>持续改进</p><p>只对自己写的代码负责要体现在发布变更，告警定位这两个环节里。做好了这两点，就有了持续改进系统的基础保障。</p><ul><li><p>发布变更。单体应用最大的原罪就是变更的粒度太大了。而大粒度变更是稳定性的最大敌人。 切分变更有三种主要的做法：</p><ul><li><p>多进程：把单体进程切分成多进程，控制的是代码的变更。一次只变更其中的一个。因为大部分线上故障都是由变更引起的，所以 SRE 会非常强调部署流程的小心谨慎。 一旦发现有问题，就会被要求立即回滚。这也就导致了搭车上线是非常讨厌的事情，谁知道你搭车进来的改动会不会翻车。 所以拆分成多进程，各上各的就会变成非常强烈的需求。</p><p>但是用拆分进程的方式来解决上线慢的问题也会有一些缺点：</p><ul><li>反馈不集中：小流量的时候，引起的小规模的故障可能观察不出来。</li></ul></li><li><p>灰度数有限：集群规模比较小的时候，总共就几个进程，灰度的刻度就会很大。</p><ul><li>回滚慢：进程替换需要时间。</li></ul></li><li><p>灰度时间有限：上线观察一天已经很夸张了，要更长时间的观察是不好用上线的方式来实现的。</p><ul><li>上线顺序：进程之间经常有数据依赖，并不能总是保持向后兼容。</li></ul></li><li><p>多租户：把所有的业务数据分成租户，控制的是数据的变更。一次只升级一个租户的数据和代码。</p></li><li><p>多变种：分租户还是粒度太粗了，比如说挂掉一个城市也是不可接受的。那么可以在线上同时运行多个版本的代码，然后逐步的切流量，这其实控制的是配置的变更。在不改变进程的情况下，通过配置等方式更灵活地进行装配组合。这样发布和上线就可以解开为两个操作了。上线就是上线，改变进程里的可执行代码。 上线可以不把 feature flag 打开，而是保持原有的行为。 然后再慢慢地打开 feature flag 的流量开关。</p></li></ul><p>当然更极致的做法是同时分租户，也在租户升级的时候切流量。</p></li><li><p>告警定位</p><p>要减轻分工带来的负面影响，最重要的是做好“隔离”。虽然我们把所有的部件都集成到了一起了，但是我们仍然要在“运行时”通过各种手段人为制造出边界，把责任隔离出来。 把责任隔离出来，就是把运行时的行为，与背后负责的团队与个人对应起来。</p><ul><li><p>进程边界</p><p>把不同的 git 仓库跑在不同的进程里。这样只要看是哪个进程出的问题，就可以知道问题是由哪个 git 仓库引起的了。</p><p>进程边界的优点如下：</p><ul><li>完善的跨进程调用监控：相比进程内调用，跨进程调用的监控基础设施要完善得多。</li></ul></li><li><p>操作系统强制的配额和安全性：基础设施更好。</p><ul><li>隔离的内存状态：进程之间不会共享内存，从而产生监控逃逸的影响。</li></ul><p>进程边界的缺点如下：</p><ul><li>适用场景：在前端里启动独立的进程不是常规的做法。</li></ul></li><li><p>性能优化会漏掉依赖：经常我们会把配置等数据读取一次之后就缓存在进程内。这部分依赖就很容易逃逸出监控的范围。</p><ul><li>远离用户：拆分出来的进程往往是越来越靠后台，离用户越远，就越难以倾听到用户的声音。</li></ul><p>我们的目标是在出问题之后，能从运行时的现象找到对应的 git 仓库。</p></li><li><p>函数边界</p><p>无论是编程语言原生支持的同步调用栈，还是需要自研的异步调用栈，其目的都是隔离，从而给 caller/callee 关系建索引。</p></li><li><p>模块边界</p><p>如果有强制的模块规范，那甚至可以做到“内存状态”的隔离，用编译检查等手段禁止全局变量，禁止偷偷地访问另外一个模块的内部状态。 一个进程要读取一份配置，只有第一次RPC的时候我们才能监控到，后续缓存在内存里的访问就是不可见的了。 而模块则不用担心跨模块调用的开销，我们可以把配置缓存在另外一个模块里，这样每次读取配置都是跨模块的调用，从而可以被监控到。</p><p>模块和进程的核心区别就是模块可以适用于更多的运行时（比如iOS，微信小程序），可以用于拆分运行时调用关系更频繁更紧密的界面和流程。 进程边界的优势来自于社区共识，提前提供了大量开源的优秀基础设施。 但是并不意味着，除了进程边界，我们不能在进程内再为每个 git 仓库划出边界来，只是要付出一些自研代价罢了。 社区共识是不够的，在函数边界（特别是同步调用栈之外的其他调用关系），以及模块边界上都没有足够强的规范。 只要能在公司或者部门级别建立好共识，函数边界和模块边界完全可以满足问题定位的需求，甚至比进程边界做得更好。</p></li></ul></li></ul></li></ul><p><strong>现给出ZXJY公司对于系统的衡量指标。</strong></p><ul><li>rpc 接口总数量。</li><li>接口改动次数 / 接口实现改动次数 比率。</li><li>微服务调用链上依赖关系的数量。</li><li>一次需求平均所需修改的 git 仓库数量</li><li>一个需求上线所需的时间。</li><li>没有循环依赖。依赖和耦合的最大区别在于，当我们说“A和B耦合”时，在字面含义中，A和B二者平等。然而，正确的模块关系根本不应该平等，而应该是单向依赖才对。所以我们应该说“A依赖B”，这样含义要清楚得多。A依赖B意味着，A模块可以调用B模块暴露的API，但B模块绝不允许调用A模块的API。单向依赖是红线，好的设计一定不会违反这条红线。</li><li>正交性：指一个模块提供的API中，多个方法之间是否有重复的功能。</li><li>紧凑性：指一个模块提供的API中，公有方法总数必须很少，每个方法的参数也必须很少。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>核心思路：降低微服务数量。</strong></p><p>为了更好的管理系统的复杂度，减缓系统的腐化，我们的架构目标主要是：</p><ul><li><p>服务接口的合理与简单高于具体功能实现的优雅。系统复杂度主要来自于服务对外的接口，因此我们的架构重点关注接口设计，而内部实现可以相对灵活。</p></li><li><p>易于迭代高于强大的预先设计。当前业务灵活多变而团队经验较为欠缺，很难做好太多预先设计，但系统必须具备快速迭代的能力。</p></li><li><p>团队和系统的自治高于功能复用。功能复用很容易带来沟通成本上升、抽象泄露、以及功能分化的风险。</p></li><li><p>风格的简单一致高于追求技术完美。</p></li><li><p>工具和自动化高于灵活与精确。我们希望尽可能的利用工具和自动化来阻断不合理的设计，降低对人的依赖。</p></li></ul><p><strong>核心方案：区分“项目”和“服务”。一个项目对应一个代码仓库（git repo），规模可以适当大一些，应当包含一个领域内的大部分逻辑。一个服务对应一个进程，可以是项目中的一个 module 或者是一个单独的 entrypoint。基础架构的部署系统提供了便于部署项目的能力，即项目中的代码修改之后，可以自动部署所有关联的服务。</strong></p><p>微服务架构最大的好处是给出了非常清晰的模块边界。以前我们会让一个微服务来对应一个功能模块，导致粒度非常细。问题在于随着业务的变化，边界也是会随之变化的，如果我们过早通过微服务来实现边界，后续修改的成本是极高的。因此我们不应该再轻易独立出微服务，而是尽量在服务内部划分清晰的功能边界。</p><p>目前我们的服务架构都是遵照三层架构，基本分为展示层、逻辑层、存储层，每一层内没有更多划分模块的规范。因为我们把系统功能拆分成为多个微服务，而且之前实践中往往把微服务拆的过小，因此一般逻辑都比较简单，每一层内不隔离问题也不大。不过之后每个微服务要处理相对完整的业务逻辑，粒度会变大，单个服务的复杂度会上升。因此简单的按层次来划分已经不够，此时的最佳实践应当是根据功能来划分。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面剖析电商项目。</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/images/DDD/001/logic_view.png"></p><p><img src="/images/DDD/001/code_struct.png"></p><p>项目整体结构参考六边形架构，将业务逻辑隐藏在 backend 模块内，即六边形的内部。</p><p><img src="/images/DDD/001/code_struct_admin.png"></p><p><img src="/images/DDD/001/code_struct_consumer.png"></p><p><img src="/images/DDD/001/code_struct_job.png"></p><p><img src="/images/DDD/001/code_struct_rpc.png"></p><p><img src="/images/DDD/001/code_struct_web.png"></p><p>admin、consumer、job、rpc、web 都属于接口，分别对应了web（B端与C端）、mq、定时任务、rpc这些系统可能的调用方，满足其需求。可以看出，接口相互之间互不影响，当需要满足新的调用方式时，只需要添加对应的模块，处理对应的请求即可，真正的业务逻辑永远保持在领域内。</p><p><img src="/images/DDD/001/code_struct_client.png"></p><p><img src="/images/DDD/001/code_struct_common.png"></p><p>由于使用 thrift 作为 rpc 协议，故在 common 模块内定义 thrift schema，在 client 封装对于 thrift 借口的调用，方便调用方使用。而 rpc 请求真正的处理者，是前文所讲的 rpc 模块内的 rpc handler。</p><p><img src="/images/DDD/001/code_struct_backend.png"></p><ul><li><p>application</p><p>application 层是对对外所暴露接口的实现，属于主适配器，有编排多个领域以及防腐层的职责。</p><p>usecase 实现了上层所有接口，通过编排各个领域中 service 所提供的基本能力，实现业务动作。如创建订单，我们需要查询商品、修改库存、使用优惠券、创建订单实体等一系列复杂行为，但是他们按照我们之前的领域划分，很有可能分属于不同领域，那么这时候就可以通过 usecase 将他们融合在一起。</p><p>commond/query CQRS模式中的 command 和 query。简单介绍，CQRS是一种读写分离模式，command 代表了对数据产生变化的操作，一般是新增、删除、更新，query 代表了不对数据产生变化的操作，一般是查询。在没有 CQRS 的系统中，不论是何种类型的请求分别经过 controller、service、storage 查询到数据库，再分别经过 storage、service、controller 返回给前端显示。但是从数据层面我们就知道，不同系统对于读写两类请求的需求与支持是不同的。故在 CQRS 模式中，读/写两类请求分别走不同的接口与路径，甚至可以实现为读/写访问不同的数据存储。</p><p>dto 是防腐层数据接口，将外部数据类型与领域内实体解耦。举例来说，thrift 接口使用的数据类型是在 thrift 文件中定义的 struct 通过 thrift 命令行命令生成的，rpc 接口的调用方和提供方都使用此数据结构，但是，领域中肯定使用 entity 实体与 model 值对象作为数据结构，这就需要 dto 作为中间层的数据结构，首先解耦了两边数据结构的直接关联，其次在整个 application 层都可以使用 dto 代表编排聚合后的数据结构。</p></li><li><p>component</p><p>严格来说，component 是真正的领域层，component 包下的每个子包，即对应了 DDD 中的一个子域（对于该项目，仍然是一个限界上下文对于一个子域）。其中 trade 属于核心域，负责交易相关内容，如查询订单、创建订单、预支付（创建支付订单与第三方支付单）、退款订单等。product 负责查询商品、查询优惠券、发送优惠券、使用优惠券、查询礼包等。</p><p>entity 实体是拥有 id（可能是多主键） 的对象。深入的说，抛开具体存储的技术不谈（不管是什么类型的数据库，还是文件等等），实体是可以被它的 id 唯一标识的，除了 id 以外的所有属性，都只是为了描述该实体，不能通过这些属性去判断两个实体是否相等。</p><p>model 值对象是没有 id 的对象。同理，一个值对象就是根据其属性所决定的，但是这里并没有说所有属性，具体判断两个值对象是否相等，由具体业务决定。</p><p>举个例子：社会上有很多人都叫王浩，但是他们的身份证 id 不同，从社会角度来说，他们就是两个完全独立的人。但是，市场上有很多同样品牌、同样款式、同样颜色、同样大小的衣服，在很多场景下，我们在 A 地看见这件衣服，当我们在 B 地再次看见时，就可以说是同一件衣服，我们没有给衣服编号的必要性，我们只是觉得根据这些属性去判断就足够了。当然，再次强调，这只是例子，如果你在开发的是某纺织工厂的系统，就是要为每一批产品，甚至每一件衣服编号，那这就是你的业务所需要的，衣服或许就应该是一个实体。</p><p>除此以外，entity 实体在内存中是可以变化的，可是 model 值对象不可以变化，即 model 值对象查询到以后，其所有属性值都是不可变的，没有 setter 方法。</p><p>port/repository 都属于从适配器，定义了领域所需要的底层逻辑接口。区别是，在此项目中，repository 所定义的接口都属于对某个 entity 实体的 CRUD。port 则没有此限制，仅代表了接口的含义。需要注意的是，现如今有很多 ORM 框架都只需要定义 java interface，由框架本身实现具体的增删改查逻辑，如 Mybatis、Hibernate 等。但是，把这些框架放在六边形架构中，就产生了一个问题，即领域内所定义的 repository 接口，是和具体实现（具体 ORM 框架）所绑定的，这是绝对不允许的，即领域内只关心业务问题，只要牵扯到了底层技术实现问题，那就是错的。所以，在使用这些框架时，我们依然把 repository 接口当作普通的抽象定义，在实现层，用这些框架的写法去定义框架所需要的 interface，来作为对 repository 的实现。</p><p>service 实现了领域内的业务逻辑。如创建订单、创建退款单等，注意，这里的每个动作，都是单一领域内的完整动作，即只是创建了一个“订单”而已（粗暴的理解，只是在订单表插入了一条记录，但这只是为了理解，切记，领域内不关心具体实现，具体实现可能要复杂很多），至于我们平常所认知的创建订单–商品、优惠券、活动等等相关概念的处理，他们都不属于此领域，故 service 中不牵扯这些概念。</p></li><li><p>infrastructure</p><p>六边形架构中的从适配器，用于对接数据、业务逻辑的底层实现，并且承担了防腐层的职责。以电商项目为例，商品、订单等功能对接电商中台，故查看商品详情、创建订单、退款订单等动作，底层数据、甚至逻辑就存储在“电商中台”。优惠券、代币等属于业务部门的功能，底层数据选择使用 mysql 存储。回想之前的主适配器，可以看出在整个六边形架构中，整个架构的依赖方向是向内的，即指向领域中心。用来约定外层行为的方式就是抽象，彻底与外层解耦。</p><p>对于领域内部而言，这些细节是不重要的，领域内不需要清楚具体的实现细节，对它而言，它只是根据约定，即 port/repository 所定义接口中声明的方法与数据结构，来实现领域的业务动作。</p></li></ul><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>微服务数量变少之后，可以很大程度上改善抽象泄露的问题，一个领域内的逻辑可以尽量保持在一个项目内部，不需要对外暴露内部接口。</p></li><li><p>在我们的基础设施足够强悍之前，微服务的数量变少总是可以大大的方便各种基础库的迭代。</p></li><li><p>项目内部的调用不需要过 rpc，可以充分利用 IDE 的自动化重构能力，在运行效率和开发效率上都会有明显提升。</p></li><li><p>项目足够自治，对外部依赖较少，更加便于自动化测试。</p></li><li><p>只有确实跨领域的逻辑才需要对外暴露接口，对于这些接口也可以进行更严格的 code review。如果微服务数量和拆分相对合理，应当期望微服务对外接口的变动是相对少的。这样我们可以强制要求所有涉及到接口变动的修改应当有更加严格的 code review 流程，从而保证系统设计的合理性。而微服务内部的变动可以相对灵活，因为重构和测试的成本都是较小的。</p></li><li><p>更易于消除循环依赖。</p></li><li><p>服务这一层抽象不是为了解决功能的划分，但是提供了两个益处：</p><ul><li>不同服务对应独立进程，提供了一定的运行时隔离，也便于单独扩容</li><li>一些展示层的代码可以放在上层模块中，使得模块之间容易避免循环依赖</li></ul><p>虽然不同服务对应了不同的进程，但是因为底层逻辑和存储都是共享的，因此只是提供了非常有限的隔离性。新建和删除服务的成本相对较低。但是每个服务都需要单独的部署，因此服务拆分也不宜太细。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>仓库规模更大，打包、编译、自动化测试等步骤可能更加耗时，一次部署涉及的服务数量会更多。虽然对于单个仓库的操作效率会降低，但是减少了一次需要所涉及的仓库数量，所以整体效率还是提升的。</li><li>多人开发同一仓库的情况变的更加严重，修改冲突的机会变大。大部分的修改应该是局限在一个 module 内部，甚至 module 内的一个 package 内部，通过限制修改范围，可以很大程度上避免冲突。</li><li>因为迭代是以项目为单位，中间的某些稳定模块也会因为其他模块的更改而多次部署。理论上基础架构的改进应当使得部署本身更加轻松和稳定，不会影响到整个系统的稳定。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Domain Driven Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>editing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO!GO!GO!</title>
    <link href="/2021/08/19/GO-GO-GO/"/>
    <url>/2021/08/19/GO-GO-GO/</url>
    
    <content type="html"><![CDATA[<p>本文是我个人博客的起点，故多说点废话。</p><p>首先说点最近的个人经历吧，有关于我对目前想要探讨的问题在时间上有个脉络。</p><ul><li>我是在研究生一年级入学前开始学习大数据相关知识，如基本思潮、hdoop、spark等，当时在没有实践基础的情况下，主要的学习内容是相关工具/框架的搭建、编码使用以及技术细节。</li><li>在研究生一年级学习中，又系统地学习了大数据相关更多的知识，如Hive、Hbas、Spark &amp; Spark Streaming、Zookeeper等等，所学内容与之前无异。</li><li>与此同时，由于本人导师的原因，又接触到了许多工程/软件工程/敏捷相关的思想课程，如《精益创业》、看板、Scrum、极限编程等（有愧的是一直没有深入系统的去看过DevOps相关书籍，只是泛泛地看过大佬们的博客，就不当作学习吧）。</li><li>再之后，即2019年上半年在上海的某家公司实习时，由于所处项目正在微服务化改造，故又去系统学习了微服务，主要书籍有《微服务架构设计模式》、《微服务设计》、《Spring 微服务实战》、Martin Flower等大佬们的各种博客，有了微服务，就总有一个绕不过去的坎–如何拆分为服务？之前的这些文章中，都或多或少的讲解过这个问题，也或明或暗的牵扯到了DDD、六边形架构、整洁架构等概念。</li><li>我实习所处的产品组，做的事简单说就是「AI模型部署」，这个过程中涉及到的知识有云计算相关（k8s、网关、灰度/蓝绿/金丝雀部署、集群监控、集群报警）、DevOps相关。</li><li>后续回到学校，又去研究了分布式相关的概念和知识，这里要重重的推荐一本书–《数据密集型应用系统设计》。</li><li>研究生毕业后，我去某国企参加了他们电商项目的微服务化改造项目，与之前的实习相比，这次我去的早，真正的从0到1体验到了到了这个过程。</li><li>工作一年不到，因为一些个人原因，跳槽到了一家互联网企业。在这里，除了日常的业务工作，我们开始了对之前微服务项目的整合（这个后续会细说，又是一个电商迁移项目，但整个公司所面对的问题简单说就是微服务一开始拆的太细了），项目结构是面向DDD的，整个开发过程中的设计策略也是DDD的那一套，我们按下不表。</li></ul><p>说了这么多细枝末节，连云计算和大数据都扯出来了，我这是要干嘛？其实我一直有一种糊涂的感觉，就是我觉得我刚才所说的这些知识，它们是有深刻联系的，在思想上、在技术上都有，我想要理清这个脉络，所以我需要按照一些方式去梳理他。所以我开启了我的博客行，旨在解决个人问题……^_^</p><p>什么联系？</p><p>细节不说，我所学习的大数据知识告诉我最重要的思想是「分而治之」，除此以外，我在学习大数据相关框架/工具的技术细节时，与之后学习分布式相关的知识不谋而合，或者说，大数据相关工具就是对这些分布式理论知识的实践（所以学习分布式时接受的也特别快～）。在微服务的整个学习过程中，分布式的影子无处不。，在思想层面，「分而治之」依旧影响着一切。至于底层的实现细节，微服务与分布式所面对的问题，也有了联系上。还是那个问题，如何拆分微服务？又引出了DDD、六边形架构等等，那么去看这些概念，「分而治之」再一次在另一个维度闪耀。</p><p>这或许就是我目前所能写出的联系吧，但我觉得不止于此处，故现在开始我的学习之旅，在未来的一段时间，我想要探究以下问题。</p><ul><li>微服务、DDD、六边形等架构、DevOps、分布式之间的关系</li><li>这些技术的历史发展</li><li>这些技术的细节探究</li><li>相关架构的研讨</li></ul><p>内容很多，路也很长，我一步一步走，就今年而言，重点放在以下两个系列。</p><ul><li>DDD 理论/实践总结</li><li>以时间轴为视角，总结各架构核心理念（灵感来源）</li></ul><p>那，就开始吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>finish</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
